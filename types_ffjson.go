// Code generated by ffjson <https://github.com/pquerna/ffjson>. DO NOT EDIT.
// source: types.go

package telegram

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

// MarshalJSON marshal bytes to json - template
func (j *Animation) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Animation) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(j.FileID))
	buf.WriteByte(',')
	if len(j.FileName) != 0 {
		buf.WriteString(`"file_name":`)
		fflib.WriteJsonString(buf, string(j.FileName))
		buf.WriteByte(',')
	}
	if len(j.MimeType) != 0 {
		buf.WriteString(`"mime_type":`)
		fflib.WriteJsonString(buf, string(j.MimeType))
		buf.WriteByte(',')
	}
	if j.Thumb != nil {
		if true {
			buf.WriteString(`"thumb":`)

			{

				err = j.Thumb.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(j.FileSize), 10, j.FileSize < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtAnimationbase = iota
	ffjtAnimationnosuchkey

	ffjtAnimationFileID

	ffjtAnimationFileName

	ffjtAnimationMimeType

	ffjtAnimationThumb

	ffjtAnimationFileSize
)

var ffjKeyAnimationFileID = []byte("file_id")

var ffjKeyAnimationFileName = []byte("file_name")

var ffjKeyAnimationMimeType = []byte("mime_type")

var ffjKeyAnimationThumb = []byte("thumb")

var ffjKeyAnimationFileSize = []byte("file_size")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Animation) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Animation) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtAnimationbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtAnimationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyAnimationFileID, kn) {
						currentKey = ffjtAnimationFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAnimationFileName, kn) {
						currentKey = ffjtAnimationFileName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAnimationFileSize, kn) {
						currentKey = ffjtAnimationFileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyAnimationMimeType, kn) {
						currentKey = ffjtAnimationMimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyAnimationThumb, kn) {
						currentKey = ffjtAnimationThumb
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyAnimationFileSize, kn) {
					currentKey = ffjtAnimationFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAnimationThumb, kn) {
					currentKey = ffjtAnimationThumb
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAnimationMimeType, kn) {
					currentKey = ffjtAnimationMimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAnimationFileName, kn) {
					currentKey = ffjtAnimationFileName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAnimationFileID, kn) {
					currentKey = ffjtAnimationFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtAnimationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtAnimationFileID:
					goto handle_FileID

				case ffjtAnimationFileName:
					goto handle_FileName

				case ffjtAnimationMimeType:
					goto handle_MimeType

				case ffjtAnimationThumb:
					goto handle_Thumb

				case ffjtAnimationFileSize:
					goto handle_FileSize

				case ffjtAnimationnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: j.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileName:

	/* handler: j.FileName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeType:

	/* handler: j.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Thumb:

	/* handler: j.Thumb type=telegram.PhotoSize kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Thumb = nil

		} else {

			if j.Thumb == nil {
				j.Thumb = new(PhotoSize)
			}

			err = j.Thumb.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: j.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Audio) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Audio) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(j.FileID))
	buf.WriteByte(',')
	if len(j.Performer) != 0 {
		buf.WriteString(`"performer":`)
		fflib.WriteJsonString(buf, string(j.Performer))
		buf.WriteByte(',')
	}
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	if len(j.MimeType) != 0 {
		buf.WriteString(`"mime_type":`)
		fflib.WriteJsonString(buf, string(j.MimeType))
		buf.WriteByte(',')
	}
	buf.WriteString(`"duration":`)
	fflib.FormatBits2(buf, uint64(j.Duration), 10, j.Duration < 0)
	buf.WriteByte(',')
	if j.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(j.FileSize), 10, j.FileSize < 0)
		buf.WriteByte(',')
	}
	if j.Thumb != nil {
		if true {
			buf.WriteString(`"thumb":`)

			{

				err = j.Thumb.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtAudiobase = iota
	ffjtAudionosuchkey

	ffjtAudioFileID

	ffjtAudioPerformer

	ffjtAudioTitle

	ffjtAudioMimeType

	ffjtAudioDuration

	ffjtAudioFileSize

	ffjtAudioThumb
)

var ffjKeyAudioFileID = []byte("file_id")

var ffjKeyAudioPerformer = []byte("performer")

var ffjKeyAudioTitle = []byte("title")

var ffjKeyAudioMimeType = []byte("mime_type")

var ffjKeyAudioDuration = []byte("duration")

var ffjKeyAudioFileSize = []byte("file_size")

var ffjKeyAudioThumb = []byte("thumb")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Audio) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Audio) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtAudiobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtAudionosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyAudioDuration, kn) {
						currentKey = ffjtAudioDuration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyAudioFileID, kn) {
						currentKey = ffjtAudioFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAudioFileSize, kn) {
						currentKey = ffjtAudioFileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyAudioMimeType, kn) {
						currentKey = ffjtAudioMimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyAudioPerformer, kn) {
						currentKey = ffjtAudioPerformer
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyAudioTitle, kn) {
						currentKey = ffjtAudioTitle
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAudioThumb, kn) {
						currentKey = ffjtAudioThumb
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyAudioThumb, kn) {
					currentKey = ffjtAudioThumb
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAudioFileSize, kn) {
					currentKey = ffjtAudioFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAudioDuration, kn) {
					currentKey = ffjtAudioDuration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAudioMimeType, kn) {
					currentKey = ffjtAudioMimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAudioTitle, kn) {
					currentKey = ffjtAudioTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAudioPerformer, kn) {
					currentKey = ffjtAudioPerformer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAudioFileID, kn) {
					currentKey = ffjtAudioFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtAudionosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtAudioFileID:
					goto handle_FileID

				case ffjtAudioPerformer:
					goto handle_Performer

				case ffjtAudioTitle:
					goto handle_Title

				case ffjtAudioMimeType:
					goto handle_MimeType

				case ffjtAudioDuration:
					goto handle_Duration

				case ffjtAudioFileSize:
					goto handle_FileSize

				case ffjtAudioThumb:
					goto handle_Thumb

				case ffjtAudionosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: j.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Performer:

	/* handler: j.Performer type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Performer = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeType:

	/* handler: j.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: j.Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: j.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Thumb:

	/* handler: j.Thumb type=telegram.PhotoSize kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Thumb = nil

		} else {

			if j.Thumb == nil {
				j.Thumb = new(PhotoSize)
			}

			err = j.Thumb.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *AuthParameters) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *AuthParameters) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"bot_id":`)
	fflib.FormatBits2(buf, uint64(j.BotID), 10, j.BotID < 0)
	buf.WriteString(`,"scope":`)

	{

		err = j.Scope.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"public_key":`)
	fflib.WriteJsonString(buf, string(j.PublicKey))
	buf.WriteString(`,"nonce":`)
	fflib.WriteJsonString(buf, string(j.Nonce))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtAuthParametersbase = iota
	ffjtAuthParametersnosuchkey

	ffjtAuthParametersBotID

	ffjtAuthParametersScope

	ffjtAuthParametersPublicKey

	ffjtAuthParametersNonce
)

var ffjKeyAuthParametersBotID = []byte("bot_id")

var ffjKeyAuthParametersScope = []byte("scope")

var ffjKeyAuthParametersPublicKey = []byte("public_key")

var ffjKeyAuthParametersNonce = []byte("nonce")

// UnmarshalJSON umarshall json - template of ffjson
func (j *AuthParameters) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *AuthParameters) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtAuthParametersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtAuthParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffjKeyAuthParametersBotID, kn) {
						currentKey = ffjtAuthParametersBotID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyAuthParametersNonce, kn) {
						currentKey = ffjtAuthParametersNonce
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyAuthParametersPublicKey, kn) {
						currentKey = ffjtAuthParametersPublicKey
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyAuthParametersScope, kn) {
						currentKey = ffjtAuthParametersScope
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyAuthParametersNonce, kn) {
					currentKey = ffjtAuthParametersNonce
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAuthParametersPublicKey, kn) {
					currentKey = ffjtAuthParametersPublicKey
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAuthParametersScope, kn) {
					currentKey = ffjtAuthParametersScope
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAuthParametersBotID, kn) {
					currentKey = ffjtAuthParametersBotID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtAuthParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtAuthParametersBotID:
					goto handle_BotID

				case ffjtAuthParametersScope:
					goto handle_Scope

				case ffjtAuthParametersPublicKey:
					goto handle_PublicKey

				case ffjtAuthParametersNonce:
					goto handle_Nonce

				case ffjtAuthParametersnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_BotID:

	/* handler: j.BotID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.BotID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Scope:

	/* handler: j.Scope type=telegram.PassportScope kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Scope.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PublicKey:

	/* handler: j.PublicKey type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PublicKey = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Nonce:

	/* handler: j.Nonce type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Nonce = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *CallbackGame) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *CallbackGame) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{}`)
	return nil
}

const (
	ffjtCallbackGamebase = iota
	ffjtCallbackGamenosuchkey
)

// UnmarshalJSON umarshall json - template of ffjson
func (j *CallbackGame) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *CallbackGame) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtCallbackGamebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtCallbackGamenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				}

				currentKey = ffjtCallbackGamenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtCallbackGamenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *CallbackQuery) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *CallbackQuery) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteByte(',')
	if len(j.InlineMessageID) != 0 {
		buf.WriteString(`"inline_message_id":`)
		fflib.WriteJsonString(buf, string(j.InlineMessageID))
		buf.WriteByte(',')
	}
	buf.WriteString(`"chat_instance":`)
	fflib.WriteJsonString(buf, string(j.ChatInstance))
	buf.WriteByte(',')
	if len(j.Data) != 0 {
		buf.WriteString(`"data":`)
		fflib.WriteJsonString(buf, string(j.Data))
		buf.WriteByte(',')
	}
	if len(j.GameShortName) != 0 {
		buf.WriteString(`"game_short_name":`)
		fflib.WriteJsonString(buf, string(j.GameShortName))
		buf.WriteByte(',')
	}
	if j.From != nil {
		buf.WriteString(`"from":`)

		{

			err = j.From.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`"from":null`)
	}
	buf.WriteByte(',')
	if j.Message != nil {
		if true {
			buf.WriteString(`"message":`)

			{

				err = j.Message.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtCallbackQuerybase = iota
	ffjtCallbackQuerynosuchkey

	ffjtCallbackQueryID

	ffjtCallbackQueryInlineMessageID

	ffjtCallbackQueryChatInstance

	ffjtCallbackQueryData

	ffjtCallbackQueryGameShortName

	ffjtCallbackQueryFrom

	ffjtCallbackQueryMessage
)

var ffjKeyCallbackQueryID = []byte("id")

var ffjKeyCallbackQueryInlineMessageID = []byte("inline_message_id")

var ffjKeyCallbackQueryChatInstance = []byte("chat_instance")

var ffjKeyCallbackQueryData = []byte("data")

var ffjKeyCallbackQueryGameShortName = []byte("game_short_name")

var ffjKeyCallbackQueryFrom = []byte("from")

var ffjKeyCallbackQueryMessage = []byte("message")

// UnmarshalJSON umarshall json - template of ffjson
func (j *CallbackQuery) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *CallbackQuery) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtCallbackQuerybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtCallbackQuerynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyCallbackQueryChatInstance, kn) {
						currentKey = ffjtCallbackQueryChatInstance
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyCallbackQueryData, kn) {
						currentKey = ffjtCallbackQueryData
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyCallbackQueryFrom, kn) {
						currentKey = ffjtCallbackQueryFrom
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyCallbackQueryGameShortName, kn) {
						currentKey = ffjtCallbackQueryGameShortName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyCallbackQueryID, kn) {
						currentKey = ffjtCallbackQueryID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCallbackQueryInlineMessageID, kn) {
						currentKey = ffjtCallbackQueryInlineMessageID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyCallbackQueryMessage, kn) {
						currentKey = ffjtCallbackQueryMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyCallbackQueryMessage, kn) {
					currentKey = ffjtCallbackQueryMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyCallbackQueryFrom, kn) {
					currentKey = ffjtCallbackQueryFrom
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCallbackQueryGameShortName, kn) {
					currentKey = ffjtCallbackQueryGameShortName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyCallbackQueryData, kn) {
					currentKey = ffjtCallbackQueryData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCallbackQueryChatInstance, kn) {
					currentKey = ffjtCallbackQueryChatInstance
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCallbackQueryInlineMessageID, kn) {
					currentKey = ffjtCallbackQueryInlineMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyCallbackQueryID, kn) {
					currentKey = ffjtCallbackQueryID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtCallbackQuerynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtCallbackQueryID:
					goto handle_ID

				case ffjtCallbackQueryInlineMessageID:
					goto handle_InlineMessageID

				case ffjtCallbackQueryChatInstance:
					goto handle_ChatInstance

				case ffjtCallbackQueryData:
					goto handle_Data

				case ffjtCallbackQueryGameShortName:
					goto handle_GameShortName

				case ffjtCallbackQueryFrom:
					goto handle_From

				case ffjtCallbackQueryMessage:
					goto handle_Message

				case ffjtCallbackQuerynosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InlineMessageID:

	/* handler: j.InlineMessageID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.InlineMessageID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChatInstance:

	/* handler: j.ChatInstance type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ChatInstance = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: j.Data type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Data = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GameShortName:

	/* handler: j.GameShortName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.GameShortName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_From:

	/* handler: j.From type=telegram.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.From = nil

		} else {

			if j.From == nil {
				j.From = new(User)
			}

			err = j.From.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: j.Message type=telegram.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Message = nil

		} else {

			if j.Message == nil {
				j.Message = new(Message)
			}

			err = j.Message.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Chat) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Chat) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)
	fflib.FormatBits2(buf, uint64(j.ID), 10, j.ID < 0)
	buf.WriteString(`,"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteByte(',')
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	if len(j.Username) != 0 {
		buf.WriteString(`"username":`)
		fflib.WriteJsonString(buf, string(j.Username))
		buf.WriteByte(',')
	}
	if len(j.FirstName) != 0 {
		buf.WriteString(`"first_name":`)
		fflib.WriteJsonString(buf, string(j.FirstName))
		buf.WriteByte(',')
	}
	if len(j.LastName) != 0 {
		buf.WriteString(`"last_name":`)
		fflib.WriteJsonString(buf, string(j.LastName))
		buf.WriteByte(',')
	}
	if j.AllMembersAreAdministrators != false {
		if j.AllMembersAreAdministrators {
			buf.WriteString(`"all_members_are_administrators":true`)
		} else {
			buf.WriteString(`"all_members_are_administrators":false`)
		}
		buf.WriteByte(',')
	}
	if j.Photo != nil {
		if true {
			buf.WriteString(`"photo":`)

			{

				err = j.Photo.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.Description) != 0 {
		buf.WriteString(`"description":`)
		fflib.WriteJsonString(buf, string(j.Description))
		buf.WriteByte(',')
	}
	if len(j.InviteLink) != 0 {
		buf.WriteString(`"invite_link":`)
		fflib.WriteJsonString(buf, string(j.InviteLink))
		buf.WriteByte(',')
	}
	if j.PinnedMessage != nil {
		if true {
			buf.WriteString(`"pinned_message":`)

			{

				err = j.PinnedMessage.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.StickerSetName) != 0 {
		buf.WriteString(`"sticker_set_name":`)
		fflib.WriteJsonString(buf, string(j.StickerSetName))
		buf.WriteByte(',')
	}
	if j.CanSetStickerSet != false {
		if j.CanSetStickerSet {
			buf.WriteString(`"can_set_sticker_set":true`)
		} else {
			buf.WriteString(`"can_set_sticker_set":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChatbase = iota
	ffjtChatnosuchkey

	ffjtChatID

	ffjtChatType

	ffjtChatTitle

	ffjtChatUsername

	ffjtChatFirstName

	ffjtChatLastName

	ffjtChatAllMembersAreAdministrators

	ffjtChatPhoto

	ffjtChatDescription

	ffjtChatInviteLink

	ffjtChatPinnedMessage

	ffjtChatStickerSetName

	ffjtChatCanSetStickerSet
)

var ffjKeyChatID = []byte("id")

var ffjKeyChatType = []byte("type")

var ffjKeyChatTitle = []byte("title")

var ffjKeyChatUsername = []byte("username")

var ffjKeyChatFirstName = []byte("first_name")

var ffjKeyChatLastName = []byte("last_name")

var ffjKeyChatAllMembersAreAdministrators = []byte("all_members_are_administrators")

var ffjKeyChatPhoto = []byte("photo")

var ffjKeyChatDescription = []byte("description")

var ffjKeyChatInviteLink = []byte("invite_link")

var ffjKeyChatPinnedMessage = []byte("pinned_message")

var ffjKeyChatStickerSetName = []byte("sticker_set_name")

var ffjKeyChatCanSetStickerSet = []byte("can_set_sticker_set")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Chat) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Chat) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChatbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChatnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyChatAllMembersAreAdministrators, kn) {
						currentKey = ffjtChatAllMembersAreAdministrators
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyChatCanSetStickerSet, kn) {
						currentKey = ffjtChatCanSetStickerSet
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyChatDescription, kn) {
						currentKey = ffjtChatDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyChatFirstName, kn) {
						currentKey = ffjtChatFirstName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyChatID, kn) {
						currentKey = ffjtChatID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatInviteLink, kn) {
						currentKey = ffjtChatInviteLink
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyChatLastName, kn) {
						currentKey = ffjtChatLastName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyChatPhoto, kn) {
						currentKey = ffjtChatPhoto
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatPinnedMessage, kn) {
						currentKey = ffjtChatPinnedMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyChatStickerSetName, kn) {
						currentKey = ffjtChatStickerSetName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyChatType, kn) {
						currentKey = ffjtChatType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatTitle, kn) {
						currentKey = ffjtChatTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyChatUsername, kn) {
						currentKey = ffjtChatUsername
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyChatCanSetStickerSet, kn) {
					currentKey = ffjtChatCanSetStickerSet
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatStickerSetName, kn) {
					currentKey = ffjtChatStickerSetName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatPinnedMessage, kn) {
					currentKey = ffjtChatPinnedMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatInviteLink, kn) {
					currentKey = ffjtChatInviteLink
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatDescription, kn) {
					currentKey = ffjtChatDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChatPhoto, kn) {
					currentKey = ffjtChatPhoto
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatAllMembersAreAdministrators, kn) {
					currentKey = ffjtChatAllMembersAreAdministrators
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatLastName, kn) {
					currentKey = ffjtChatLastName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatFirstName, kn) {
					currentKey = ffjtChatFirstName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatUsername, kn) {
					currentKey = ffjtChatUsername
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChatTitle, kn) {
					currentKey = ffjtChatTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChatType, kn) {
					currentKey = ffjtChatType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChatID, kn) {
					currentKey = ffjtChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChatnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChatID:
					goto handle_ID

				case ffjtChatType:
					goto handle_Type

				case ffjtChatTitle:
					goto handle_Title

				case ffjtChatUsername:
					goto handle_Username

				case ffjtChatFirstName:
					goto handle_FirstName

				case ffjtChatLastName:
					goto handle_LastName

				case ffjtChatAllMembersAreAdministrators:
					goto handle_AllMembersAreAdministrators

				case ffjtChatPhoto:
					goto handle_Photo

				case ffjtChatDescription:
					goto handle_Description

				case ffjtChatInviteLink:
					goto handle_InviteLink

				case ffjtChatPinnedMessage:
					goto handle_PinnedMessage

				case ffjtChatStickerSetName:
					goto handle_StickerSetName

				case ffjtChatCanSetStickerSet:
					goto handle_CanSetStickerSet

				case ffjtChatnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Username:

	/* handler: j.Username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FirstName:

	/* handler: j.FirstName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FirstName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastName:

	/* handler: j.LastName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LastName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AllMembersAreAdministrators:

	/* handler: j.AllMembersAreAdministrators type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.AllMembersAreAdministrators = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.AllMembersAreAdministrators = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Photo:

	/* handler: j.Photo type=telegram.ChatPhoto kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Photo = nil

		} else {

			if j.Photo == nil {
				j.Photo = new(ChatPhoto)
			}

			err = j.Photo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InviteLink:

	/* handler: j.InviteLink type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.InviteLink = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PinnedMessage:

	/* handler: j.PinnedMessage type=telegram.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.PinnedMessage = nil

		} else {

			if j.PinnedMessage == nil {
				j.PinnedMessage = new(Message)
			}

			err = j.PinnedMessage.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StickerSetName:

	/* handler: j.StickerSetName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.StickerSetName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanSetStickerSet:

	/* handler: j.CanSetStickerSet type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanSetStickerSet = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanSetStickerSet = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChatMember) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChatMember) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.User != nil {
		buf.WriteString(`{ "user":`)

		{

			err = j.User.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`{ "user":null`)
	}
	buf.WriteString(`,"status":`)
	fflib.WriteJsonString(buf, string(j.Status))
	buf.WriteByte(',')
	if j.UntilDate != 0 {
		buf.WriteString(`"until_date":`)
		fflib.FormatBits2(buf, uint64(j.UntilDate), 10, j.UntilDate < 0)
		buf.WriteByte(',')
	}
	if j.CanBeEdited != false {
		if j.CanBeEdited {
			buf.WriteString(`"can_be_edited":true`)
		} else {
			buf.WriteString(`"can_be_edited":false`)
		}
		buf.WriteByte(',')
	}
	if j.CanChangeInfo != false {
		if j.CanChangeInfo {
			buf.WriteString(`"can_change_info":true`)
		} else {
			buf.WriteString(`"can_change_info":false`)
		}
		buf.WriteByte(',')
	}
	if j.CanPostMessages != false {
		if j.CanPostMessages {
			buf.WriteString(`"can_post_messages":true`)
		} else {
			buf.WriteString(`"can_post_messages":false`)
		}
		buf.WriteByte(',')
	}
	if j.CanEditMessages != false {
		if j.CanEditMessages {
			buf.WriteString(`"can_edit_messages":true`)
		} else {
			buf.WriteString(`"can_edit_messages":false`)
		}
		buf.WriteByte(',')
	}
	if j.CanDeleteMessages != false {
		if j.CanDeleteMessages {
			buf.WriteString(`"can_delete_messages":true`)
		} else {
			buf.WriteString(`"can_delete_messages":false`)
		}
		buf.WriteByte(',')
	}
	if j.CanInviteUsers != false {
		if j.CanInviteUsers {
			buf.WriteString(`"can_invite_users":true`)
		} else {
			buf.WriteString(`"can_invite_users":false`)
		}
		buf.WriteByte(',')
	}
	if j.CanRestrictMembers != false {
		if j.CanRestrictMembers {
			buf.WriteString(`"can_restrict_members":true`)
		} else {
			buf.WriteString(`"can_restrict_members":false`)
		}
		buf.WriteByte(',')
	}
	if j.CanPinMessages != false {
		if j.CanPinMessages {
			buf.WriteString(`"can_pin_messages":true`)
		} else {
			buf.WriteString(`"can_pin_messages":false`)
		}
		buf.WriteByte(',')
	}
	if j.CanPromoteMembers != false {
		if j.CanPromoteMembers {
			buf.WriteString(`"can_promote_members":true`)
		} else {
			buf.WriteString(`"can_promote_members":false`)
		}
		buf.WriteByte(',')
	}
	if j.IsMember != false {
		if j.IsMember {
			buf.WriteString(`"is_member":true`)
		} else {
			buf.WriteString(`"is_member":false`)
		}
		buf.WriteByte(',')
	}
	if j.CanSendMessages != false {
		if j.CanSendMessages {
			buf.WriteString(`"can_send_messages":true`)
		} else {
			buf.WriteString(`"can_send_messages":false`)
		}
		buf.WriteByte(',')
	}
	if j.CanSendMediaMessages != false {
		if j.CanSendMediaMessages {
			buf.WriteString(`"can_send_media_messages":true`)
		} else {
			buf.WriteString(`"can_send_media_messages":false`)
		}
		buf.WriteByte(',')
	}
	if j.CanSendOtherMessages != false {
		if j.CanSendOtherMessages {
			buf.WriteString(`"can_send_other_messages":true`)
		} else {
			buf.WriteString(`"can_send_other_messages":false`)
		}
		buf.WriteByte(',')
	}
	if j.CanAddWebPagePreviews != false {
		if j.CanAddWebPagePreviews {
			buf.WriteString(`"can_add_web_page_previews":true`)
		} else {
			buf.WriteString(`"can_add_web_page_previews":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChatMemberbase = iota
	ffjtChatMembernosuchkey

	ffjtChatMemberUser

	ffjtChatMemberStatus

	ffjtChatMemberUntilDate

	ffjtChatMemberCanBeEdited

	ffjtChatMemberCanChangeInfo

	ffjtChatMemberCanPostMessages

	ffjtChatMemberCanEditMessages

	ffjtChatMemberCanDeleteMessages

	ffjtChatMemberCanInviteUsers

	ffjtChatMemberCanRestrictMembers

	ffjtChatMemberCanPinMessages

	ffjtChatMemberCanPromoteMembers

	ffjtChatMemberIsMember

	ffjtChatMemberCanSendMessages

	ffjtChatMemberCanSendMediaMessages

	ffjtChatMemberCanSendOtherMessages

	ffjtChatMemberCanAddWebPagePreviews
)

var ffjKeyChatMemberUser = []byte("user")

var ffjKeyChatMemberStatus = []byte("status")

var ffjKeyChatMemberUntilDate = []byte("until_date")

var ffjKeyChatMemberCanBeEdited = []byte("can_be_edited")

var ffjKeyChatMemberCanChangeInfo = []byte("can_change_info")

var ffjKeyChatMemberCanPostMessages = []byte("can_post_messages")

var ffjKeyChatMemberCanEditMessages = []byte("can_edit_messages")

var ffjKeyChatMemberCanDeleteMessages = []byte("can_delete_messages")

var ffjKeyChatMemberCanInviteUsers = []byte("can_invite_users")

var ffjKeyChatMemberCanRestrictMembers = []byte("can_restrict_members")

var ffjKeyChatMemberCanPinMessages = []byte("can_pin_messages")

var ffjKeyChatMemberCanPromoteMembers = []byte("can_promote_members")

var ffjKeyChatMemberIsMember = []byte("is_member")

var ffjKeyChatMemberCanSendMessages = []byte("can_send_messages")

var ffjKeyChatMemberCanSendMediaMessages = []byte("can_send_media_messages")

var ffjKeyChatMemberCanSendOtherMessages = []byte("can_send_other_messages")

var ffjKeyChatMemberCanAddWebPagePreviews = []byte("can_add_web_page_previews")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChatMember) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChatMember) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChatMemberbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChatMembernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyChatMemberCanBeEdited, kn) {
						currentKey = ffjtChatMemberCanBeEdited
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberCanChangeInfo, kn) {
						currentKey = ffjtChatMemberCanChangeInfo
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberCanPostMessages, kn) {
						currentKey = ffjtChatMemberCanPostMessages
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberCanEditMessages, kn) {
						currentKey = ffjtChatMemberCanEditMessages
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberCanDeleteMessages, kn) {
						currentKey = ffjtChatMemberCanDeleteMessages
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberCanInviteUsers, kn) {
						currentKey = ffjtChatMemberCanInviteUsers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberCanRestrictMembers, kn) {
						currentKey = ffjtChatMemberCanRestrictMembers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberCanPinMessages, kn) {
						currentKey = ffjtChatMemberCanPinMessages
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberCanPromoteMembers, kn) {
						currentKey = ffjtChatMemberCanPromoteMembers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberCanSendMessages, kn) {
						currentKey = ffjtChatMemberCanSendMessages
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberCanSendMediaMessages, kn) {
						currentKey = ffjtChatMemberCanSendMediaMessages
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberCanSendOtherMessages, kn) {
						currentKey = ffjtChatMemberCanSendOtherMessages
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberCanAddWebPagePreviews, kn) {
						currentKey = ffjtChatMemberCanAddWebPagePreviews
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyChatMemberIsMember, kn) {
						currentKey = ffjtChatMemberIsMember
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyChatMemberStatus, kn) {
						currentKey = ffjtChatMemberStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyChatMemberUser, kn) {
						currentKey = ffjtChatMemberUser
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberUntilDate, kn) {
						currentKey = ffjtChatMemberUntilDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyChatMemberCanAddWebPagePreviews, kn) {
					currentKey = ffjtChatMemberCanAddWebPagePreviews
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberCanSendOtherMessages, kn) {
					currentKey = ffjtChatMemberCanSendOtherMessages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberCanSendMediaMessages, kn) {
					currentKey = ffjtChatMemberCanSendMediaMessages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberCanSendMessages, kn) {
					currentKey = ffjtChatMemberCanSendMessages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberIsMember, kn) {
					currentKey = ffjtChatMemberIsMember
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberCanPromoteMembers, kn) {
					currentKey = ffjtChatMemberCanPromoteMembers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberCanPinMessages, kn) {
					currentKey = ffjtChatMemberCanPinMessages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberCanRestrictMembers, kn) {
					currentKey = ffjtChatMemberCanRestrictMembers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberCanInviteUsers, kn) {
					currentKey = ffjtChatMemberCanInviteUsers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberCanDeleteMessages, kn) {
					currentKey = ffjtChatMemberCanDeleteMessages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberCanEditMessages, kn) {
					currentKey = ffjtChatMemberCanEditMessages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberCanPostMessages, kn) {
					currentKey = ffjtChatMemberCanPostMessages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChatMemberCanChangeInfo, kn) {
					currentKey = ffjtChatMemberCanChangeInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChatMemberCanBeEdited, kn) {
					currentKey = ffjtChatMemberCanBeEdited
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChatMemberUntilDate, kn) {
					currentKey = ffjtChatMemberUntilDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberStatus, kn) {
					currentKey = ffjtChatMemberStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberUser, kn) {
					currentKey = ffjtChatMemberUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChatMembernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChatMemberUser:
					goto handle_User

				case ffjtChatMemberStatus:
					goto handle_Status

				case ffjtChatMemberUntilDate:
					goto handle_UntilDate

				case ffjtChatMemberCanBeEdited:
					goto handle_CanBeEdited

				case ffjtChatMemberCanChangeInfo:
					goto handle_CanChangeInfo

				case ffjtChatMemberCanPostMessages:
					goto handle_CanPostMessages

				case ffjtChatMemberCanEditMessages:
					goto handle_CanEditMessages

				case ffjtChatMemberCanDeleteMessages:
					goto handle_CanDeleteMessages

				case ffjtChatMemberCanInviteUsers:
					goto handle_CanInviteUsers

				case ffjtChatMemberCanRestrictMembers:
					goto handle_CanRestrictMembers

				case ffjtChatMemberCanPinMessages:
					goto handle_CanPinMessages

				case ffjtChatMemberCanPromoteMembers:
					goto handle_CanPromoteMembers

				case ffjtChatMemberIsMember:
					goto handle_IsMember

				case ffjtChatMemberCanSendMessages:
					goto handle_CanSendMessages

				case ffjtChatMemberCanSendMediaMessages:
					goto handle_CanSendMediaMessages

				case ffjtChatMemberCanSendOtherMessages:
					goto handle_CanSendOtherMessages

				case ffjtChatMemberCanAddWebPagePreviews:
					goto handle_CanAddWebPagePreviews

				case ffjtChatMembernosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_User:

	/* handler: j.User type=telegram.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.User = nil

		} else {

			if j.User == nil {
				j.User = new(User)
			}

			err = j.User.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: j.Status type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Status = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UntilDate:

	/* handler: j.UntilDate type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.UntilDate = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanBeEdited:

	/* handler: j.CanBeEdited type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanBeEdited = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanBeEdited = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanChangeInfo:

	/* handler: j.CanChangeInfo type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanChangeInfo = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanChangeInfo = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanPostMessages:

	/* handler: j.CanPostMessages type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanPostMessages = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanPostMessages = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanEditMessages:

	/* handler: j.CanEditMessages type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanEditMessages = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanEditMessages = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanDeleteMessages:

	/* handler: j.CanDeleteMessages type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanDeleteMessages = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanDeleteMessages = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanInviteUsers:

	/* handler: j.CanInviteUsers type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanInviteUsers = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanInviteUsers = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanRestrictMembers:

	/* handler: j.CanRestrictMembers type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanRestrictMembers = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanRestrictMembers = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanPinMessages:

	/* handler: j.CanPinMessages type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanPinMessages = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanPinMessages = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanPromoteMembers:

	/* handler: j.CanPromoteMembers type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanPromoteMembers = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanPromoteMembers = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsMember:

	/* handler: j.IsMember type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.IsMember = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.IsMember = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanSendMessages:

	/* handler: j.CanSendMessages type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanSendMessages = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanSendMessages = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanSendMediaMessages:

	/* handler: j.CanSendMediaMessages type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanSendMediaMessages = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanSendMediaMessages = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanSendOtherMessages:

	/* handler: j.CanSendOtherMessages type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanSendOtherMessages = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanSendOtherMessages = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanAddWebPagePreviews:

	/* handler: j.CanAddWebPagePreviews type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanAddWebPagePreviews = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanAddWebPagePreviews = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChatPhoto) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChatPhoto) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"small_file_id":`)
	fflib.WriteJsonString(buf, string(j.SmallFileID))
	buf.WriteString(`,"big_file_id":`)
	fflib.WriteJsonString(buf, string(j.BigFileID))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChatPhotobase = iota
	ffjtChatPhotonosuchkey

	ffjtChatPhotoSmallFileID

	ffjtChatPhotoBigFileID
)

var ffjKeyChatPhotoSmallFileID = []byte("small_file_id")

var ffjKeyChatPhotoBigFileID = []byte("big_file_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChatPhoto) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChatPhoto) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChatPhotobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChatPhotonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffjKeyChatPhotoBigFileID, kn) {
						currentKey = ffjtChatPhotoBigFileID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyChatPhotoSmallFileID, kn) {
						currentKey = ffjtChatPhotoSmallFileID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyChatPhotoBigFileID, kn) {
					currentKey = ffjtChatPhotoBigFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatPhotoSmallFileID, kn) {
					currentKey = ffjtChatPhotoSmallFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChatPhotonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChatPhotoSmallFileID:
					goto handle_SmallFileID

				case ffjtChatPhotoBigFileID:
					goto handle_BigFileID

				case ffjtChatPhotonosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_SmallFileID:

	/* handler: j.SmallFileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.SmallFileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BigFileID:

	/* handler: j.BigFileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.BigFileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChosenInlineResult) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChosenInlineResult) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "result_id":`)
	fflib.WriteJsonString(buf, string(j.ResultID))
	buf.WriteByte(',')
	if len(j.InlineMessageID) != 0 {
		buf.WriteString(`"inline_message_id":`)
		fflib.WriteJsonString(buf, string(j.InlineMessageID))
		buf.WriteByte(',')
	}
	buf.WriteString(`"query":`)
	fflib.WriteJsonString(buf, string(j.Query))
	if j.From != nil {
		buf.WriteString(`,"from":`)

		{

			err = j.From.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"from":null`)
	}
	buf.WriteByte(',')
	if j.Location != nil {
		if true {
			buf.WriteString(`"location":`)

			{

				err = j.Location.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChosenInlineResultbase = iota
	ffjtChosenInlineResultnosuchkey

	ffjtChosenInlineResultResultID

	ffjtChosenInlineResultInlineMessageID

	ffjtChosenInlineResultQuery

	ffjtChosenInlineResultFrom

	ffjtChosenInlineResultLocation
)

var ffjKeyChosenInlineResultResultID = []byte("result_id")

var ffjKeyChosenInlineResultInlineMessageID = []byte("inline_message_id")

var ffjKeyChosenInlineResultQuery = []byte("query")

var ffjKeyChosenInlineResultFrom = []byte("from")

var ffjKeyChosenInlineResultLocation = []byte("location")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChosenInlineResult) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChosenInlineResult) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChosenInlineResultbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChosenInlineResultnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyChosenInlineResultFrom, kn) {
						currentKey = ffjtChosenInlineResultFrom
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyChosenInlineResultInlineMessageID, kn) {
						currentKey = ffjtChosenInlineResultInlineMessageID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyChosenInlineResultLocation, kn) {
						currentKey = ffjtChosenInlineResultLocation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'q':

					if bytes.Equal(ffjKeyChosenInlineResultQuery, kn) {
						currentKey = ffjtChosenInlineResultQuery
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyChosenInlineResultResultID, kn) {
						currentKey = ffjtChosenInlineResultResultID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyChosenInlineResultLocation, kn) {
					currentKey = ffjtChosenInlineResultLocation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChosenInlineResultFrom, kn) {
					currentKey = ffjtChosenInlineResultFrom
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChosenInlineResultQuery, kn) {
					currentKey = ffjtChosenInlineResultQuery
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChosenInlineResultInlineMessageID, kn) {
					currentKey = ffjtChosenInlineResultInlineMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChosenInlineResultResultID, kn) {
					currentKey = ffjtChosenInlineResultResultID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChosenInlineResultnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChosenInlineResultResultID:
					goto handle_ResultID

				case ffjtChosenInlineResultInlineMessageID:
					goto handle_InlineMessageID

				case ffjtChosenInlineResultQuery:
					goto handle_Query

				case ffjtChosenInlineResultFrom:
					goto handle_From

				case ffjtChosenInlineResultLocation:
					goto handle_Location

				case ffjtChosenInlineResultnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ResultID:

	/* handler: j.ResultID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ResultID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InlineMessageID:

	/* handler: j.InlineMessageID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.InlineMessageID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Query:

	/* handler: j.Query type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Query = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_From:

	/* handler: j.From type=telegram.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.From = nil

		} else {

			if j.From == nil {
				j.From = new(User)
			}

			err = j.From.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Location:

	/* handler: j.Location type=telegram.Location kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Location = nil

		} else {

			if j.Location == nil {
				j.Location = new(Location)
			}

			err = j.Location.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Contact) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Contact) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "phone_number":`)
	fflib.WriteJsonString(buf, string(j.PhoneNumber))
	buf.WriteString(`,"first_name":`)
	fflib.WriteJsonString(buf, string(j.FirstName))
	buf.WriteByte(',')
	if len(j.LastName) != 0 {
		buf.WriteString(`"last_name":`)
		fflib.WriteJsonString(buf, string(j.LastName))
		buf.WriteByte(',')
	}
	if j.UserID != 0 {
		buf.WriteString(`"user_id":`)
		fflib.FormatBits2(buf, uint64(j.UserID), 10, j.UserID < 0)
		buf.WriteByte(',')
	}
	if len(j.VCard) != 0 {
		buf.WriteString(`"vcard":`)
		fflib.WriteJsonString(buf, string(j.VCard))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtContactbase = iota
	ffjtContactnosuchkey

	ffjtContactPhoneNumber

	ffjtContactFirstName

	ffjtContactLastName

	ffjtContactUserID

	ffjtContactVCard
)

var ffjKeyContactPhoneNumber = []byte("phone_number")

var ffjKeyContactFirstName = []byte("first_name")

var ffjKeyContactLastName = []byte("last_name")

var ffjKeyContactUserID = []byte("user_id")

var ffjKeyContactVCard = []byte("vcard")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Contact) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Contact) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtContactbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtContactnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyContactFirstName, kn) {
						currentKey = ffjtContactFirstName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyContactLastName, kn) {
						currentKey = ffjtContactLastName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyContactPhoneNumber, kn) {
						currentKey = ffjtContactPhoneNumber
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyContactUserID, kn) {
						currentKey = ffjtContactUserID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyContactVCard, kn) {
						currentKey = ffjtContactVCard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyContactVCard, kn) {
					currentKey = ffjtContactVCard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContactUserID, kn) {
					currentKey = ffjtContactUserID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContactLastName, kn) {
					currentKey = ffjtContactLastName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContactFirstName, kn) {
					currentKey = ffjtContactFirstName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyContactPhoneNumber, kn) {
					currentKey = ffjtContactPhoneNumber
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtContactnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtContactPhoneNumber:
					goto handle_PhoneNumber

				case ffjtContactFirstName:
					goto handle_FirstName

				case ffjtContactLastName:
					goto handle_LastName

				case ffjtContactUserID:
					goto handle_UserID

				case ffjtContactVCard:
					goto handle_VCard

				case ffjtContactnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_PhoneNumber:

	/* handler: j.PhoneNumber type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PhoneNumber = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FirstName:

	/* handler: j.FirstName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FirstName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastName:

	/* handler: j.LastName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LastName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserID:

	/* handler: j.UserID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.UserID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VCard:

	/* handler: j.VCard type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.VCard = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Credentials) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Credentials) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.SecureData != nil {
		buf.WriteString(`{"secure_data":`)

		{

			err = j.SecureData.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`{"secure_data":null`)
	}
	buf.WriteString(`,"nonce":`)
	fflib.WriteJsonString(buf, string(j.Nonce))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtCredentialsbase = iota
	ffjtCredentialsnosuchkey

	ffjtCredentialsSecureData

	ffjtCredentialsNonce
)

var ffjKeyCredentialsSecureData = []byte("secure_data")

var ffjKeyCredentialsNonce = []byte("nonce")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Credentials) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Credentials) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtCredentialsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtCredentialsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'n':

					if bytes.Equal(ffjKeyCredentialsNonce, kn) {
						currentKey = ffjtCredentialsNonce
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyCredentialsSecureData, kn) {
						currentKey = ffjtCredentialsSecureData
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyCredentialsNonce, kn) {
					currentKey = ffjtCredentialsNonce
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCredentialsSecureData, kn) {
					currentKey = ffjtCredentialsSecureData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtCredentialsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtCredentialsSecureData:
					goto handle_SecureData

				case ffjtCredentialsNonce:
					goto handle_Nonce

				case ffjtCredentialsnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_SecureData:

	/* handler: j.SecureData type=telegram.SecureData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.SecureData = nil

		} else {

			if j.SecureData == nil {
				j.SecureData = new(SecureData)
			}

			err = j.SecureData.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Nonce:

	/* handler: j.Nonce type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Nonce = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *DataCredentials) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *DataCredentials) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"data_hash":`)
	fflib.WriteJsonString(buf, string(j.DataHash))
	buf.WriteString(`,"secret":`)
	fflib.WriteJsonString(buf, string(j.Secret))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtDataCredentialsbase = iota
	ffjtDataCredentialsnosuchkey

	ffjtDataCredentialsDataHash

	ffjtDataCredentialsSecret
)

var ffjKeyDataCredentialsDataHash = []byte("data_hash")

var ffjKeyDataCredentialsSecret = []byte("secret")

// UnmarshalJSON umarshall json - template of ffjson
func (j *DataCredentials) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *DataCredentials) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtDataCredentialsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtDataCredentialsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyDataCredentialsDataHash, kn) {
						currentKey = ffjtDataCredentialsDataHash
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyDataCredentialsSecret, kn) {
						currentKey = ffjtDataCredentialsSecret
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyDataCredentialsSecret, kn) {
					currentKey = ffjtDataCredentialsSecret
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyDataCredentialsDataHash, kn) {
					currentKey = ffjtDataCredentialsDataHash
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtDataCredentialsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtDataCredentialsDataHash:
					goto handle_DataHash

				case ffjtDataCredentialsSecret:
					goto handle_Secret

				case ffjtDataCredentialsnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_DataHash:

	/* handler: j.DataHash type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.DataHash = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Secret:

	/* handler: j.Secret type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Secret = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Document) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Document) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(j.FileID))
	buf.WriteByte(',')
	if len(j.FileName) != 0 {
		buf.WriteString(`"file_name":`)
		fflib.WriteJsonString(buf, string(j.FileName))
		buf.WriteByte(',')
	}
	if len(j.MimeType) != 0 {
		buf.WriteString(`"mime_type":`)
		fflib.WriteJsonString(buf, string(j.MimeType))
		buf.WriteByte(',')
	}
	if j.Thumb != nil {
		if true {
			buf.WriteString(`"thumb":`)

			{

				err = j.Thumb.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(j.FileSize), 10, j.FileSize < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtDocumentbase = iota
	ffjtDocumentnosuchkey

	ffjtDocumentFileID

	ffjtDocumentFileName

	ffjtDocumentMimeType

	ffjtDocumentThumb

	ffjtDocumentFileSize
)

var ffjKeyDocumentFileID = []byte("file_id")

var ffjKeyDocumentFileName = []byte("file_name")

var ffjKeyDocumentMimeType = []byte("mime_type")

var ffjKeyDocumentThumb = []byte("thumb")

var ffjKeyDocumentFileSize = []byte("file_size")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Document) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Document) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtDocumentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtDocumentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyDocumentFileID, kn) {
						currentKey = ffjtDocumentFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDocumentFileName, kn) {
						currentKey = ffjtDocumentFileName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDocumentFileSize, kn) {
						currentKey = ffjtDocumentFileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyDocumentMimeType, kn) {
						currentKey = ffjtDocumentMimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyDocumentThumb, kn) {
						currentKey = ffjtDocumentThumb
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyDocumentFileSize, kn) {
					currentKey = ffjtDocumentFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDocumentThumb, kn) {
					currentKey = ffjtDocumentThumb
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyDocumentMimeType, kn) {
					currentKey = ffjtDocumentMimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyDocumentFileName, kn) {
					currentKey = ffjtDocumentFileName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyDocumentFileID, kn) {
					currentKey = ffjtDocumentFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtDocumentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtDocumentFileID:
					goto handle_FileID

				case ffjtDocumentFileName:
					goto handle_FileName

				case ffjtDocumentMimeType:
					goto handle_MimeType

				case ffjtDocumentThumb:
					goto handle_Thumb

				case ffjtDocumentFileSize:
					goto handle_FileSize

				case ffjtDocumentnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: j.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileName:

	/* handler: j.FileName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeType:

	/* handler: j.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Thumb:

	/* handler: j.Thumb type=telegram.PhotoSize kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Thumb = nil

		} else {

			if j.Thumb == nil {
				j.Thumb = new(PhotoSize)
			}

			err = j.Thumb.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: j.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *EncryptedCredentials) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *EncryptedCredentials) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"data":`)
	fflib.WriteJsonString(buf, string(j.Data))
	buf.WriteString(`,"hash":`)
	fflib.WriteJsonString(buf, string(j.Hash))
	buf.WriteString(`,"secret":`)
	fflib.WriteJsonString(buf, string(j.Secret))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtEncryptedCredentialsbase = iota
	ffjtEncryptedCredentialsnosuchkey

	ffjtEncryptedCredentialsData

	ffjtEncryptedCredentialsHash

	ffjtEncryptedCredentialsSecret
)

var ffjKeyEncryptedCredentialsData = []byte("data")

var ffjKeyEncryptedCredentialsHash = []byte("hash")

var ffjKeyEncryptedCredentialsSecret = []byte("secret")

// UnmarshalJSON umarshall json - template of ffjson
func (j *EncryptedCredentials) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *EncryptedCredentials) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtEncryptedCredentialsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtEncryptedCredentialsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyEncryptedCredentialsData, kn) {
						currentKey = ffjtEncryptedCredentialsData
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyEncryptedCredentialsHash, kn) {
						currentKey = ffjtEncryptedCredentialsHash
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyEncryptedCredentialsSecret, kn) {
						currentKey = ffjtEncryptedCredentialsSecret
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyEncryptedCredentialsSecret, kn) {
					currentKey = ffjtEncryptedCredentialsSecret
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEncryptedCredentialsHash, kn) {
					currentKey = ffjtEncryptedCredentialsHash
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEncryptedCredentialsData, kn) {
					currentKey = ffjtEncryptedCredentialsData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtEncryptedCredentialsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtEncryptedCredentialsData:
					goto handle_Data

				case ffjtEncryptedCredentialsHash:
					goto handle_Hash

				case ffjtEncryptedCredentialsSecret:
					goto handle_Secret

				case ffjtEncryptedCredentialsnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Data:

	/* handler: j.Data type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Data = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Hash:

	/* handler: j.Hash type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Hash = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Secret:

	/* handler: j.Secret type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Secret = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *EncryptedPassportElement) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *EncryptedPassportElement) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteByte(',')
	if len(j.Data) != 0 {
		buf.WriteString(`"data":`)
		fflib.WriteJsonString(buf, string(j.Data))
		buf.WriteByte(',')
	}
	if len(j.PhoneNumber) != 0 {
		buf.WriteString(`"phone_number":`)
		fflib.WriteJsonString(buf, string(j.PhoneNumber))
		buf.WriteByte(',')
	}
	if len(j.Email) != 0 {
		buf.WriteString(`"email":`)
		fflib.WriteJsonString(buf, string(j.Email))
		buf.WriteByte(',')
	}
	if len(j.Files) != 0 {
		buf.WriteString(`"files":`)
		if j.Files != nil {
			buf.WriteString(`[`)
			for i, v := range j.Files {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.FrontSide != nil {
		if true {
			buf.WriteString(`"front_side":`)

			{

				err = j.FrontSide.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ReverseSide != nil {
		if true {
			buf.WriteString(`"reverse_side":`)

			{

				err = j.ReverseSide.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Selfie != nil {
		if true {
			buf.WriteString(`"selfie":`)

			{

				err = j.Selfie.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.Translation) != 0 {
		buf.WriteString(`"translation":`)
		if j.Translation != nil {
			buf.WriteString(`[`)
			for i, v := range j.Translation {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"hash":`)
	fflib.WriteJsonString(buf, string(j.Hash))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtEncryptedPassportElementbase = iota
	ffjtEncryptedPassportElementnosuchkey

	ffjtEncryptedPassportElementType

	ffjtEncryptedPassportElementData

	ffjtEncryptedPassportElementPhoneNumber

	ffjtEncryptedPassportElementEmail

	ffjtEncryptedPassportElementFiles

	ffjtEncryptedPassportElementFrontSide

	ffjtEncryptedPassportElementReverseSide

	ffjtEncryptedPassportElementSelfie

	ffjtEncryptedPassportElementTranslation

	ffjtEncryptedPassportElementHash
)

var ffjKeyEncryptedPassportElementType = []byte("type")

var ffjKeyEncryptedPassportElementData = []byte("data")

var ffjKeyEncryptedPassportElementPhoneNumber = []byte("phone_number")

var ffjKeyEncryptedPassportElementEmail = []byte("email")

var ffjKeyEncryptedPassportElementFiles = []byte("files")

var ffjKeyEncryptedPassportElementFrontSide = []byte("front_side")

var ffjKeyEncryptedPassportElementReverseSide = []byte("reverse_side")

var ffjKeyEncryptedPassportElementSelfie = []byte("selfie")

var ffjKeyEncryptedPassportElementTranslation = []byte("translation")

var ffjKeyEncryptedPassportElementHash = []byte("hash")

// UnmarshalJSON umarshall json - template of ffjson
func (j *EncryptedPassportElement) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *EncryptedPassportElement) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtEncryptedPassportElementbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtEncryptedPassportElementnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyEncryptedPassportElementData, kn) {
						currentKey = ffjtEncryptedPassportElementData
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyEncryptedPassportElementEmail, kn) {
						currentKey = ffjtEncryptedPassportElementEmail
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyEncryptedPassportElementFiles, kn) {
						currentKey = ffjtEncryptedPassportElementFiles
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEncryptedPassportElementFrontSide, kn) {
						currentKey = ffjtEncryptedPassportElementFrontSide
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyEncryptedPassportElementHash, kn) {
						currentKey = ffjtEncryptedPassportElementHash
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyEncryptedPassportElementPhoneNumber, kn) {
						currentKey = ffjtEncryptedPassportElementPhoneNumber
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyEncryptedPassportElementReverseSide, kn) {
						currentKey = ffjtEncryptedPassportElementReverseSide
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyEncryptedPassportElementSelfie, kn) {
						currentKey = ffjtEncryptedPassportElementSelfie
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyEncryptedPassportElementType, kn) {
						currentKey = ffjtEncryptedPassportElementType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEncryptedPassportElementTranslation, kn) {
						currentKey = ffjtEncryptedPassportElementTranslation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyEncryptedPassportElementHash, kn) {
					currentKey = ffjtEncryptedPassportElementHash
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEncryptedPassportElementTranslation, kn) {
					currentKey = ffjtEncryptedPassportElementTranslation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEncryptedPassportElementSelfie, kn) {
					currentKey = ffjtEncryptedPassportElementSelfie
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEncryptedPassportElementReverseSide, kn) {
					currentKey = ffjtEncryptedPassportElementReverseSide
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEncryptedPassportElementFrontSide, kn) {
					currentKey = ffjtEncryptedPassportElementFrontSide
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEncryptedPassportElementFiles, kn) {
					currentKey = ffjtEncryptedPassportElementFiles
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEncryptedPassportElementEmail, kn) {
					currentKey = ffjtEncryptedPassportElementEmail
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyEncryptedPassportElementPhoneNumber, kn) {
					currentKey = ffjtEncryptedPassportElementPhoneNumber
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEncryptedPassportElementData, kn) {
					currentKey = ffjtEncryptedPassportElementData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEncryptedPassportElementType, kn) {
					currentKey = ffjtEncryptedPassportElementType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtEncryptedPassportElementnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtEncryptedPassportElementType:
					goto handle_Type

				case ffjtEncryptedPassportElementData:
					goto handle_Data

				case ffjtEncryptedPassportElementPhoneNumber:
					goto handle_PhoneNumber

				case ffjtEncryptedPassportElementEmail:
					goto handle_Email

				case ffjtEncryptedPassportElementFiles:
					goto handle_Files

				case ffjtEncryptedPassportElementFrontSide:
					goto handle_FrontSide

				case ffjtEncryptedPassportElementReverseSide:
					goto handle_ReverseSide

				case ffjtEncryptedPassportElementSelfie:
					goto handle_Selfie

				case ffjtEncryptedPassportElementTranslation:
					goto handle_Translation

				case ffjtEncryptedPassportElementHash:
					goto handle_Hash

				case ffjtEncryptedPassportElementnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: j.Data type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Data = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PhoneNumber:

	/* handler: j.PhoneNumber type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PhoneNumber = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Email:

	/* handler: j.Email type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Email = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Files:

	/* handler: j.Files type=[]telegram.PassportFile kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Files = nil
		} else {

			j.Files = []PassportFile{}

			wantVal := true

			for {

				var tmpJFiles PassportFile

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJFiles type=telegram.PassportFile kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJFiles.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Files = append(j.Files, tmpJFiles)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FrontSide:

	/* handler: j.FrontSide type=telegram.PassportFile kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.FrontSide = nil

		} else {

			if j.FrontSide == nil {
				j.FrontSide = new(PassportFile)
			}

			err = j.FrontSide.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReverseSide:

	/* handler: j.ReverseSide type=telegram.PassportFile kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReverseSide = nil

		} else {

			if j.ReverseSide == nil {
				j.ReverseSide = new(PassportFile)
			}

			err = j.ReverseSide.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Selfie:

	/* handler: j.Selfie type=telegram.PassportFile kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Selfie = nil

		} else {

			if j.Selfie == nil {
				j.Selfie = new(PassportFile)
			}

			err = j.Selfie.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Translation:

	/* handler: j.Translation type=[]telegram.PassportFile kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Translation = nil
		} else {

			j.Translation = []PassportFile{}

			wantVal := true

			for {

				var tmpJTranslation PassportFile

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJTranslation type=telegram.PassportFile kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJTranslation.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Translation = append(j.Translation, tmpJTranslation)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Hash:

	/* handler: j.Hash type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Hash = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *File) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *File) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(j.FileID))
	buf.WriteByte(',')
	if len(j.FilePath) != 0 {
		buf.WriteString(`"file_path":`)
		fflib.WriteJsonString(buf, string(j.FilePath))
		buf.WriteByte(',')
	}
	if j.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(j.FileSize), 10, j.FileSize < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtFilebase = iota
	ffjtFilenosuchkey

	ffjtFileFileID

	ffjtFileFilePath

	ffjtFileFileSize
)

var ffjKeyFileFileID = []byte("file_id")

var ffjKeyFileFilePath = []byte("file_path")

var ffjKeyFileFileSize = []byte("file_size")

// UnmarshalJSON umarshall json - template of ffjson
func (j *File) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *File) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtFilebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtFilenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyFileFileID, kn) {
						currentKey = ffjtFileFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFileFilePath, kn) {
						currentKey = ffjtFileFilePath
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFileFileSize, kn) {
						currentKey = ffjtFileFileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyFileFileSize, kn) {
					currentKey = ffjtFileFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyFileFilePath, kn) {
					currentKey = ffjtFileFilePath
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyFileFileID, kn) {
					currentKey = ffjtFileFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtFilenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtFileFileID:
					goto handle_FileID

				case ffjtFileFilePath:
					goto handle_FilePath

				case ffjtFileFileSize:
					goto handle_FileSize

				case ffjtFilenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: j.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FilePath:

	/* handler: j.FilePath type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FilePath = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: j.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *FileCredentials) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *FileCredentials) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"file_hash":`)
	fflib.WriteJsonString(buf, string(j.FileHash))
	buf.WriteString(`,"secret":`)
	fflib.WriteJsonString(buf, string(j.Secret))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtFileCredentialsbase = iota
	ffjtFileCredentialsnosuchkey

	ffjtFileCredentialsFileHash

	ffjtFileCredentialsSecret
)

var ffjKeyFileCredentialsFileHash = []byte("file_hash")

var ffjKeyFileCredentialsSecret = []byte("secret")

// UnmarshalJSON umarshall json - template of ffjson
func (j *FileCredentials) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *FileCredentials) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtFileCredentialsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtFileCredentialsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyFileCredentialsFileHash, kn) {
						currentKey = ffjtFileCredentialsFileHash
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyFileCredentialsSecret, kn) {
						currentKey = ffjtFileCredentialsSecret
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyFileCredentialsSecret, kn) {
					currentKey = ffjtFileCredentialsSecret
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFileCredentialsFileHash, kn) {
					currentKey = ffjtFileCredentialsFileHash
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtFileCredentialsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtFileCredentialsFileHash:
					goto handle_FileHash

				case ffjtFileCredentialsSecret:
					goto handle_Secret

				case ffjtFileCredentialsnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileHash:

	/* handler: j.FileHash type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileHash = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Secret:

	/* handler: j.Secret type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Secret = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ForceReply) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ForceReply) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.ForceReply {
		buf.WriteString(`{ "force_reply":true`)
	} else {
		buf.WriteString(`{ "force_reply":false`)
	}
	buf.WriteByte(',')
	if j.Selective != false {
		if j.Selective {
			buf.WriteString(`"selective":true`)
		} else {
			buf.WriteString(`"selective":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtForceReplybase = iota
	ffjtForceReplynosuchkey

	ffjtForceReplyForceReply

	ffjtForceReplySelective
)

var ffjKeyForceReplyForceReply = []byte("force_reply")

var ffjKeyForceReplySelective = []byte("selective")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ForceReply) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ForceReply) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtForceReplybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtForceReplynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyForceReplyForceReply, kn) {
						currentKey = ffjtForceReplyForceReply
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyForceReplySelective, kn) {
						currentKey = ffjtForceReplySelective
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyForceReplySelective, kn) {
					currentKey = ffjtForceReplySelective
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyForceReplyForceReply, kn) {
					currentKey = ffjtForceReplyForceReply
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtForceReplynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtForceReplyForceReply:
					goto handle_ForceReply

				case ffjtForceReplySelective:
					goto handle_Selective

				case ffjtForceReplynosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ForceReply:

	/* handler: j.ForceReply type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.ForceReply = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.ForceReply = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Selective:

	/* handler: j.Selective type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Selective = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Selective = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Game) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Game) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteString(`,"description":`)
	fflib.WriteJsonString(buf, string(j.Description))
	buf.WriteByte(',')
	if len(j.Text) != 0 {
		buf.WriteString(`"text":`)
		fflib.WriteJsonString(buf, string(j.Text))
		buf.WriteByte(',')
	}
	buf.WriteString(`"photo":`)
	if j.Photo != nil {
		buf.WriteString(`[`)
		for i, v := range j.Photo {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(j.TextEntities) != 0 {
		buf.WriteString(`"text_entities":`)
		if j.TextEntities != nil {
			buf.WriteString(`[`)
			for i, v := range j.TextEntities {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.Animation != nil {
		if true {
			buf.WriteString(`"animation":`)

			{

				err = j.Animation.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGamebase = iota
	ffjtGamenosuchkey

	ffjtGameTitle

	ffjtGameDescription

	ffjtGameText

	ffjtGamePhoto

	ffjtGameTextEntities

	ffjtGameAnimation
)

var ffjKeyGameTitle = []byte("title")

var ffjKeyGameDescription = []byte("description")

var ffjKeyGameText = []byte("text")

var ffjKeyGamePhoto = []byte("photo")

var ffjKeyGameTextEntities = []byte("text_entities")

var ffjKeyGameAnimation = []byte("animation")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Game) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Game) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGamebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGamenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyGameAnimation, kn) {
						currentKey = ffjtGameAnimation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyGameDescription, kn) {
						currentKey = ffjtGameDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyGamePhoto, kn) {
						currentKey = ffjtGamePhoto
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyGameTitle, kn) {
						currentKey = ffjtGameTitle
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGameText, kn) {
						currentKey = ffjtGameText
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGameTextEntities, kn) {
						currentKey = ffjtGameTextEntities
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyGameAnimation, kn) {
					currentKey = ffjtGameAnimation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGameTextEntities, kn) {
					currentKey = ffjtGameTextEntities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGamePhoto, kn) {
					currentKey = ffjtGamePhoto
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGameText, kn) {
					currentKey = ffjtGameText
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGameDescription, kn) {
					currentKey = ffjtGameDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGameTitle, kn) {
					currentKey = ffjtGameTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGamenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGameTitle:
					goto handle_Title

				case ffjtGameDescription:
					goto handle_Description

				case ffjtGameText:
					goto handle_Text

				case ffjtGamePhoto:
					goto handle_Photo

				case ffjtGameTextEntities:
					goto handle_TextEntities

				case ffjtGameAnimation:
					goto handle_Animation

				case ffjtGamenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Text:

	/* handler: j.Text type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Text = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Photo:

	/* handler: j.Photo type=[]telegram.PhotoSize kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Photo = nil
		} else {

			j.Photo = []PhotoSize{}

			wantVal := true

			for {

				var tmpJPhoto PhotoSize

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJPhoto type=telegram.PhotoSize kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJPhoto.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Photo = append(j.Photo, tmpJPhoto)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TextEntities:

	/* handler: j.TextEntities type=[]telegram.MessageEntity kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.TextEntities = nil
		} else {

			j.TextEntities = []MessageEntity{}

			wantVal := true

			for {

				var tmpJTextEntities MessageEntity

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJTextEntities type=telegram.MessageEntity kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJTextEntities.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.TextEntities = append(j.TextEntities, tmpJTextEntities)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Animation:

	/* handler: j.Animation type=telegram.Animation kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Animation = nil

		} else {

			if j.Animation == nil {
				j.Animation = new(Animation)
			}

			err = j.Animation.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GameHighScore) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GameHighScore) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"position":`)
	fflib.FormatBits2(buf, uint64(j.Position), 10, j.Position < 0)
	buf.WriteString(`,"score":`)
	fflib.FormatBits2(buf, uint64(j.Score), 10, j.Score < 0)
	if j.User != nil {
		buf.WriteString(`,"user":`)

		{

			err = j.User.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"user":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGameHighScorebase = iota
	ffjtGameHighScorenosuchkey

	ffjtGameHighScorePosition

	ffjtGameHighScoreScore

	ffjtGameHighScoreUser
)

var ffjKeyGameHighScorePosition = []byte("position")

var ffjKeyGameHighScoreScore = []byte("score")

var ffjKeyGameHighScoreUser = []byte("user")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GameHighScore) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GameHighScore) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGameHighScorebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGameHighScorenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffjKeyGameHighScorePosition, kn) {
						currentKey = ffjtGameHighScorePosition
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyGameHighScoreScore, kn) {
						currentKey = ffjtGameHighScoreScore
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyGameHighScoreUser, kn) {
						currentKey = ffjtGameHighScoreUser
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyGameHighScoreUser, kn) {
					currentKey = ffjtGameHighScoreUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGameHighScoreScore, kn) {
					currentKey = ffjtGameHighScoreScore
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGameHighScorePosition, kn) {
					currentKey = ffjtGameHighScorePosition
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGameHighScorenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGameHighScorePosition:
					goto handle_Position

				case ffjtGameHighScoreScore:
					goto handle_Score

				case ffjtGameHighScoreUser:
					goto handle_User

				case ffjtGameHighScorenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Position:

	/* handler: j.Position type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Position = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Score:

	/* handler: j.Score type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Score = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_User:

	/* handler: j.User type=telegram.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.User = nil

		} else {

			if j.User == nil {
				j.User = new(User)
			}

			err = j.User.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *IDDocumentData) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *IDDocumentData) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "document_no":`)
	fflib.WriteJsonString(buf, string(j.DocumentNo))
	buf.WriteByte(',')
	if len(j.ExpiryDate) != 0 {
		buf.WriteString(`"expiry_date":`)
		fflib.WriteJsonString(buf, string(j.ExpiryDate))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtIDDocumentDatabase = iota
	ffjtIDDocumentDatanosuchkey

	ffjtIDDocumentDataDocumentNo

	ffjtIDDocumentDataExpiryDate
)

var ffjKeyIDDocumentDataDocumentNo = []byte("document_no")

var ffjKeyIDDocumentDataExpiryDate = []byte("expiry_date")

// UnmarshalJSON umarshall json - template of ffjson
func (j *IDDocumentData) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *IDDocumentData) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtIDDocumentDatabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtIDDocumentDatanosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyIDDocumentDataDocumentNo, kn) {
						currentKey = ffjtIDDocumentDataDocumentNo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyIDDocumentDataExpiryDate, kn) {
						currentKey = ffjtIDDocumentDataExpiryDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyIDDocumentDataExpiryDate, kn) {
					currentKey = ffjtIDDocumentDataExpiryDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyIDDocumentDataDocumentNo, kn) {
					currentKey = ffjtIDDocumentDataDocumentNo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtIDDocumentDatanosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtIDDocumentDataDocumentNo:
					goto handle_DocumentNo

				case ffjtIDDocumentDataExpiryDate:
					goto handle_ExpiryDate

				case ffjtIDDocumentDatanosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_DocumentNo:

	/* handler: j.DocumentNo type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.DocumentNo = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExpiryDate:

	/* handler: j.ExpiryDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ExpiryDate = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineKeyboardButton) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineKeyboardButton) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "text":`)
	fflib.WriteJsonString(buf, string(j.Text))
	buf.WriteByte(',')
	if len(j.URL) != 0 {
		buf.WriteString(`"url":`)
		fflib.WriteJsonString(buf, string(j.URL))
		buf.WriteByte(',')
	}
	if j.LoginURL != nil {
		if true {
			buf.WriteString(`"login_url":`)

			{

				err = j.LoginURL.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.CallbackData) != 0 {
		buf.WriteString(`"callback_data":`)
		fflib.WriteJsonString(buf, string(j.CallbackData))
		buf.WriteByte(',')
	}
	if len(j.SwitchInlineQuery) != 0 {
		buf.WriteString(`"switch_inline_query":`)
		fflib.WriteJsonString(buf, string(j.SwitchInlineQuery))
		buf.WriteByte(',')
	}
	if len(j.SwitchInlineQueryCurrentChat) != 0 {
		buf.WriteString(`"switch_inline_query_current_chat":`)
		fflib.WriteJsonString(buf, string(j.SwitchInlineQueryCurrentChat))
		buf.WriteByte(',')
	}
	if j.CallbackGame != nil {
		if true {
			buf.WriteString(`"callback_game":`)

			{

				err = j.CallbackGame.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Pay != false {
		if j.Pay {
			buf.WriteString(`"pay":true`)
		} else {
			buf.WriteString(`"pay":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineKeyboardButtonbase = iota
	ffjtInlineKeyboardButtonnosuchkey

	ffjtInlineKeyboardButtonText

	ffjtInlineKeyboardButtonURL

	ffjtInlineKeyboardButtonLoginURL

	ffjtInlineKeyboardButtonCallbackData

	ffjtInlineKeyboardButtonSwitchInlineQuery

	ffjtInlineKeyboardButtonSwitchInlineQueryCurrentChat

	ffjtInlineKeyboardButtonCallbackGame

	ffjtInlineKeyboardButtonPay
)

var ffjKeyInlineKeyboardButtonText = []byte("text")

var ffjKeyInlineKeyboardButtonURL = []byte("url")

var ffjKeyInlineKeyboardButtonLoginURL = []byte("login_url")

var ffjKeyInlineKeyboardButtonCallbackData = []byte("callback_data")

var ffjKeyInlineKeyboardButtonSwitchInlineQuery = []byte("switch_inline_query")

var ffjKeyInlineKeyboardButtonSwitchInlineQueryCurrentChat = []byte("switch_inline_query_current_chat")

var ffjKeyInlineKeyboardButtonCallbackGame = []byte("callback_game")

var ffjKeyInlineKeyboardButtonPay = []byte("pay")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineKeyboardButton) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineKeyboardButton) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineKeyboardButtonbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineKeyboardButtonnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInlineKeyboardButtonCallbackData, kn) {
						currentKey = ffjtInlineKeyboardButtonCallbackData
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineKeyboardButtonCallbackGame, kn) {
						currentKey = ffjtInlineKeyboardButtonCallbackGame
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyInlineKeyboardButtonLoginURL, kn) {
						currentKey = ffjtInlineKeyboardButtonLoginURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInlineKeyboardButtonPay, kn) {
						currentKey = ffjtInlineKeyboardButtonPay
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyInlineKeyboardButtonSwitchInlineQuery, kn) {
						currentKey = ffjtInlineKeyboardButtonSwitchInlineQuery
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineKeyboardButtonSwitchInlineQueryCurrentChat, kn) {
						currentKey = ffjtInlineKeyboardButtonSwitchInlineQueryCurrentChat
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineKeyboardButtonText, kn) {
						currentKey = ffjtInlineKeyboardButtonText
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyInlineKeyboardButtonURL, kn) {
						currentKey = ffjtInlineKeyboardButtonURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineKeyboardButtonPay, kn) {
					currentKey = ffjtInlineKeyboardButtonPay
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineKeyboardButtonCallbackGame, kn) {
					currentKey = ffjtInlineKeyboardButtonCallbackGame
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineKeyboardButtonSwitchInlineQueryCurrentChat, kn) {
					currentKey = ffjtInlineKeyboardButtonSwitchInlineQueryCurrentChat
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineKeyboardButtonSwitchInlineQuery, kn) {
					currentKey = ffjtInlineKeyboardButtonSwitchInlineQuery
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineKeyboardButtonCallbackData, kn) {
					currentKey = ffjtInlineKeyboardButtonCallbackData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineKeyboardButtonLoginURL, kn) {
					currentKey = ffjtInlineKeyboardButtonLoginURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineKeyboardButtonURL, kn) {
					currentKey = ffjtInlineKeyboardButtonURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineKeyboardButtonText, kn) {
					currentKey = ffjtInlineKeyboardButtonText
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineKeyboardButtonnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineKeyboardButtonText:
					goto handle_Text

				case ffjtInlineKeyboardButtonURL:
					goto handle_URL

				case ffjtInlineKeyboardButtonLoginURL:
					goto handle_LoginURL

				case ffjtInlineKeyboardButtonCallbackData:
					goto handle_CallbackData

				case ffjtInlineKeyboardButtonSwitchInlineQuery:
					goto handle_SwitchInlineQuery

				case ffjtInlineKeyboardButtonSwitchInlineQueryCurrentChat:
					goto handle_SwitchInlineQueryCurrentChat

				case ffjtInlineKeyboardButtonCallbackGame:
					goto handle_CallbackGame

				case ffjtInlineKeyboardButtonPay:
					goto handle_Pay

				case ffjtInlineKeyboardButtonnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Text:

	/* handler: j.Text type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Text = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_URL:

	/* handler: j.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LoginURL:

	/* handler: j.LoginURL type=telegram.LoginURL kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.LoginURL = nil

		} else {

			if j.LoginURL == nil {
				j.LoginURL = new(LoginURL)
			}

			err = j.LoginURL.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CallbackData:

	/* handler: j.CallbackData type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CallbackData = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SwitchInlineQuery:

	/* handler: j.SwitchInlineQuery type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.SwitchInlineQuery = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SwitchInlineQueryCurrentChat:

	/* handler: j.SwitchInlineQueryCurrentChat type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.SwitchInlineQueryCurrentChat = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CallbackGame:

	/* handler: j.CallbackGame type=telegram.CallbackGame kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.CallbackGame = nil

		} else {

			if j.CallbackGame == nil {
				j.CallbackGame = new(CallbackGame)
			}

			err = j.CallbackGame.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Pay:

	/* handler: j.Pay type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Pay = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Pay = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineKeyboardMarkup) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineKeyboardMarkup) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"inline_keyboard":`)
	if j.InlineKeyboard != nil {
		buf.WriteString(`[`)
		for i, v := range j.InlineKeyboard {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				buf.WriteString(`[`)
				for i, v := range v {
					if i != 0 {
						buf.WriteString(`,`)
					}

					{

						err = v.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}
				}
				buf.WriteString(`]`)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineKeyboardMarkupbase = iota
	ffjtInlineKeyboardMarkupnosuchkey

	ffjtInlineKeyboardMarkupInlineKeyboard
)

var ffjKeyInlineKeyboardMarkupInlineKeyboard = []byte("inline_keyboard")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineKeyboardMarkup) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineKeyboardMarkup) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineKeyboardMarkupbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineKeyboardMarkupnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffjKeyInlineKeyboardMarkupInlineKeyboard, kn) {
						currentKey = ffjtInlineKeyboardMarkupInlineKeyboard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineKeyboardMarkupInlineKeyboard, kn) {
					currentKey = ffjtInlineKeyboardMarkupInlineKeyboard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineKeyboardMarkupnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineKeyboardMarkupInlineKeyboard:
					goto handle_InlineKeyboard

				case ffjtInlineKeyboardMarkupnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_InlineKeyboard:

	/* handler: j.InlineKeyboard type=[][]telegram.InlineKeyboardButton kind=slice quoted=false*/

	{
		/* Falling back. type=[][]telegram.InlineKeyboardButton kind=slice */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InlineKeyboard)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQuery) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQuery) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"query":`)
	fflib.WriteJsonString(buf, string(j.Query))
	buf.WriteString(`,"offset":`)
	fflib.WriteJsonString(buf, string(j.Offset))
	if j.From != nil {
		buf.WriteString(`,"from":`)

		{

			err = j.From.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"from":null`)
	}
	buf.WriteByte(',')
	if j.Location != nil {
		if true {
			buf.WriteString(`"location":`)

			{

				err = j.Location.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQuerybase = iota
	ffjtInlineQuerynosuchkey

	ffjtInlineQueryID

	ffjtInlineQueryQuery

	ffjtInlineQueryOffset

	ffjtInlineQueryFrom

	ffjtInlineQueryLocation
)

var ffjKeyInlineQueryID = []byte("id")

var ffjKeyInlineQueryQuery = []byte("query")

var ffjKeyInlineQueryOffset = []byte("offset")

var ffjKeyInlineQueryFrom = []byte("from")

var ffjKeyInlineQueryLocation = []byte("location")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQuery) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQuery) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQuerybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQuerynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyInlineQueryFrom, kn) {
						currentKey = ffjtInlineQueryFrom
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryID, kn) {
						currentKey = ffjtInlineQueryID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyInlineQueryLocation, kn) {
						currentKey = ffjtInlineQueryLocation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyInlineQueryOffset, kn) {
						currentKey = ffjtInlineQueryOffset
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'q':

					if bytes.Equal(ffjKeyInlineQueryQuery, kn) {
						currentKey = ffjtInlineQueryQuery
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryLocation, kn) {
					currentKey = ffjtInlineQueryLocation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryFrom, kn) {
					currentKey = ffjtInlineQueryFrom
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryOffset, kn) {
					currentKey = ffjtInlineQueryOffset
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryQuery, kn) {
					currentKey = ffjtInlineQueryQuery
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryID, kn) {
					currentKey = ffjtInlineQueryID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQuerynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryID:
					goto handle_ID

				case ffjtInlineQueryQuery:
					goto handle_Query

				case ffjtInlineQueryOffset:
					goto handle_Offset

				case ffjtInlineQueryFrom:
					goto handle_From

				case ffjtInlineQueryLocation:
					goto handle_Location

				case ffjtInlineQuerynosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Query:

	/* handler: j.Query type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Query = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Offset:

	/* handler: j.Offset type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Offset = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_From:

	/* handler: j.From type=telegram.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.From = nil

		} else {

			if j.From == nil {
				j.From = new(User)
			}

			err = j.From.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Location:

	/* handler: j.Location type=telegram.Location kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Location = nil

		} else {

			if j.Location == nil {
				j.Location = new(Location)
			}

			err = j.Location.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultArticle) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultArticle) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteByte(',')
	if len(j.URL) != 0 {
		buf.WriteString(`"url":`)
		fflib.WriteJsonString(buf, string(j.URL))
		buf.WriteByte(',')
	}
	if len(j.Description) != 0 {
		buf.WriteString(`"description":`)
		fflib.WriteJsonString(buf, string(j.Description))
		buf.WriteByte(',')
	}
	if len(j.ThumbURL) != 0 {
		buf.WriteString(`"thumb_url":`)
		fflib.WriteJsonString(buf, string(j.ThumbURL))
		buf.WriteByte(',')
	}
	buf.WriteString(`"input_message_content":`)
	/* Interface types must use runtime reflection. type=interface {} kind=interface */
	err = buf.Encode(j.InputMessageContent)
	if err != nil {
		return err
	}
	buf.WriteByte(',')
	if j.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = j.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.HideURL != false {
		if j.HideURL {
			buf.WriteString(`"hide_url":true`)
		} else {
			buf.WriteString(`"hide_url":false`)
		}
		buf.WriteByte(',')
	}
	if j.ThumbWidth != 0 {
		buf.WriteString(`"thumb_width":`)
		fflib.FormatBits2(buf, uint64(j.ThumbWidth), 10, j.ThumbWidth < 0)
		buf.WriteByte(',')
	}
	if j.ThumbHeight != 0 {
		buf.WriteString(`"thumb_height":`)
		fflib.FormatBits2(buf, uint64(j.ThumbHeight), 10, j.ThumbHeight < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultArticlebase = iota
	ffjtInlineQueryResultArticlenosuchkey

	ffjtInlineQueryResultArticleType

	ffjtInlineQueryResultArticleID

	ffjtInlineQueryResultArticleTitle

	ffjtInlineQueryResultArticleURL

	ffjtInlineQueryResultArticleDescription

	ffjtInlineQueryResultArticleThumbURL

	ffjtInlineQueryResultArticleInputMessageContent

	ffjtInlineQueryResultArticleReplyMarkup

	ffjtInlineQueryResultArticleHideURL

	ffjtInlineQueryResultArticleThumbWidth

	ffjtInlineQueryResultArticleThumbHeight
)

var ffjKeyInlineQueryResultArticleType = []byte("type")

var ffjKeyInlineQueryResultArticleID = []byte("id")

var ffjKeyInlineQueryResultArticleTitle = []byte("title")

var ffjKeyInlineQueryResultArticleURL = []byte("url")

var ffjKeyInlineQueryResultArticleDescription = []byte("description")

var ffjKeyInlineQueryResultArticleThumbURL = []byte("thumb_url")

var ffjKeyInlineQueryResultArticleInputMessageContent = []byte("input_message_content")

var ffjKeyInlineQueryResultArticleReplyMarkup = []byte("reply_markup")

var ffjKeyInlineQueryResultArticleHideURL = []byte("hide_url")

var ffjKeyInlineQueryResultArticleThumbWidth = []byte("thumb_width")

var ffjKeyInlineQueryResultArticleThumbHeight = []byte("thumb_height")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultArticle) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultArticle) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultArticlebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultArticlenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyInlineQueryResultArticleDescription, kn) {
						currentKey = ffjtInlineQueryResultArticleDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyInlineQueryResultArticleHideURL, kn) {
						currentKey = ffjtInlineQueryResultArticleHideURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultArticleID, kn) {
						currentKey = ffjtInlineQueryResultArticleID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultArticleInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultArticleInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultArticleReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultArticleReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultArticleType, kn) {
						currentKey = ffjtInlineQueryResultArticleType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultArticleTitle, kn) {
						currentKey = ffjtInlineQueryResultArticleTitle
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultArticleThumbURL, kn) {
						currentKey = ffjtInlineQueryResultArticleThumbURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultArticleThumbWidth, kn) {
						currentKey = ffjtInlineQueryResultArticleThumbWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultArticleThumbHeight, kn) {
						currentKey = ffjtInlineQueryResultArticleThumbHeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyInlineQueryResultArticleURL, kn) {
						currentKey = ffjtInlineQueryResultArticleURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultArticleThumbHeight, kn) {
					currentKey = ffjtInlineQueryResultArticleThumbHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultArticleThumbWidth, kn) {
					currentKey = ffjtInlineQueryResultArticleThumbWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultArticleHideURL, kn) {
					currentKey = ffjtInlineQueryResultArticleHideURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultArticleReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultArticleReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultArticleInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultArticleInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultArticleThumbURL, kn) {
					currentKey = ffjtInlineQueryResultArticleThumbURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultArticleDescription, kn) {
					currentKey = ffjtInlineQueryResultArticleDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultArticleURL, kn) {
					currentKey = ffjtInlineQueryResultArticleURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultArticleTitle, kn) {
					currentKey = ffjtInlineQueryResultArticleTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultArticleID, kn) {
					currentKey = ffjtInlineQueryResultArticleID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultArticleType, kn) {
					currentKey = ffjtInlineQueryResultArticleType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultArticlenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultArticleType:
					goto handle_Type

				case ffjtInlineQueryResultArticleID:
					goto handle_ID

				case ffjtInlineQueryResultArticleTitle:
					goto handle_Title

				case ffjtInlineQueryResultArticleURL:
					goto handle_URL

				case ffjtInlineQueryResultArticleDescription:
					goto handle_Description

				case ffjtInlineQueryResultArticleThumbURL:
					goto handle_ThumbURL

				case ffjtInlineQueryResultArticleInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultArticleReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultArticleHideURL:
					goto handle_HideURL

				case ffjtInlineQueryResultArticleThumbWidth:
					goto handle_ThumbWidth

				case ffjtInlineQueryResultArticleThumbHeight:
					goto handle_ThumbHeight

				case ffjtInlineQueryResultArticlenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_URL:

	/* handler: j.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbURL:

	/* handler: j.ThumbURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ThumbURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=telegram.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReplyMarkup = nil

		} else {

			if j.ReplyMarkup == nil {
				j.ReplyMarkup = new(InlineKeyboardMarkup)
			}

			err = j.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HideURL:

	/* handler: j.HideURL type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.HideURL = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.HideURL = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbWidth:

	/* handler: j.ThumbWidth type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ThumbWidth = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbHeight:

	/* handler: j.ThumbHeight type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ThumbHeight = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultAudio) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultAudio) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"audio_url":`)
	fflib.WriteJsonString(buf, string(j.AudioURL))
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteByte(',')
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if len(j.ParseMode) != 0 {
		buf.WriteString(`"parse_mode":`)
		fflib.WriteJsonString(buf, string(j.ParseMode))
		buf.WriteByte(',')
	}
	if len(j.Performer) != 0 {
		buf.WriteString(`"performer":`)
		fflib.WriteJsonString(buf, string(j.Performer))
		buf.WriteByte(',')
	}
	if j.AudioDuration != 0 {
		buf.WriteString(`"audio_duration":`)
		fflib.FormatBits2(buf, uint64(j.AudioDuration), 10, j.AudioDuration < 0)
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = j.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultAudiobase = iota
	ffjtInlineQueryResultAudionosuchkey

	ffjtInlineQueryResultAudioType

	ffjtInlineQueryResultAudioID

	ffjtInlineQueryResultAudioAudioURL

	ffjtInlineQueryResultAudioTitle

	ffjtInlineQueryResultAudioCaption

	ffjtInlineQueryResultAudioParseMode

	ffjtInlineQueryResultAudioPerformer

	ffjtInlineQueryResultAudioAudioDuration

	ffjtInlineQueryResultAudioReplyMarkup

	ffjtInlineQueryResultAudioInputMessageContent
)

var ffjKeyInlineQueryResultAudioType = []byte("type")

var ffjKeyInlineQueryResultAudioID = []byte("id")

var ffjKeyInlineQueryResultAudioAudioURL = []byte("audio_url")

var ffjKeyInlineQueryResultAudioTitle = []byte("title")

var ffjKeyInlineQueryResultAudioCaption = []byte("caption")

var ffjKeyInlineQueryResultAudioParseMode = []byte("parse_mode")

var ffjKeyInlineQueryResultAudioPerformer = []byte("performer")

var ffjKeyInlineQueryResultAudioAudioDuration = []byte("audio_duration")

var ffjKeyInlineQueryResultAudioReplyMarkup = []byte("reply_markup")

var ffjKeyInlineQueryResultAudioInputMessageContent = []byte("input_message_content")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultAudio) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultAudio) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultAudiobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultAudionosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyInlineQueryResultAudioAudioURL, kn) {
						currentKey = ffjtInlineQueryResultAudioAudioURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultAudioAudioDuration, kn) {
						currentKey = ffjtInlineQueryResultAudioAudioDuration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyInlineQueryResultAudioCaption, kn) {
						currentKey = ffjtInlineQueryResultAudioCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultAudioID, kn) {
						currentKey = ffjtInlineQueryResultAudioID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultAudioInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultAudioInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInlineQueryResultAudioParseMode, kn) {
						currentKey = ffjtInlineQueryResultAudioParseMode
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultAudioPerformer, kn) {
						currentKey = ffjtInlineQueryResultAudioPerformer
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultAudioReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultAudioReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultAudioType, kn) {
						currentKey = ffjtInlineQueryResultAudioType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultAudioTitle, kn) {
						currentKey = ffjtInlineQueryResultAudioTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultAudioInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultAudioInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultAudioReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultAudioReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultAudioAudioDuration, kn) {
					currentKey = ffjtInlineQueryResultAudioAudioDuration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultAudioPerformer, kn) {
					currentKey = ffjtInlineQueryResultAudioPerformer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultAudioParseMode, kn) {
					currentKey = ffjtInlineQueryResultAudioParseMode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultAudioCaption, kn) {
					currentKey = ffjtInlineQueryResultAudioCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultAudioTitle, kn) {
					currentKey = ffjtInlineQueryResultAudioTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultAudioAudioURL, kn) {
					currentKey = ffjtInlineQueryResultAudioAudioURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultAudioID, kn) {
					currentKey = ffjtInlineQueryResultAudioID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultAudioType, kn) {
					currentKey = ffjtInlineQueryResultAudioType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultAudionosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultAudioType:
					goto handle_Type

				case ffjtInlineQueryResultAudioID:
					goto handle_ID

				case ffjtInlineQueryResultAudioAudioURL:
					goto handle_AudioURL

				case ffjtInlineQueryResultAudioTitle:
					goto handle_Title

				case ffjtInlineQueryResultAudioCaption:
					goto handle_Caption

				case ffjtInlineQueryResultAudioParseMode:
					goto handle_ParseMode

				case ffjtInlineQueryResultAudioPerformer:
					goto handle_Performer

				case ffjtInlineQueryResultAudioAudioDuration:
					goto handle_AudioDuration

				case ffjtInlineQueryResultAudioReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultAudioInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultAudionosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AudioURL:

	/* handler: j.AudioURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.AudioURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ParseMode:

	/* handler: j.ParseMode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ParseMode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Performer:

	/* handler: j.Performer type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Performer = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AudioDuration:

	/* handler: j.AudioDuration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.AudioDuration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=telegram.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReplyMarkup = nil

		} else {

			if j.ReplyMarkup == nil {
				j.ReplyMarkup = new(InlineKeyboardMarkup)
			}

			err = j.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultCachedAudio) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultCachedAudio) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"audio_file_id":`)
	fflib.WriteJsonString(buf, string(j.AudioFileID))
	buf.WriteByte(',')
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if len(j.ParseMode) != 0 {
		buf.WriteString(`"parse_mode":`)
		fflib.WriteJsonString(buf, string(j.ParseMode))
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = j.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultCachedAudiobase = iota
	ffjtInlineQueryResultCachedAudionosuchkey

	ffjtInlineQueryResultCachedAudioType

	ffjtInlineQueryResultCachedAudioID

	ffjtInlineQueryResultCachedAudioAudioFileID

	ffjtInlineQueryResultCachedAudioCaption

	ffjtInlineQueryResultCachedAudioParseMode

	ffjtInlineQueryResultCachedAudioReplyMarkup

	ffjtInlineQueryResultCachedAudioInputMessageContent
)

var ffjKeyInlineQueryResultCachedAudioType = []byte("type")

var ffjKeyInlineQueryResultCachedAudioID = []byte("id")

var ffjKeyInlineQueryResultCachedAudioAudioFileID = []byte("audio_file_id")

var ffjKeyInlineQueryResultCachedAudioCaption = []byte("caption")

var ffjKeyInlineQueryResultCachedAudioParseMode = []byte("parse_mode")

var ffjKeyInlineQueryResultCachedAudioReplyMarkup = []byte("reply_markup")

var ffjKeyInlineQueryResultCachedAudioInputMessageContent = []byte("input_message_content")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultCachedAudio) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultCachedAudio) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultCachedAudiobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultCachedAudionosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyInlineQueryResultCachedAudioAudioFileID, kn) {
						currentKey = ffjtInlineQueryResultCachedAudioAudioFileID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyInlineQueryResultCachedAudioCaption, kn) {
						currentKey = ffjtInlineQueryResultCachedAudioCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultCachedAudioID, kn) {
						currentKey = ffjtInlineQueryResultCachedAudioID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultCachedAudioInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultCachedAudioInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInlineQueryResultCachedAudioParseMode, kn) {
						currentKey = ffjtInlineQueryResultCachedAudioParseMode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultCachedAudioReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultCachedAudioReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultCachedAudioType, kn) {
						currentKey = ffjtInlineQueryResultCachedAudioType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedAudioInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultCachedAudioInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedAudioReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultCachedAudioReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedAudioParseMode, kn) {
					currentKey = ffjtInlineQueryResultCachedAudioParseMode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedAudioCaption, kn) {
					currentKey = ffjtInlineQueryResultCachedAudioCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultCachedAudioAudioFileID, kn) {
					currentKey = ffjtInlineQueryResultCachedAudioAudioFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedAudioID, kn) {
					currentKey = ffjtInlineQueryResultCachedAudioID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedAudioType, kn) {
					currentKey = ffjtInlineQueryResultCachedAudioType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultCachedAudionosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultCachedAudioType:
					goto handle_Type

				case ffjtInlineQueryResultCachedAudioID:
					goto handle_ID

				case ffjtInlineQueryResultCachedAudioAudioFileID:
					goto handle_AudioFileID

				case ffjtInlineQueryResultCachedAudioCaption:
					goto handle_Caption

				case ffjtInlineQueryResultCachedAudioParseMode:
					goto handle_ParseMode

				case ffjtInlineQueryResultCachedAudioReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultCachedAudioInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultCachedAudionosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AudioFileID:

	/* handler: j.AudioFileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.AudioFileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ParseMode:

	/* handler: j.ParseMode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ParseMode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=telegram.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReplyMarkup = nil

		} else {

			if j.ReplyMarkup == nil {
				j.ReplyMarkup = new(InlineKeyboardMarkup)
			}

			err = j.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultCachedDocument) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultCachedDocument) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteString(`,"document_file_id":`)
	fflib.WriteJsonString(buf, string(j.DocumentFileID))
	buf.WriteByte(',')
	if len(j.Description) != 0 {
		buf.WriteString(`"description":`)
		fflib.WriteJsonString(buf, string(j.Description))
		buf.WriteByte(',')
	}
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if len(j.ParseMode) != 0 {
		buf.WriteString(`"parse_mode":`)
		fflib.WriteJsonString(buf, string(j.ParseMode))
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = j.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultCachedDocumentbase = iota
	ffjtInlineQueryResultCachedDocumentnosuchkey

	ffjtInlineQueryResultCachedDocumentType

	ffjtInlineQueryResultCachedDocumentID

	ffjtInlineQueryResultCachedDocumentTitle

	ffjtInlineQueryResultCachedDocumentDocumentFileID

	ffjtInlineQueryResultCachedDocumentDescription

	ffjtInlineQueryResultCachedDocumentCaption

	ffjtInlineQueryResultCachedDocumentParseMode

	ffjtInlineQueryResultCachedDocumentReplyMarkup

	ffjtInlineQueryResultCachedDocumentInputMessageContent
)

var ffjKeyInlineQueryResultCachedDocumentType = []byte("type")

var ffjKeyInlineQueryResultCachedDocumentID = []byte("id")

var ffjKeyInlineQueryResultCachedDocumentTitle = []byte("title")

var ffjKeyInlineQueryResultCachedDocumentDocumentFileID = []byte("document_file_id")

var ffjKeyInlineQueryResultCachedDocumentDescription = []byte("description")

var ffjKeyInlineQueryResultCachedDocumentCaption = []byte("caption")

var ffjKeyInlineQueryResultCachedDocumentParseMode = []byte("parse_mode")

var ffjKeyInlineQueryResultCachedDocumentReplyMarkup = []byte("reply_markup")

var ffjKeyInlineQueryResultCachedDocumentInputMessageContent = []byte("input_message_content")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultCachedDocument) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultCachedDocument) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultCachedDocumentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultCachedDocumentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInlineQueryResultCachedDocumentCaption, kn) {
						currentKey = ffjtInlineQueryResultCachedDocumentCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyInlineQueryResultCachedDocumentDocumentFileID, kn) {
						currentKey = ffjtInlineQueryResultCachedDocumentDocumentFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultCachedDocumentDescription, kn) {
						currentKey = ffjtInlineQueryResultCachedDocumentDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultCachedDocumentID, kn) {
						currentKey = ffjtInlineQueryResultCachedDocumentID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultCachedDocumentInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultCachedDocumentInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInlineQueryResultCachedDocumentParseMode, kn) {
						currentKey = ffjtInlineQueryResultCachedDocumentParseMode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultCachedDocumentReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultCachedDocumentReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultCachedDocumentType, kn) {
						currentKey = ffjtInlineQueryResultCachedDocumentType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultCachedDocumentTitle, kn) {
						currentKey = ffjtInlineQueryResultCachedDocumentTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedDocumentInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultCachedDocumentInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedDocumentReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultCachedDocumentReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedDocumentParseMode, kn) {
					currentKey = ffjtInlineQueryResultCachedDocumentParseMode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedDocumentCaption, kn) {
					currentKey = ffjtInlineQueryResultCachedDocumentCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedDocumentDescription, kn) {
					currentKey = ffjtInlineQueryResultCachedDocumentDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultCachedDocumentDocumentFileID, kn) {
					currentKey = ffjtInlineQueryResultCachedDocumentDocumentFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedDocumentTitle, kn) {
					currentKey = ffjtInlineQueryResultCachedDocumentTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedDocumentID, kn) {
					currentKey = ffjtInlineQueryResultCachedDocumentID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedDocumentType, kn) {
					currentKey = ffjtInlineQueryResultCachedDocumentType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultCachedDocumentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultCachedDocumentType:
					goto handle_Type

				case ffjtInlineQueryResultCachedDocumentID:
					goto handle_ID

				case ffjtInlineQueryResultCachedDocumentTitle:
					goto handle_Title

				case ffjtInlineQueryResultCachedDocumentDocumentFileID:
					goto handle_DocumentFileID

				case ffjtInlineQueryResultCachedDocumentDescription:
					goto handle_Description

				case ffjtInlineQueryResultCachedDocumentCaption:
					goto handle_Caption

				case ffjtInlineQueryResultCachedDocumentParseMode:
					goto handle_ParseMode

				case ffjtInlineQueryResultCachedDocumentReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultCachedDocumentInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultCachedDocumentnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DocumentFileID:

	/* handler: j.DocumentFileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.DocumentFileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ParseMode:

	/* handler: j.ParseMode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ParseMode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=telegram.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReplyMarkup = nil

		} else {

			if j.ReplyMarkup == nil {
				j.ReplyMarkup = new(InlineKeyboardMarkup)
			}

			err = j.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultCachedGif) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultCachedGif) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"gif_file_id":`)
	fflib.WriteJsonString(buf, string(j.GifFileID))
	buf.WriteByte(',')
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if len(j.ParseMode) != 0 {
		buf.WriteString(`"parse_mode":`)
		fflib.WriteJsonString(buf, string(j.ParseMode))
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = j.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultCachedGifbase = iota
	ffjtInlineQueryResultCachedGifnosuchkey

	ffjtInlineQueryResultCachedGifType

	ffjtInlineQueryResultCachedGifID

	ffjtInlineQueryResultCachedGifGifFileID

	ffjtInlineQueryResultCachedGifTitle

	ffjtInlineQueryResultCachedGifCaption

	ffjtInlineQueryResultCachedGifParseMode

	ffjtInlineQueryResultCachedGifReplyMarkup

	ffjtInlineQueryResultCachedGifInputMessageContent
)

var ffjKeyInlineQueryResultCachedGifType = []byte("type")

var ffjKeyInlineQueryResultCachedGifID = []byte("id")

var ffjKeyInlineQueryResultCachedGifGifFileID = []byte("gif_file_id")

var ffjKeyInlineQueryResultCachedGifTitle = []byte("title")

var ffjKeyInlineQueryResultCachedGifCaption = []byte("caption")

var ffjKeyInlineQueryResultCachedGifParseMode = []byte("parse_mode")

var ffjKeyInlineQueryResultCachedGifReplyMarkup = []byte("reply_markup")

var ffjKeyInlineQueryResultCachedGifInputMessageContent = []byte("input_message_content")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultCachedGif) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultCachedGif) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultCachedGifbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultCachedGifnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInlineQueryResultCachedGifCaption, kn) {
						currentKey = ffjtInlineQueryResultCachedGifCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyInlineQueryResultCachedGifGifFileID, kn) {
						currentKey = ffjtInlineQueryResultCachedGifGifFileID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultCachedGifID, kn) {
						currentKey = ffjtInlineQueryResultCachedGifID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultCachedGifInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultCachedGifInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInlineQueryResultCachedGifParseMode, kn) {
						currentKey = ffjtInlineQueryResultCachedGifParseMode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultCachedGifReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultCachedGifReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultCachedGifType, kn) {
						currentKey = ffjtInlineQueryResultCachedGifType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultCachedGifTitle, kn) {
						currentKey = ffjtInlineQueryResultCachedGifTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedGifInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultCachedGifInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedGifReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultCachedGifReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedGifParseMode, kn) {
					currentKey = ffjtInlineQueryResultCachedGifParseMode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedGifCaption, kn) {
					currentKey = ffjtInlineQueryResultCachedGifCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedGifTitle, kn) {
					currentKey = ffjtInlineQueryResultCachedGifTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultCachedGifGifFileID, kn) {
					currentKey = ffjtInlineQueryResultCachedGifGifFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedGifID, kn) {
					currentKey = ffjtInlineQueryResultCachedGifID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedGifType, kn) {
					currentKey = ffjtInlineQueryResultCachedGifType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultCachedGifnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultCachedGifType:
					goto handle_Type

				case ffjtInlineQueryResultCachedGifID:
					goto handle_ID

				case ffjtInlineQueryResultCachedGifGifFileID:
					goto handle_GifFileID

				case ffjtInlineQueryResultCachedGifTitle:
					goto handle_Title

				case ffjtInlineQueryResultCachedGifCaption:
					goto handle_Caption

				case ffjtInlineQueryResultCachedGifParseMode:
					goto handle_ParseMode

				case ffjtInlineQueryResultCachedGifReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultCachedGifInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultCachedGifnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GifFileID:

	/* handler: j.GifFileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.GifFileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ParseMode:

	/* handler: j.ParseMode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ParseMode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=telegram.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReplyMarkup = nil

		} else {

			if j.ReplyMarkup == nil {
				j.ReplyMarkup = new(InlineKeyboardMarkup)
			}

			err = j.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultCachedMpeg4Gif) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultCachedMpeg4Gif) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"mpeg4_file_id":`)
	fflib.WriteJsonString(buf, string(j.Mpeg4FileID))
	buf.WriteByte(',')
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if len(j.ParseMode) != 0 {
		buf.WriteString(`"parse_mode":`)
		fflib.WriteJsonString(buf, string(j.ParseMode))
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = j.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultCachedMpeg4Gifbase = iota
	ffjtInlineQueryResultCachedMpeg4Gifnosuchkey

	ffjtInlineQueryResultCachedMpeg4GifType

	ffjtInlineQueryResultCachedMpeg4GifID

	ffjtInlineQueryResultCachedMpeg4GifMpeg4FileID

	ffjtInlineQueryResultCachedMpeg4GifTitle

	ffjtInlineQueryResultCachedMpeg4GifCaption

	ffjtInlineQueryResultCachedMpeg4GifParseMode

	ffjtInlineQueryResultCachedMpeg4GifReplyMarkup

	ffjtInlineQueryResultCachedMpeg4GifInputMessageContent
)

var ffjKeyInlineQueryResultCachedMpeg4GifType = []byte("type")

var ffjKeyInlineQueryResultCachedMpeg4GifID = []byte("id")

var ffjKeyInlineQueryResultCachedMpeg4GifMpeg4FileID = []byte("mpeg4_file_id")

var ffjKeyInlineQueryResultCachedMpeg4GifTitle = []byte("title")

var ffjKeyInlineQueryResultCachedMpeg4GifCaption = []byte("caption")

var ffjKeyInlineQueryResultCachedMpeg4GifParseMode = []byte("parse_mode")

var ffjKeyInlineQueryResultCachedMpeg4GifReplyMarkup = []byte("reply_markup")

var ffjKeyInlineQueryResultCachedMpeg4GifInputMessageContent = []byte("input_message_content")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultCachedMpeg4Gif) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultCachedMpeg4Gif) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultCachedMpeg4Gifbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultCachedMpeg4Gifnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInlineQueryResultCachedMpeg4GifCaption, kn) {
						currentKey = ffjtInlineQueryResultCachedMpeg4GifCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultCachedMpeg4GifID, kn) {
						currentKey = ffjtInlineQueryResultCachedMpeg4GifID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultCachedMpeg4GifInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultCachedMpeg4GifInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyInlineQueryResultCachedMpeg4GifMpeg4FileID, kn) {
						currentKey = ffjtInlineQueryResultCachedMpeg4GifMpeg4FileID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInlineQueryResultCachedMpeg4GifParseMode, kn) {
						currentKey = ffjtInlineQueryResultCachedMpeg4GifParseMode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultCachedMpeg4GifReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultCachedMpeg4GifReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultCachedMpeg4GifType, kn) {
						currentKey = ffjtInlineQueryResultCachedMpeg4GifType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultCachedMpeg4GifTitle, kn) {
						currentKey = ffjtInlineQueryResultCachedMpeg4GifTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedMpeg4GifInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultCachedMpeg4GifInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedMpeg4GifReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultCachedMpeg4GifReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedMpeg4GifParseMode, kn) {
					currentKey = ffjtInlineQueryResultCachedMpeg4GifParseMode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedMpeg4GifCaption, kn) {
					currentKey = ffjtInlineQueryResultCachedMpeg4GifCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedMpeg4GifTitle, kn) {
					currentKey = ffjtInlineQueryResultCachedMpeg4GifTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultCachedMpeg4GifMpeg4FileID, kn) {
					currentKey = ffjtInlineQueryResultCachedMpeg4GifMpeg4FileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedMpeg4GifID, kn) {
					currentKey = ffjtInlineQueryResultCachedMpeg4GifID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedMpeg4GifType, kn) {
					currentKey = ffjtInlineQueryResultCachedMpeg4GifType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultCachedMpeg4Gifnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultCachedMpeg4GifType:
					goto handle_Type

				case ffjtInlineQueryResultCachedMpeg4GifID:
					goto handle_ID

				case ffjtInlineQueryResultCachedMpeg4GifMpeg4FileID:
					goto handle_Mpeg4FileID

				case ffjtInlineQueryResultCachedMpeg4GifTitle:
					goto handle_Title

				case ffjtInlineQueryResultCachedMpeg4GifCaption:
					goto handle_Caption

				case ffjtInlineQueryResultCachedMpeg4GifParseMode:
					goto handle_ParseMode

				case ffjtInlineQueryResultCachedMpeg4GifReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultCachedMpeg4GifInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultCachedMpeg4Gifnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mpeg4FileID:

	/* handler: j.Mpeg4FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Mpeg4FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ParseMode:

	/* handler: j.ParseMode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ParseMode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=telegram.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReplyMarkup = nil

		} else {

			if j.ReplyMarkup == nil {
				j.ReplyMarkup = new(InlineKeyboardMarkup)
			}

			err = j.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultCachedPhoto) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultCachedPhoto) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"photo_file_id":`)
	fflib.WriteJsonString(buf, string(j.PhotoFileID))
	buf.WriteByte(',')
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	if len(j.Description) != 0 {
		buf.WriteString(`"description":`)
		fflib.WriteJsonString(buf, string(j.Description))
		buf.WriteByte(',')
	}
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if len(j.ParseMode) != 0 {
		buf.WriteString(`"parse_mode":`)
		fflib.WriteJsonString(buf, string(j.ParseMode))
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = j.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultCachedPhotobase = iota
	ffjtInlineQueryResultCachedPhotonosuchkey

	ffjtInlineQueryResultCachedPhotoType

	ffjtInlineQueryResultCachedPhotoID

	ffjtInlineQueryResultCachedPhotoPhotoFileID

	ffjtInlineQueryResultCachedPhotoTitle

	ffjtInlineQueryResultCachedPhotoDescription

	ffjtInlineQueryResultCachedPhotoCaption

	ffjtInlineQueryResultCachedPhotoParseMode

	ffjtInlineQueryResultCachedPhotoReplyMarkup

	ffjtInlineQueryResultCachedPhotoInputMessageContent
)

var ffjKeyInlineQueryResultCachedPhotoType = []byte("type")

var ffjKeyInlineQueryResultCachedPhotoID = []byte("id")

var ffjKeyInlineQueryResultCachedPhotoPhotoFileID = []byte("photo_file_id")

var ffjKeyInlineQueryResultCachedPhotoTitle = []byte("title")

var ffjKeyInlineQueryResultCachedPhotoDescription = []byte("description")

var ffjKeyInlineQueryResultCachedPhotoCaption = []byte("caption")

var ffjKeyInlineQueryResultCachedPhotoParseMode = []byte("parse_mode")

var ffjKeyInlineQueryResultCachedPhotoReplyMarkup = []byte("reply_markup")

var ffjKeyInlineQueryResultCachedPhotoInputMessageContent = []byte("input_message_content")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultCachedPhoto) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultCachedPhoto) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultCachedPhotobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultCachedPhotonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInlineQueryResultCachedPhotoCaption, kn) {
						currentKey = ffjtInlineQueryResultCachedPhotoCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyInlineQueryResultCachedPhotoDescription, kn) {
						currentKey = ffjtInlineQueryResultCachedPhotoDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultCachedPhotoID, kn) {
						currentKey = ffjtInlineQueryResultCachedPhotoID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultCachedPhotoInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultCachedPhotoInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInlineQueryResultCachedPhotoPhotoFileID, kn) {
						currentKey = ffjtInlineQueryResultCachedPhotoPhotoFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultCachedPhotoParseMode, kn) {
						currentKey = ffjtInlineQueryResultCachedPhotoParseMode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultCachedPhotoReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultCachedPhotoReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultCachedPhotoType, kn) {
						currentKey = ffjtInlineQueryResultCachedPhotoType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultCachedPhotoTitle, kn) {
						currentKey = ffjtInlineQueryResultCachedPhotoTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedPhotoInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultCachedPhotoInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedPhotoReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultCachedPhotoReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedPhotoParseMode, kn) {
					currentKey = ffjtInlineQueryResultCachedPhotoParseMode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedPhotoCaption, kn) {
					currentKey = ffjtInlineQueryResultCachedPhotoCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedPhotoDescription, kn) {
					currentKey = ffjtInlineQueryResultCachedPhotoDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedPhotoTitle, kn) {
					currentKey = ffjtInlineQueryResultCachedPhotoTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultCachedPhotoPhotoFileID, kn) {
					currentKey = ffjtInlineQueryResultCachedPhotoPhotoFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedPhotoID, kn) {
					currentKey = ffjtInlineQueryResultCachedPhotoID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedPhotoType, kn) {
					currentKey = ffjtInlineQueryResultCachedPhotoType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultCachedPhotonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultCachedPhotoType:
					goto handle_Type

				case ffjtInlineQueryResultCachedPhotoID:
					goto handle_ID

				case ffjtInlineQueryResultCachedPhotoPhotoFileID:
					goto handle_PhotoFileID

				case ffjtInlineQueryResultCachedPhotoTitle:
					goto handle_Title

				case ffjtInlineQueryResultCachedPhotoDescription:
					goto handle_Description

				case ffjtInlineQueryResultCachedPhotoCaption:
					goto handle_Caption

				case ffjtInlineQueryResultCachedPhotoParseMode:
					goto handle_ParseMode

				case ffjtInlineQueryResultCachedPhotoReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultCachedPhotoInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultCachedPhotonosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PhotoFileID:

	/* handler: j.PhotoFileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PhotoFileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ParseMode:

	/* handler: j.ParseMode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ParseMode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=telegram.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReplyMarkup = nil

		} else {

			if j.ReplyMarkup == nil {
				j.ReplyMarkup = new(InlineKeyboardMarkup)
			}

			err = j.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultCachedSticker) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultCachedSticker) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"sticker_file_id":`)
	fflib.WriteJsonString(buf, string(j.StickerFileID))
	buf.WriteByte(',')
	if j.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = j.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultCachedStickerbase = iota
	ffjtInlineQueryResultCachedStickernosuchkey

	ffjtInlineQueryResultCachedStickerType

	ffjtInlineQueryResultCachedStickerID

	ffjtInlineQueryResultCachedStickerStickerFileID

	ffjtInlineQueryResultCachedStickerReplyMarkup

	ffjtInlineQueryResultCachedStickerInputMessageContent
)

var ffjKeyInlineQueryResultCachedStickerType = []byte("type")

var ffjKeyInlineQueryResultCachedStickerID = []byte("id")

var ffjKeyInlineQueryResultCachedStickerStickerFileID = []byte("sticker_file_id")

var ffjKeyInlineQueryResultCachedStickerReplyMarkup = []byte("reply_markup")

var ffjKeyInlineQueryResultCachedStickerInputMessageContent = []byte("input_message_content")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultCachedSticker) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultCachedSticker) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultCachedStickerbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultCachedStickernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultCachedStickerID, kn) {
						currentKey = ffjtInlineQueryResultCachedStickerID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultCachedStickerInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultCachedStickerInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultCachedStickerReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultCachedStickerReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyInlineQueryResultCachedStickerStickerFileID, kn) {
						currentKey = ffjtInlineQueryResultCachedStickerStickerFileID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultCachedStickerType, kn) {
						currentKey = ffjtInlineQueryResultCachedStickerType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedStickerInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultCachedStickerInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedStickerReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultCachedStickerReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedStickerStickerFileID, kn) {
					currentKey = ffjtInlineQueryResultCachedStickerStickerFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedStickerID, kn) {
					currentKey = ffjtInlineQueryResultCachedStickerID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedStickerType, kn) {
					currentKey = ffjtInlineQueryResultCachedStickerType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultCachedStickernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultCachedStickerType:
					goto handle_Type

				case ffjtInlineQueryResultCachedStickerID:
					goto handle_ID

				case ffjtInlineQueryResultCachedStickerStickerFileID:
					goto handle_StickerFileID

				case ffjtInlineQueryResultCachedStickerReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultCachedStickerInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultCachedStickernosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StickerFileID:

	/* handler: j.StickerFileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.StickerFileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=telegram.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReplyMarkup = nil

		} else {

			if j.ReplyMarkup == nil {
				j.ReplyMarkup = new(InlineKeyboardMarkup)
			}

			err = j.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultCachedVideo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultCachedVideo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"video_file_id":`)
	fflib.WriteJsonString(buf, string(j.VideoFileID))
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteByte(',')
	if len(j.Description) != 0 {
		buf.WriteString(`"description":`)
		fflib.WriteJsonString(buf, string(j.Description))
		buf.WriteByte(',')
	}
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if len(j.ParseMode) != 0 {
		buf.WriteString(`"parse_mode":`)
		fflib.WriteJsonString(buf, string(j.ParseMode))
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = j.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultCachedVideobase = iota
	ffjtInlineQueryResultCachedVideonosuchkey

	ffjtInlineQueryResultCachedVideoType

	ffjtInlineQueryResultCachedVideoID

	ffjtInlineQueryResultCachedVideoVideoFileID

	ffjtInlineQueryResultCachedVideoTitle

	ffjtInlineQueryResultCachedVideoDescription

	ffjtInlineQueryResultCachedVideoCaption

	ffjtInlineQueryResultCachedVideoParseMode

	ffjtInlineQueryResultCachedVideoReplyMarkup

	ffjtInlineQueryResultCachedVideoInputMessageContent
)

var ffjKeyInlineQueryResultCachedVideoType = []byte("type")

var ffjKeyInlineQueryResultCachedVideoID = []byte("id")

var ffjKeyInlineQueryResultCachedVideoVideoFileID = []byte("video_file_id")

var ffjKeyInlineQueryResultCachedVideoTitle = []byte("title")

var ffjKeyInlineQueryResultCachedVideoDescription = []byte("description")

var ffjKeyInlineQueryResultCachedVideoCaption = []byte("caption")

var ffjKeyInlineQueryResultCachedVideoParseMode = []byte("parse_mode")

var ffjKeyInlineQueryResultCachedVideoReplyMarkup = []byte("reply_markup")

var ffjKeyInlineQueryResultCachedVideoInputMessageContent = []byte("input_message_content")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultCachedVideo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultCachedVideo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultCachedVideobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultCachedVideonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInlineQueryResultCachedVideoCaption, kn) {
						currentKey = ffjtInlineQueryResultCachedVideoCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyInlineQueryResultCachedVideoDescription, kn) {
						currentKey = ffjtInlineQueryResultCachedVideoDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultCachedVideoID, kn) {
						currentKey = ffjtInlineQueryResultCachedVideoID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultCachedVideoInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultCachedVideoInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInlineQueryResultCachedVideoParseMode, kn) {
						currentKey = ffjtInlineQueryResultCachedVideoParseMode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultCachedVideoReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultCachedVideoReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultCachedVideoType, kn) {
						currentKey = ffjtInlineQueryResultCachedVideoType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultCachedVideoTitle, kn) {
						currentKey = ffjtInlineQueryResultCachedVideoTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyInlineQueryResultCachedVideoVideoFileID, kn) {
						currentKey = ffjtInlineQueryResultCachedVideoVideoFileID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedVideoInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultCachedVideoInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedVideoReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultCachedVideoReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedVideoParseMode, kn) {
					currentKey = ffjtInlineQueryResultCachedVideoParseMode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedVideoCaption, kn) {
					currentKey = ffjtInlineQueryResultCachedVideoCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedVideoDescription, kn) {
					currentKey = ffjtInlineQueryResultCachedVideoDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedVideoTitle, kn) {
					currentKey = ffjtInlineQueryResultCachedVideoTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultCachedVideoVideoFileID, kn) {
					currentKey = ffjtInlineQueryResultCachedVideoVideoFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedVideoID, kn) {
					currentKey = ffjtInlineQueryResultCachedVideoID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedVideoType, kn) {
					currentKey = ffjtInlineQueryResultCachedVideoType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultCachedVideonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultCachedVideoType:
					goto handle_Type

				case ffjtInlineQueryResultCachedVideoID:
					goto handle_ID

				case ffjtInlineQueryResultCachedVideoVideoFileID:
					goto handle_VideoFileID

				case ffjtInlineQueryResultCachedVideoTitle:
					goto handle_Title

				case ffjtInlineQueryResultCachedVideoDescription:
					goto handle_Description

				case ffjtInlineQueryResultCachedVideoCaption:
					goto handle_Caption

				case ffjtInlineQueryResultCachedVideoParseMode:
					goto handle_ParseMode

				case ffjtInlineQueryResultCachedVideoReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultCachedVideoInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultCachedVideonosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VideoFileID:

	/* handler: j.VideoFileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.VideoFileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ParseMode:

	/* handler: j.ParseMode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ParseMode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=telegram.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReplyMarkup = nil

		} else {

			if j.ReplyMarkup == nil {
				j.ReplyMarkup = new(InlineKeyboardMarkup)
			}

			err = j.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultCachedVoice) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultCachedVoice) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"voice_file_id":`)
	fflib.WriteJsonString(buf, string(j.VoiceFileID))
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteByte(',')
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if len(j.ParseMode) != 0 {
		buf.WriteString(`"parse_mode":`)
		fflib.WriteJsonString(buf, string(j.ParseMode))
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = j.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultCachedVoicebase = iota
	ffjtInlineQueryResultCachedVoicenosuchkey

	ffjtInlineQueryResultCachedVoiceType

	ffjtInlineQueryResultCachedVoiceID

	ffjtInlineQueryResultCachedVoiceVoiceFileID

	ffjtInlineQueryResultCachedVoiceTitle

	ffjtInlineQueryResultCachedVoiceCaption

	ffjtInlineQueryResultCachedVoiceParseMode

	ffjtInlineQueryResultCachedVoiceReplyMarkup

	ffjtInlineQueryResultCachedVoiceInputMessageContent
)

var ffjKeyInlineQueryResultCachedVoiceType = []byte("type")

var ffjKeyInlineQueryResultCachedVoiceID = []byte("id")

var ffjKeyInlineQueryResultCachedVoiceVoiceFileID = []byte("voice_file_id")

var ffjKeyInlineQueryResultCachedVoiceTitle = []byte("title")

var ffjKeyInlineQueryResultCachedVoiceCaption = []byte("caption")

var ffjKeyInlineQueryResultCachedVoiceParseMode = []byte("parse_mode")

var ffjKeyInlineQueryResultCachedVoiceReplyMarkup = []byte("reply_markup")

var ffjKeyInlineQueryResultCachedVoiceInputMessageContent = []byte("input_message_content")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultCachedVoice) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultCachedVoice) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultCachedVoicebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultCachedVoicenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInlineQueryResultCachedVoiceCaption, kn) {
						currentKey = ffjtInlineQueryResultCachedVoiceCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultCachedVoiceID, kn) {
						currentKey = ffjtInlineQueryResultCachedVoiceID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultCachedVoiceInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultCachedVoiceInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInlineQueryResultCachedVoiceParseMode, kn) {
						currentKey = ffjtInlineQueryResultCachedVoiceParseMode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultCachedVoiceReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultCachedVoiceReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultCachedVoiceType, kn) {
						currentKey = ffjtInlineQueryResultCachedVoiceType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultCachedVoiceTitle, kn) {
						currentKey = ffjtInlineQueryResultCachedVoiceTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyInlineQueryResultCachedVoiceVoiceFileID, kn) {
						currentKey = ffjtInlineQueryResultCachedVoiceVoiceFileID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedVoiceInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultCachedVoiceInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedVoiceReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultCachedVoiceReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedVoiceParseMode, kn) {
					currentKey = ffjtInlineQueryResultCachedVoiceParseMode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedVoiceCaption, kn) {
					currentKey = ffjtInlineQueryResultCachedVoiceCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedVoiceTitle, kn) {
					currentKey = ffjtInlineQueryResultCachedVoiceTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultCachedVoiceVoiceFileID, kn) {
					currentKey = ffjtInlineQueryResultCachedVoiceVoiceFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedVoiceID, kn) {
					currentKey = ffjtInlineQueryResultCachedVoiceID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedVoiceType, kn) {
					currentKey = ffjtInlineQueryResultCachedVoiceType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultCachedVoicenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultCachedVoiceType:
					goto handle_Type

				case ffjtInlineQueryResultCachedVoiceID:
					goto handle_ID

				case ffjtInlineQueryResultCachedVoiceVoiceFileID:
					goto handle_VoiceFileID

				case ffjtInlineQueryResultCachedVoiceTitle:
					goto handle_Title

				case ffjtInlineQueryResultCachedVoiceCaption:
					goto handle_Caption

				case ffjtInlineQueryResultCachedVoiceParseMode:
					goto handle_ParseMode

				case ffjtInlineQueryResultCachedVoiceReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultCachedVoiceInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultCachedVoicenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VoiceFileID:

	/* handler: j.VoiceFileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.VoiceFileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ParseMode:

	/* handler: j.ParseMode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ParseMode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=telegram.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReplyMarkup = nil

		} else {

			if j.ReplyMarkup == nil {
				j.ReplyMarkup = new(InlineKeyboardMarkup)
			}

			err = j.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultContact) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultContact) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"phone_number":`)
	fflib.WriteJsonString(buf, string(j.PhoneNumber))
	buf.WriteString(`,"first_name":`)
	fflib.WriteJsonString(buf, string(j.FirstName))
	buf.WriteByte(',')
	if len(j.LastName) != 0 {
		buf.WriteString(`"last_name":`)
		fflib.WriteJsonString(buf, string(j.LastName))
		buf.WriteByte(',')
	}
	if len(j.VCard) != 0 {
		buf.WriteString(`"vcard":`)
		fflib.WriteJsonString(buf, string(j.VCard))
		buf.WriteByte(',')
	}
	if len(j.ThumbURL) != 0 {
		buf.WriteString(`"thumb_url":`)
		fflib.WriteJsonString(buf, string(j.ThumbURL))
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = j.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	if j.ThumbWidth != 0 {
		buf.WriteString(`"thumb_width":`)
		fflib.FormatBits2(buf, uint64(j.ThumbWidth), 10, j.ThumbWidth < 0)
		buf.WriteByte(',')
	}
	if j.ThumbHeight != 0 {
		buf.WriteString(`"thumb_height":`)
		fflib.FormatBits2(buf, uint64(j.ThumbHeight), 10, j.ThumbHeight < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultContactbase = iota
	ffjtInlineQueryResultContactnosuchkey

	ffjtInlineQueryResultContactType

	ffjtInlineQueryResultContactID

	ffjtInlineQueryResultContactPhoneNumber

	ffjtInlineQueryResultContactFirstName

	ffjtInlineQueryResultContactLastName

	ffjtInlineQueryResultContactVCard

	ffjtInlineQueryResultContactThumbURL

	ffjtInlineQueryResultContactReplyMarkup

	ffjtInlineQueryResultContactInputMessageContent

	ffjtInlineQueryResultContactThumbWidth

	ffjtInlineQueryResultContactThumbHeight
)

var ffjKeyInlineQueryResultContactType = []byte("type")

var ffjKeyInlineQueryResultContactID = []byte("id")

var ffjKeyInlineQueryResultContactPhoneNumber = []byte("phone_number")

var ffjKeyInlineQueryResultContactFirstName = []byte("first_name")

var ffjKeyInlineQueryResultContactLastName = []byte("last_name")

var ffjKeyInlineQueryResultContactVCard = []byte("vcard")

var ffjKeyInlineQueryResultContactThumbURL = []byte("thumb_url")

var ffjKeyInlineQueryResultContactReplyMarkup = []byte("reply_markup")

var ffjKeyInlineQueryResultContactInputMessageContent = []byte("input_message_content")

var ffjKeyInlineQueryResultContactThumbWidth = []byte("thumb_width")

var ffjKeyInlineQueryResultContactThumbHeight = []byte("thumb_height")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultContact) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultContact) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultContactbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultContactnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyInlineQueryResultContactFirstName, kn) {
						currentKey = ffjtInlineQueryResultContactFirstName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultContactID, kn) {
						currentKey = ffjtInlineQueryResultContactID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultContactInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultContactInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyInlineQueryResultContactLastName, kn) {
						currentKey = ffjtInlineQueryResultContactLastName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInlineQueryResultContactPhoneNumber, kn) {
						currentKey = ffjtInlineQueryResultContactPhoneNumber
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultContactReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultContactReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultContactType, kn) {
						currentKey = ffjtInlineQueryResultContactType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultContactThumbURL, kn) {
						currentKey = ffjtInlineQueryResultContactThumbURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultContactThumbWidth, kn) {
						currentKey = ffjtInlineQueryResultContactThumbWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultContactThumbHeight, kn) {
						currentKey = ffjtInlineQueryResultContactThumbHeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyInlineQueryResultContactVCard, kn) {
						currentKey = ffjtInlineQueryResultContactVCard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultContactThumbHeight, kn) {
					currentKey = ffjtInlineQueryResultContactThumbHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultContactThumbWidth, kn) {
					currentKey = ffjtInlineQueryResultContactThumbWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultContactInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultContactInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultContactReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultContactReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultContactThumbURL, kn) {
					currentKey = ffjtInlineQueryResultContactThumbURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultContactVCard, kn) {
					currentKey = ffjtInlineQueryResultContactVCard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultContactLastName, kn) {
					currentKey = ffjtInlineQueryResultContactLastName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultContactFirstName, kn) {
					currentKey = ffjtInlineQueryResultContactFirstName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultContactPhoneNumber, kn) {
					currentKey = ffjtInlineQueryResultContactPhoneNumber
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultContactID, kn) {
					currentKey = ffjtInlineQueryResultContactID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultContactType, kn) {
					currentKey = ffjtInlineQueryResultContactType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultContactnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultContactType:
					goto handle_Type

				case ffjtInlineQueryResultContactID:
					goto handle_ID

				case ffjtInlineQueryResultContactPhoneNumber:
					goto handle_PhoneNumber

				case ffjtInlineQueryResultContactFirstName:
					goto handle_FirstName

				case ffjtInlineQueryResultContactLastName:
					goto handle_LastName

				case ffjtInlineQueryResultContactVCard:
					goto handle_VCard

				case ffjtInlineQueryResultContactThumbURL:
					goto handle_ThumbURL

				case ffjtInlineQueryResultContactReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultContactInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultContactThumbWidth:
					goto handle_ThumbWidth

				case ffjtInlineQueryResultContactThumbHeight:
					goto handle_ThumbHeight

				case ffjtInlineQueryResultContactnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PhoneNumber:

	/* handler: j.PhoneNumber type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PhoneNumber = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FirstName:

	/* handler: j.FirstName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FirstName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastName:

	/* handler: j.LastName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LastName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VCard:

	/* handler: j.VCard type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.VCard = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbURL:

	/* handler: j.ThumbURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ThumbURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=telegram.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReplyMarkup = nil

		} else {

			if j.ReplyMarkup == nil {
				j.ReplyMarkup = new(InlineKeyboardMarkup)
			}

			err = j.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbWidth:

	/* handler: j.ThumbWidth type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ThumbWidth = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbHeight:

	/* handler: j.ThumbHeight type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ThumbHeight = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultDocument) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultDocument) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteByte(',')
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if len(j.ParseMode) != 0 {
		buf.WriteString(`"parse_mode":`)
		fflib.WriteJsonString(buf, string(j.ParseMode))
		buf.WriteByte(',')
	}
	buf.WriteString(`"document_url":`)
	fflib.WriteJsonString(buf, string(j.DocumentURL))
	buf.WriteString(`,"mime_type":`)
	fflib.WriteJsonString(buf, string(j.MimeType))
	buf.WriteByte(',')
	if len(j.Description) != 0 {
		buf.WriteString(`"description":`)
		fflib.WriteJsonString(buf, string(j.Description))
		buf.WriteByte(',')
	}
	if len(j.ThumbURL) != 0 {
		buf.WriteString(`"thumb_url":`)
		fflib.WriteJsonString(buf, string(j.ThumbURL))
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = j.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	if j.ThumbWidth != 0 {
		buf.WriteString(`"thumb_width":`)
		fflib.FormatBits2(buf, uint64(j.ThumbWidth), 10, j.ThumbWidth < 0)
		buf.WriteByte(',')
	}
	if j.ThumbHeight != 0 {
		buf.WriteString(`"thumb_height":`)
		fflib.FormatBits2(buf, uint64(j.ThumbHeight), 10, j.ThumbHeight < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultDocumentbase = iota
	ffjtInlineQueryResultDocumentnosuchkey

	ffjtInlineQueryResultDocumentType

	ffjtInlineQueryResultDocumentID

	ffjtInlineQueryResultDocumentTitle

	ffjtInlineQueryResultDocumentCaption

	ffjtInlineQueryResultDocumentParseMode

	ffjtInlineQueryResultDocumentDocumentURL

	ffjtInlineQueryResultDocumentMimeType

	ffjtInlineQueryResultDocumentDescription

	ffjtInlineQueryResultDocumentThumbURL

	ffjtInlineQueryResultDocumentReplyMarkup

	ffjtInlineQueryResultDocumentInputMessageContent

	ffjtInlineQueryResultDocumentThumbWidth

	ffjtInlineQueryResultDocumentThumbHeight
)

var ffjKeyInlineQueryResultDocumentType = []byte("type")

var ffjKeyInlineQueryResultDocumentID = []byte("id")

var ffjKeyInlineQueryResultDocumentTitle = []byte("title")

var ffjKeyInlineQueryResultDocumentCaption = []byte("caption")

var ffjKeyInlineQueryResultDocumentParseMode = []byte("parse_mode")

var ffjKeyInlineQueryResultDocumentDocumentURL = []byte("document_url")

var ffjKeyInlineQueryResultDocumentMimeType = []byte("mime_type")

var ffjKeyInlineQueryResultDocumentDescription = []byte("description")

var ffjKeyInlineQueryResultDocumentThumbURL = []byte("thumb_url")

var ffjKeyInlineQueryResultDocumentReplyMarkup = []byte("reply_markup")

var ffjKeyInlineQueryResultDocumentInputMessageContent = []byte("input_message_content")

var ffjKeyInlineQueryResultDocumentThumbWidth = []byte("thumb_width")

var ffjKeyInlineQueryResultDocumentThumbHeight = []byte("thumb_height")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultDocument) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultDocument) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultDocumentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultDocumentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInlineQueryResultDocumentCaption, kn) {
						currentKey = ffjtInlineQueryResultDocumentCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyInlineQueryResultDocumentDocumentURL, kn) {
						currentKey = ffjtInlineQueryResultDocumentDocumentURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultDocumentDescription, kn) {
						currentKey = ffjtInlineQueryResultDocumentDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultDocumentID, kn) {
						currentKey = ffjtInlineQueryResultDocumentID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultDocumentInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultDocumentInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyInlineQueryResultDocumentMimeType, kn) {
						currentKey = ffjtInlineQueryResultDocumentMimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInlineQueryResultDocumentParseMode, kn) {
						currentKey = ffjtInlineQueryResultDocumentParseMode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultDocumentReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultDocumentReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultDocumentType, kn) {
						currentKey = ffjtInlineQueryResultDocumentType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultDocumentTitle, kn) {
						currentKey = ffjtInlineQueryResultDocumentTitle
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultDocumentThumbURL, kn) {
						currentKey = ffjtInlineQueryResultDocumentThumbURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultDocumentThumbWidth, kn) {
						currentKey = ffjtInlineQueryResultDocumentThumbWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultDocumentThumbHeight, kn) {
						currentKey = ffjtInlineQueryResultDocumentThumbHeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultDocumentThumbHeight, kn) {
					currentKey = ffjtInlineQueryResultDocumentThumbHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultDocumentThumbWidth, kn) {
					currentKey = ffjtInlineQueryResultDocumentThumbWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultDocumentInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultDocumentInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultDocumentReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultDocumentReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultDocumentThumbURL, kn) {
					currentKey = ffjtInlineQueryResultDocumentThumbURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultDocumentDescription, kn) {
					currentKey = ffjtInlineQueryResultDocumentDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultDocumentMimeType, kn) {
					currentKey = ffjtInlineQueryResultDocumentMimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultDocumentDocumentURL, kn) {
					currentKey = ffjtInlineQueryResultDocumentDocumentURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultDocumentParseMode, kn) {
					currentKey = ffjtInlineQueryResultDocumentParseMode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultDocumentCaption, kn) {
					currentKey = ffjtInlineQueryResultDocumentCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultDocumentTitle, kn) {
					currentKey = ffjtInlineQueryResultDocumentTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultDocumentID, kn) {
					currentKey = ffjtInlineQueryResultDocumentID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultDocumentType, kn) {
					currentKey = ffjtInlineQueryResultDocumentType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultDocumentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultDocumentType:
					goto handle_Type

				case ffjtInlineQueryResultDocumentID:
					goto handle_ID

				case ffjtInlineQueryResultDocumentTitle:
					goto handle_Title

				case ffjtInlineQueryResultDocumentCaption:
					goto handle_Caption

				case ffjtInlineQueryResultDocumentParseMode:
					goto handle_ParseMode

				case ffjtInlineQueryResultDocumentDocumentURL:
					goto handle_DocumentURL

				case ffjtInlineQueryResultDocumentMimeType:
					goto handle_MimeType

				case ffjtInlineQueryResultDocumentDescription:
					goto handle_Description

				case ffjtInlineQueryResultDocumentThumbURL:
					goto handle_ThumbURL

				case ffjtInlineQueryResultDocumentReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultDocumentInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultDocumentThumbWidth:
					goto handle_ThumbWidth

				case ffjtInlineQueryResultDocumentThumbHeight:
					goto handle_ThumbHeight

				case ffjtInlineQueryResultDocumentnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ParseMode:

	/* handler: j.ParseMode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ParseMode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DocumentURL:

	/* handler: j.DocumentURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.DocumentURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeType:

	/* handler: j.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbURL:

	/* handler: j.ThumbURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ThumbURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=telegram.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReplyMarkup = nil

		} else {

			if j.ReplyMarkup == nil {
				j.ReplyMarkup = new(InlineKeyboardMarkup)
			}

			err = j.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbWidth:

	/* handler: j.ThumbWidth type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ThumbWidth = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbHeight:

	/* handler: j.ThumbHeight type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ThumbHeight = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultGame) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultGame) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"game_short_name":`)
	fflib.WriteJsonString(buf, string(j.GameShortName))
	buf.WriteByte(',')
	if j.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = j.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultGamebase = iota
	ffjtInlineQueryResultGamenosuchkey

	ffjtInlineQueryResultGameType

	ffjtInlineQueryResultGameID

	ffjtInlineQueryResultGameGameShortName

	ffjtInlineQueryResultGameReplyMarkup
)

var ffjKeyInlineQueryResultGameType = []byte("type")

var ffjKeyInlineQueryResultGameID = []byte("id")

var ffjKeyInlineQueryResultGameGameShortName = []byte("game_short_name")

var ffjKeyInlineQueryResultGameReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultGame) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultGame) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultGamebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultGamenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffjKeyInlineQueryResultGameGameShortName, kn) {
						currentKey = ffjtInlineQueryResultGameGameShortName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultGameID, kn) {
						currentKey = ffjtInlineQueryResultGameID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultGameReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultGameReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultGameType, kn) {
						currentKey = ffjtInlineQueryResultGameType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultGameReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultGameReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultGameGameShortName, kn) {
					currentKey = ffjtInlineQueryResultGameGameShortName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultGameID, kn) {
					currentKey = ffjtInlineQueryResultGameID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultGameType, kn) {
					currentKey = ffjtInlineQueryResultGameType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultGamenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultGameType:
					goto handle_Type

				case ffjtInlineQueryResultGameID:
					goto handle_ID

				case ffjtInlineQueryResultGameGameShortName:
					goto handle_GameShortName

				case ffjtInlineQueryResultGameReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultGamenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GameShortName:

	/* handler: j.GameShortName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.GameShortName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=telegram.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReplyMarkup = nil

		} else {

			if j.ReplyMarkup == nil {
				j.ReplyMarkup = new(InlineKeyboardMarkup)
			}

			err = j.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultGif) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultGif) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"gif_url":`)
	fflib.WriteJsonString(buf, string(j.GifURL))
	buf.WriteString(`,"thumb_url":`)
	fflib.WriteJsonString(buf, string(j.ThumbURL))
	buf.WriteByte(',')
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if len(j.ParseMode) != 0 {
		buf.WriteString(`"parse_mode":`)
		fflib.WriteJsonString(buf, string(j.ParseMode))
		buf.WriteByte(',')
	}
	if j.GifWidth != 0 {
		buf.WriteString(`"gif_width":`)
		fflib.FormatBits2(buf, uint64(j.GifWidth), 10, j.GifWidth < 0)
		buf.WriteByte(',')
	}
	if j.GifHeight != 0 {
		buf.WriteString(`"gif_height":`)
		fflib.FormatBits2(buf, uint64(j.GifHeight), 10, j.GifHeight < 0)
		buf.WriteByte(',')
	}
	if j.GifDuration != 0 {
		buf.WriteString(`"gif_duration":`)
		fflib.FormatBits2(buf, uint64(j.GifDuration), 10, j.GifDuration < 0)
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = j.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultGifbase = iota
	ffjtInlineQueryResultGifnosuchkey

	ffjtInlineQueryResultGifType

	ffjtInlineQueryResultGifID

	ffjtInlineQueryResultGifGifURL

	ffjtInlineQueryResultGifThumbURL

	ffjtInlineQueryResultGifTitle

	ffjtInlineQueryResultGifCaption

	ffjtInlineQueryResultGifParseMode

	ffjtInlineQueryResultGifGifWidth

	ffjtInlineQueryResultGifGifHeight

	ffjtInlineQueryResultGifGifDuration

	ffjtInlineQueryResultGifReplyMarkup

	ffjtInlineQueryResultGifInputMessageContent
)

var ffjKeyInlineQueryResultGifType = []byte("type")

var ffjKeyInlineQueryResultGifID = []byte("id")

var ffjKeyInlineQueryResultGifGifURL = []byte("gif_url")

var ffjKeyInlineQueryResultGifThumbURL = []byte("thumb_url")

var ffjKeyInlineQueryResultGifTitle = []byte("title")

var ffjKeyInlineQueryResultGifCaption = []byte("caption")

var ffjKeyInlineQueryResultGifParseMode = []byte("parse_mode")

var ffjKeyInlineQueryResultGifGifWidth = []byte("gif_width")

var ffjKeyInlineQueryResultGifGifHeight = []byte("gif_height")

var ffjKeyInlineQueryResultGifGifDuration = []byte("gif_duration")

var ffjKeyInlineQueryResultGifReplyMarkup = []byte("reply_markup")

var ffjKeyInlineQueryResultGifInputMessageContent = []byte("input_message_content")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultGif) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultGif) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultGifbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultGifnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInlineQueryResultGifCaption, kn) {
						currentKey = ffjtInlineQueryResultGifCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyInlineQueryResultGifGifURL, kn) {
						currentKey = ffjtInlineQueryResultGifGifURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultGifGifWidth, kn) {
						currentKey = ffjtInlineQueryResultGifGifWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultGifGifHeight, kn) {
						currentKey = ffjtInlineQueryResultGifGifHeight
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultGifGifDuration, kn) {
						currentKey = ffjtInlineQueryResultGifGifDuration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultGifID, kn) {
						currentKey = ffjtInlineQueryResultGifID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultGifInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultGifInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInlineQueryResultGifParseMode, kn) {
						currentKey = ffjtInlineQueryResultGifParseMode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultGifReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultGifReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultGifType, kn) {
						currentKey = ffjtInlineQueryResultGifType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultGifThumbURL, kn) {
						currentKey = ffjtInlineQueryResultGifThumbURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultGifTitle, kn) {
						currentKey = ffjtInlineQueryResultGifTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultGifInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultGifInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultGifReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultGifReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultGifGifDuration, kn) {
					currentKey = ffjtInlineQueryResultGifGifDuration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultGifGifHeight, kn) {
					currentKey = ffjtInlineQueryResultGifGifHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultGifGifWidth, kn) {
					currentKey = ffjtInlineQueryResultGifGifWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultGifParseMode, kn) {
					currentKey = ffjtInlineQueryResultGifParseMode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultGifCaption, kn) {
					currentKey = ffjtInlineQueryResultGifCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultGifTitle, kn) {
					currentKey = ffjtInlineQueryResultGifTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultGifThumbURL, kn) {
					currentKey = ffjtInlineQueryResultGifThumbURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultGifGifURL, kn) {
					currentKey = ffjtInlineQueryResultGifGifURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultGifID, kn) {
					currentKey = ffjtInlineQueryResultGifID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultGifType, kn) {
					currentKey = ffjtInlineQueryResultGifType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultGifnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultGifType:
					goto handle_Type

				case ffjtInlineQueryResultGifID:
					goto handle_ID

				case ffjtInlineQueryResultGifGifURL:
					goto handle_GifURL

				case ffjtInlineQueryResultGifThumbURL:
					goto handle_ThumbURL

				case ffjtInlineQueryResultGifTitle:
					goto handle_Title

				case ffjtInlineQueryResultGifCaption:
					goto handle_Caption

				case ffjtInlineQueryResultGifParseMode:
					goto handle_ParseMode

				case ffjtInlineQueryResultGifGifWidth:
					goto handle_GifWidth

				case ffjtInlineQueryResultGifGifHeight:
					goto handle_GifHeight

				case ffjtInlineQueryResultGifGifDuration:
					goto handle_GifDuration

				case ffjtInlineQueryResultGifReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultGifInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultGifnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GifURL:

	/* handler: j.GifURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.GifURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbURL:

	/* handler: j.ThumbURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ThumbURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ParseMode:

	/* handler: j.ParseMode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ParseMode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GifWidth:

	/* handler: j.GifWidth type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.GifWidth = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GifHeight:

	/* handler: j.GifHeight type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.GifHeight = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GifDuration:

	/* handler: j.GifDuration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.GifDuration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=telegram.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReplyMarkup = nil

		} else {

			if j.ReplyMarkup == nil {
				j.ReplyMarkup = new(InlineKeyboardMarkup)
			}

			err = j.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultLocation) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultLocation) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteByte(',')
	if len(j.ThumbURL) != 0 {
		buf.WriteString(`"thumb_url":`)
		fflib.WriteJsonString(buf, string(j.ThumbURL))
		buf.WriteByte(',')
	}
	buf.WriteString(`"latitude":`)
	fflib.AppendFloat(buf, float64(j.Latitude), 'g', -1, 32)
	buf.WriteString(`,"longitude":`)
	fflib.AppendFloat(buf, float64(j.Longitude), 'g', -1, 32)
	buf.WriteByte(',')
	if j.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = j.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	if j.ThumbWidth != 0 {
		buf.WriteString(`"thumb_width":`)
		fflib.FormatBits2(buf, uint64(j.ThumbWidth), 10, j.ThumbWidth < 0)
		buf.WriteByte(',')
	}
	if j.ThumbHeight != 0 {
		buf.WriteString(`"thumb_height":`)
		fflib.FormatBits2(buf, uint64(j.ThumbHeight), 10, j.ThumbHeight < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultLocationbase = iota
	ffjtInlineQueryResultLocationnosuchkey

	ffjtInlineQueryResultLocationType

	ffjtInlineQueryResultLocationID

	ffjtInlineQueryResultLocationTitle

	ffjtInlineQueryResultLocationThumbURL

	ffjtInlineQueryResultLocationLatitude

	ffjtInlineQueryResultLocationLongitude

	ffjtInlineQueryResultLocationReplyMarkup

	ffjtInlineQueryResultLocationInputMessageContent

	ffjtInlineQueryResultLocationThumbWidth

	ffjtInlineQueryResultLocationThumbHeight
)

var ffjKeyInlineQueryResultLocationType = []byte("type")

var ffjKeyInlineQueryResultLocationID = []byte("id")

var ffjKeyInlineQueryResultLocationTitle = []byte("title")

var ffjKeyInlineQueryResultLocationThumbURL = []byte("thumb_url")

var ffjKeyInlineQueryResultLocationLatitude = []byte("latitude")

var ffjKeyInlineQueryResultLocationLongitude = []byte("longitude")

var ffjKeyInlineQueryResultLocationReplyMarkup = []byte("reply_markup")

var ffjKeyInlineQueryResultLocationInputMessageContent = []byte("input_message_content")

var ffjKeyInlineQueryResultLocationThumbWidth = []byte("thumb_width")

var ffjKeyInlineQueryResultLocationThumbHeight = []byte("thumb_height")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultLocation) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultLocation) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultLocationbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultLocationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultLocationID, kn) {
						currentKey = ffjtInlineQueryResultLocationID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultLocationInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultLocationInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyInlineQueryResultLocationLatitude, kn) {
						currentKey = ffjtInlineQueryResultLocationLatitude
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultLocationLongitude, kn) {
						currentKey = ffjtInlineQueryResultLocationLongitude
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultLocationReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultLocationReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultLocationType, kn) {
						currentKey = ffjtInlineQueryResultLocationType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultLocationTitle, kn) {
						currentKey = ffjtInlineQueryResultLocationTitle
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultLocationThumbURL, kn) {
						currentKey = ffjtInlineQueryResultLocationThumbURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultLocationThumbWidth, kn) {
						currentKey = ffjtInlineQueryResultLocationThumbWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultLocationThumbHeight, kn) {
						currentKey = ffjtInlineQueryResultLocationThumbHeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultLocationThumbHeight, kn) {
					currentKey = ffjtInlineQueryResultLocationThumbHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultLocationThumbWidth, kn) {
					currentKey = ffjtInlineQueryResultLocationThumbWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultLocationInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultLocationInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultLocationReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultLocationReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultLocationLongitude, kn) {
					currentKey = ffjtInlineQueryResultLocationLongitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultLocationLatitude, kn) {
					currentKey = ffjtInlineQueryResultLocationLatitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultLocationThumbURL, kn) {
					currentKey = ffjtInlineQueryResultLocationThumbURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultLocationTitle, kn) {
					currentKey = ffjtInlineQueryResultLocationTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultLocationID, kn) {
					currentKey = ffjtInlineQueryResultLocationID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultLocationType, kn) {
					currentKey = ffjtInlineQueryResultLocationType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultLocationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultLocationType:
					goto handle_Type

				case ffjtInlineQueryResultLocationID:
					goto handle_ID

				case ffjtInlineQueryResultLocationTitle:
					goto handle_Title

				case ffjtInlineQueryResultLocationThumbURL:
					goto handle_ThumbURL

				case ffjtInlineQueryResultLocationLatitude:
					goto handle_Latitude

				case ffjtInlineQueryResultLocationLongitude:
					goto handle_Longitude

				case ffjtInlineQueryResultLocationReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultLocationInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultLocationThumbWidth:
					goto handle_ThumbWidth

				case ffjtInlineQueryResultLocationThumbHeight:
					goto handle_ThumbHeight

				case ffjtInlineQueryResultLocationnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbURL:

	/* handler: j.ThumbURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ThumbURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Latitude:

	/* handler: j.Latitude type=float32 kind=float32 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Latitude = float32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Longitude:

	/* handler: j.Longitude type=float32 kind=float32 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Longitude = float32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=telegram.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReplyMarkup = nil

		} else {

			if j.ReplyMarkup == nil {
				j.ReplyMarkup = new(InlineKeyboardMarkup)
			}

			err = j.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbWidth:

	/* handler: j.ThumbWidth type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ThumbWidth = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbHeight:

	/* handler: j.ThumbHeight type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ThumbHeight = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultMpeg4Gif) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultMpeg4Gif) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"mpeg4_url":`)
	fflib.WriteJsonString(buf, string(j.Mpeg4URL))
	buf.WriteString(`,"thumb_url":`)
	fflib.WriteJsonString(buf, string(j.ThumbURL))
	buf.WriteByte(',')
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if j.Mpeg4Width != 0 {
		buf.WriteString(`"mpeg4_width":`)
		fflib.FormatBits2(buf, uint64(j.Mpeg4Width), 10, j.Mpeg4Width < 0)
		buf.WriteByte(',')
	}
	if j.Mpeg4Height != 0 {
		buf.WriteString(`"mpeg4_height":`)
		fflib.FormatBits2(buf, uint64(j.Mpeg4Height), 10, j.Mpeg4Height < 0)
		buf.WriteByte(',')
	}
	if j.Mpeg4Duration != 0 {
		buf.WriteString(`"mpeg4_duration":`)
		fflib.FormatBits2(buf, uint64(j.Mpeg4Duration), 10, j.Mpeg4Duration < 0)
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = j.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultMpeg4Gifbase = iota
	ffjtInlineQueryResultMpeg4Gifnosuchkey

	ffjtInlineQueryResultMpeg4GifType

	ffjtInlineQueryResultMpeg4GifID

	ffjtInlineQueryResultMpeg4GifMpeg4URL

	ffjtInlineQueryResultMpeg4GifThumbURL

	ffjtInlineQueryResultMpeg4GifTitle

	ffjtInlineQueryResultMpeg4GifCaption

	ffjtInlineQueryResultMpeg4GifMpeg4Width

	ffjtInlineQueryResultMpeg4GifMpeg4Height

	ffjtInlineQueryResultMpeg4GifMpeg4Duration

	ffjtInlineQueryResultMpeg4GifReplyMarkup

	ffjtInlineQueryResultMpeg4GifInputMessageContent
)

var ffjKeyInlineQueryResultMpeg4GifType = []byte("type")

var ffjKeyInlineQueryResultMpeg4GifID = []byte("id")

var ffjKeyInlineQueryResultMpeg4GifMpeg4URL = []byte("mpeg4_url")

var ffjKeyInlineQueryResultMpeg4GifThumbURL = []byte("thumb_url")

var ffjKeyInlineQueryResultMpeg4GifTitle = []byte("title")

var ffjKeyInlineQueryResultMpeg4GifCaption = []byte("caption")

var ffjKeyInlineQueryResultMpeg4GifMpeg4Width = []byte("mpeg4_width")

var ffjKeyInlineQueryResultMpeg4GifMpeg4Height = []byte("mpeg4_height")

var ffjKeyInlineQueryResultMpeg4GifMpeg4Duration = []byte("mpeg4_duration")

var ffjKeyInlineQueryResultMpeg4GifReplyMarkup = []byte("reply_markup")

var ffjKeyInlineQueryResultMpeg4GifInputMessageContent = []byte("input_message_content")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultMpeg4Gif) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultMpeg4Gif) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultMpeg4Gifbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultMpeg4Gifnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInlineQueryResultMpeg4GifCaption, kn) {
						currentKey = ffjtInlineQueryResultMpeg4GifCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultMpeg4GifID, kn) {
						currentKey = ffjtInlineQueryResultMpeg4GifID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultMpeg4GifInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultMpeg4GifInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyInlineQueryResultMpeg4GifMpeg4URL, kn) {
						currentKey = ffjtInlineQueryResultMpeg4GifMpeg4URL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultMpeg4GifMpeg4Width, kn) {
						currentKey = ffjtInlineQueryResultMpeg4GifMpeg4Width
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultMpeg4GifMpeg4Height, kn) {
						currentKey = ffjtInlineQueryResultMpeg4GifMpeg4Height
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultMpeg4GifMpeg4Duration, kn) {
						currentKey = ffjtInlineQueryResultMpeg4GifMpeg4Duration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultMpeg4GifReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultMpeg4GifReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultMpeg4GifType, kn) {
						currentKey = ffjtInlineQueryResultMpeg4GifType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultMpeg4GifThumbURL, kn) {
						currentKey = ffjtInlineQueryResultMpeg4GifThumbURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultMpeg4GifTitle, kn) {
						currentKey = ffjtInlineQueryResultMpeg4GifTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultMpeg4GifInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultMpeg4GifInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultMpeg4GifReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultMpeg4GifReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultMpeg4GifMpeg4Duration, kn) {
					currentKey = ffjtInlineQueryResultMpeg4GifMpeg4Duration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultMpeg4GifMpeg4Height, kn) {
					currentKey = ffjtInlineQueryResultMpeg4GifMpeg4Height
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultMpeg4GifMpeg4Width, kn) {
					currentKey = ffjtInlineQueryResultMpeg4GifMpeg4Width
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultMpeg4GifCaption, kn) {
					currentKey = ffjtInlineQueryResultMpeg4GifCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultMpeg4GifTitle, kn) {
					currentKey = ffjtInlineQueryResultMpeg4GifTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultMpeg4GifThumbURL, kn) {
					currentKey = ffjtInlineQueryResultMpeg4GifThumbURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultMpeg4GifMpeg4URL, kn) {
					currentKey = ffjtInlineQueryResultMpeg4GifMpeg4URL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultMpeg4GifID, kn) {
					currentKey = ffjtInlineQueryResultMpeg4GifID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultMpeg4GifType, kn) {
					currentKey = ffjtInlineQueryResultMpeg4GifType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultMpeg4Gifnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultMpeg4GifType:
					goto handle_Type

				case ffjtInlineQueryResultMpeg4GifID:
					goto handle_ID

				case ffjtInlineQueryResultMpeg4GifMpeg4URL:
					goto handle_Mpeg4URL

				case ffjtInlineQueryResultMpeg4GifThumbURL:
					goto handle_ThumbURL

				case ffjtInlineQueryResultMpeg4GifTitle:
					goto handle_Title

				case ffjtInlineQueryResultMpeg4GifCaption:
					goto handle_Caption

				case ffjtInlineQueryResultMpeg4GifMpeg4Width:
					goto handle_Mpeg4Width

				case ffjtInlineQueryResultMpeg4GifMpeg4Height:
					goto handle_Mpeg4Height

				case ffjtInlineQueryResultMpeg4GifMpeg4Duration:
					goto handle_Mpeg4Duration

				case ffjtInlineQueryResultMpeg4GifReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultMpeg4GifInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultMpeg4Gifnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mpeg4URL:

	/* handler: j.Mpeg4URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Mpeg4URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbURL:

	/* handler: j.ThumbURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ThumbURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mpeg4Width:

	/* handler: j.Mpeg4Width type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Mpeg4Width = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mpeg4Height:

	/* handler: j.Mpeg4Height type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Mpeg4Height = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mpeg4Duration:

	/* handler: j.Mpeg4Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Mpeg4Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=telegram.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReplyMarkup = nil

		} else {

			if j.ReplyMarkup == nil {
				j.ReplyMarkup = new(InlineKeyboardMarkup)
			}

			err = j.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultPhoto) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultPhoto) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"photo_url":`)
	fflib.WriteJsonString(buf, string(j.PhotoURL))
	buf.WriteString(`,"thumb_url":`)
	fflib.WriteJsonString(buf, string(j.ThumbURL))
	buf.WriteByte(',')
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	if len(j.Description) != 0 {
		buf.WriteString(`"description":`)
		fflib.WriteJsonString(buf, string(j.Description))
		buf.WriteByte(',')
	}
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if len(j.ParseMode) != 0 {
		buf.WriteString(`"parse_mode":`)
		fflib.WriteJsonString(buf, string(j.ParseMode))
		buf.WriteByte(',')
	}
	if j.PhotoWidth != 0 {
		buf.WriteString(`"photo_width":`)
		fflib.FormatBits2(buf, uint64(j.PhotoWidth), 10, j.PhotoWidth < 0)
		buf.WriteByte(',')
	}
	if j.PhotoHeight != 0 {
		buf.WriteString(`"photo_height":`)
		fflib.FormatBits2(buf, uint64(j.PhotoHeight), 10, j.PhotoHeight < 0)
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = j.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultPhotobase = iota
	ffjtInlineQueryResultPhotonosuchkey

	ffjtInlineQueryResultPhotoType

	ffjtInlineQueryResultPhotoID

	ffjtInlineQueryResultPhotoPhotoURL

	ffjtInlineQueryResultPhotoThumbURL

	ffjtInlineQueryResultPhotoTitle

	ffjtInlineQueryResultPhotoDescription

	ffjtInlineQueryResultPhotoCaption

	ffjtInlineQueryResultPhotoParseMode

	ffjtInlineQueryResultPhotoPhotoWidth

	ffjtInlineQueryResultPhotoPhotoHeight

	ffjtInlineQueryResultPhotoReplyMarkup

	ffjtInlineQueryResultPhotoInputMessageContent
)

var ffjKeyInlineQueryResultPhotoType = []byte("type")

var ffjKeyInlineQueryResultPhotoID = []byte("id")

var ffjKeyInlineQueryResultPhotoPhotoURL = []byte("photo_url")

var ffjKeyInlineQueryResultPhotoThumbURL = []byte("thumb_url")

var ffjKeyInlineQueryResultPhotoTitle = []byte("title")

var ffjKeyInlineQueryResultPhotoDescription = []byte("description")

var ffjKeyInlineQueryResultPhotoCaption = []byte("caption")

var ffjKeyInlineQueryResultPhotoParseMode = []byte("parse_mode")

var ffjKeyInlineQueryResultPhotoPhotoWidth = []byte("photo_width")

var ffjKeyInlineQueryResultPhotoPhotoHeight = []byte("photo_height")

var ffjKeyInlineQueryResultPhotoReplyMarkup = []byte("reply_markup")

var ffjKeyInlineQueryResultPhotoInputMessageContent = []byte("input_message_content")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultPhoto) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultPhoto) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultPhotobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultPhotonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInlineQueryResultPhotoCaption, kn) {
						currentKey = ffjtInlineQueryResultPhotoCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyInlineQueryResultPhotoDescription, kn) {
						currentKey = ffjtInlineQueryResultPhotoDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultPhotoID, kn) {
						currentKey = ffjtInlineQueryResultPhotoID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultPhotoInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultPhotoInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInlineQueryResultPhotoPhotoURL, kn) {
						currentKey = ffjtInlineQueryResultPhotoPhotoURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultPhotoParseMode, kn) {
						currentKey = ffjtInlineQueryResultPhotoParseMode
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultPhotoPhotoWidth, kn) {
						currentKey = ffjtInlineQueryResultPhotoPhotoWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultPhotoPhotoHeight, kn) {
						currentKey = ffjtInlineQueryResultPhotoPhotoHeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultPhotoReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultPhotoReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultPhotoType, kn) {
						currentKey = ffjtInlineQueryResultPhotoType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultPhotoThumbURL, kn) {
						currentKey = ffjtInlineQueryResultPhotoThumbURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultPhotoTitle, kn) {
						currentKey = ffjtInlineQueryResultPhotoTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultPhotoInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultPhotoInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultPhotoReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultPhotoReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultPhotoPhotoHeight, kn) {
					currentKey = ffjtInlineQueryResultPhotoPhotoHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultPhotoPhotoWidth, kn) {
					currentKey = ffjtInlineQueryResultPhotoPhotoWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultPhotoParseMode, kn) {
					currentKey = ffjtInlineQueryResultPhotoParseMode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultPhotoCaption, kn) {
					currentKey = ffjtInlineQueryResultPhotoCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultPhotoDescription, kn) {
					currentKey = ffjtInlineQueryResultPhotoDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultPhotoTitle, kn) {
					currentKey = ffjtInlineQueryResultPhotoTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultPhotoThumbURL, kn) {
					currentKey = ffjtInlineQueryResultPhotoThumbURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultPhotoPhotoURL, kn) {
					currentKey = ffjtInlineQueryResultPhotoPhotoURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultPhotoID, kn) {
					currentKey = ffjtInlineQueryResultPhotoID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultPhotoType, kn) {
					currentKey = ffjtInlineQueryResultPhotoType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultPhotonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultPhotoType:
					goto handle_Type

				case ffjtInlineQueryResultPhotoID:
					goto handle_ID

				case ffjtInlineQueryResultPhotoPhotoURL:
					goto handle_PhotoURL

				case ffjtInlineQueryResultPhotoThumbURL:
					goto handle_ThumbURL

				case ffjtInlineQueryResultPhotoTitle:
					goto handle_Title

				case ffjtInlineQueryResultPhotoDescription:
					goto handle_Description

				case ffjtInlineQueryResultPhotoCaption:
					goto handle_Caption

				case ffjtInlineQueryResultPhotoParseMode:
					goto handle_ParseMode

				case ffjtInlineQueryResultPhotoPhotoWidth:
					goto handle_PhotoWidth

				case ffjtInlineQueryResultPhotoPhotoHeight:
					goto handle_PhotoHeight

				case ffjtInlineQueryResultPhotoReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultPhotoInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultPhotonosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PhotoURL:

	/* handler: j.PhotoURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PhotoURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbURL:

	/* handler: j.ThumbURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ThumbURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ParseMode:

	/* handler: j.ParseMode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ParseMode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PhotoWidth:

	/* handler: j.PhotoWidth type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PhotoWidth = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PhotoHeight:

	/* handler: j.PhotoHeight type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PhotoHeight = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=telegram.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReplyMarkup = nil

		} else {

			if j.ReplyMarkup == nil {
				j.ReplyMarkup = new(InlineKeyboardMarkup)
			}

			err = j.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultVenue) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultVenue) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteString(`,"address":`)
	fflib.WriteJsonString(buf, string(j.Address))
	buf.WriteByte(',')
	if len(j.FoursquareID) != 0 {
		buf.WriteString(`"foursquare_id":`)
		fflib.WriteJsonString(buf, string(j.FoursquareID))
		buf.WriteByte(',')
	}
	if len(j.FoursquareType) != 0 {
		buf.WriteString(`"foursquare_type":`)
		fflib.WriteJsonString(buf, string(j.FoursquareType))
		buf.WriteByte(',')
	}
	if len(j.ThumbURL) != 0 {
		buf.WriteString(`"thumb_url":`)
		fflib.WriteJsonString(buf, string(j.ThumbURL))
		buf.WriteByte(',')
	}
	buf.WriteString(`"latitude":`)
	fflib.AppendFloat(buf, float64(j.Latitude), 'g', -1, 32)
	buf.WriteString(`,"longitude":`)
	fflib.AppendFloat(buf, float64(j.Longitude), 'g', -1, 32)
	buf.WriteByte(',')
	if j.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = j.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	if j.ThumbWidth != 0 {
		buf.WriteString(`"thumb_width":`)
		fflib.FormatBits2(buf, uint64(j.ThumbWidth), 10, j.ThumbWidth < 0)
		buf.WriteByte(',')
	}
	if j.ThumbHeight != 0 {
		buf.WriteString(`"thumb_height":`)
		fflib.FormatBits2(buf, uint64(j.ThumbHeight), 10, j.ThumbHeight < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultVenuebase = iota
	ffjtInlineQueryResultVenuenosuchkey

	ffjtInlineQueryResultVenueType

	ffjtInlineQueryResultVenueID

	ffjtInlineQueryResultVenueTitle

	ffjtInlineQueryResultVenueAddress

	ffjtInlineQueryResultVenueFoursquareID

	ffjtInlineQueryResultVenueFoursquareType

	ffjtInlineQueryResultVenueThumbURL

	ffjtInlineQueryResultVenueLatitude

	ffjtInlineQueryResultVenueLongitude

	ffjtInlineQueryResultVenueReplyMarkup

	ffjtInlineQueryResultVenueInputMessageContent

	ffjtInlineQueryResultVenueThumbWidth

	ffjtInlineQueryResultVenueThumbHeight
)

var ffjKeyInlineQueryResultVenueType = []byte("type")

var ffjKeyInlineQueryResultVenueID = []byte("id")

var ffjKeyInlineQueryResultVenueTitle = []byte("title")

var ffjKeyInlineQueryResultVenueAddress = []byte("address")

var ffjKeyInlineQueryResultVenueFoursquareID = []byte("foursquare_id")

var ffjKeyInlineQueryResultVenueFoursquareType = []byte("foursquare_type")

var ffjKeyInlineQueryResultVenueThumbURL = []byte("thumb_url")

var ffjKeyInlineQueryResultVenueLatitude = []byte("latitude")

var ffjKeyInlineQueryResultVenueLongitude = []byte("longitude")

var ffjKeyInlineQueryResultVenueReplyMarkup = []byte("reply_markup")

var ffjKeyInlineQueryResultVenueInputMessageContent = []byte("input_message_content")

var ffjKeyInlineQueryResultVenueThumbWidth = []byte("thumb_width")

var ffjKeyInlineQueryResultVenueThumbHeight = []byte("thumb_height")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultVenue) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultVenue) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultVenuebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultVenuenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyInlineQueryResultVenueAddress, kn) {
						currentKey = ffjtInlineQueryResultVenueAddress
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyInlineQueryResultVenueFoursquareID, kn) {
						currentKey = ffjtInlineQueryResultVenueFoursquareID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVenueFoursquareType, kn) {
						currentKey = ffjtInlineQueryResultVenueFoursquareType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultVenueID, kn) {
						currentKey = ffjtInlineQueryResultVenueID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVenueInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultVenueInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyInlineQueryResultVenueLatitude, kn) {
						currentKey = ffjtInlineQueryResultVenueLatitude
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVenueLongitude, kn) {
						currentKey = ffjtInlineQueryResultVenueLongitude
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultVenueReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultVenueReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultVenueType, kn) {
						currentKey = ffjtInlineQueryResultVenueType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVenueTitle, kn) {
						currentKey = ffjtInlineQueryResultVenueTitle
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVenueThumbURL, kn) {
						currentKey = ffjtInlineQueryResultVenueThumbURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVenueThumbWidth, kn) {
						currentKey = ffjtInlineQueryResultVenueThumbWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVenueThumbHeight, kn) {
						currentKey = ffjtInlineQueryResultVenueThumbHeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultVenueThumbHeight, kn) {
					currentKey = ffjtInlineQueryResultVenueThumbHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultVenueThumbWidth, kn) {
					currentKey = ffjtInlineQueryResultVenueThumbWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultVenueInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultVenueInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultVenueReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultVenueReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultVenueLongitude, kn) {
					currentKey = ffjtInlineQueryResultVenueLongitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultVenueLatitude, kn) {
					currentKey = ffjtInlineQueryResultVenueLatitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultVenueThumbURL, kn) {
					currentKey = ffjtInlineQueryResultVenueThumbURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultVenueFoursquareType, kn) {
					currentKey = ffjtInlineQueryResultVenueFoursquareType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultVenueFoursquareID, kn) {
					currentKey = ffjtInlineQueryResultVenueFoursquareID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultVenueAddress, kn) {
					currentKey = ffjtInlineQueryResultVenueAddress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultVenueTitle, kn) {
					currentKey = ffjtInlineQueryResultVenueTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultVenueID, kn) {
					currentKey = ffjtInlineQueryResultVenueID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultVenueType, kn) {
					currentKey = ffjtInlineQueryResultVenueType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultVenuenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultVenueType:
					goto handle_Type

				case ffjtInlineQueryResultVenueID:
					goto handle_ID

				case ffjtInlineQueryResultVenueTitle:
					goto handle_Title

				case ffjtInlineQueryResultVenueAddress:
					goto handle_Address

				case ffjtInlineQueryResultVenueFoursquareID:
					goto handle_FoursquareID

				case ffjtInlineQueryResultVenueFoursquareType:
					goto handle_FoursquareType

				case ffjtInlineQueryResultVenueThumbURL:
					goto handle_ThumbURL

				case ffjtInlineQueryResultVenueLatitude:
					goto handle_Latitude

				case ffjtInlineQueryResultVenueLongitude:
					goto handle_Longitude

				case ffjtInlineQueryResultVenueReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultVenueInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultVenueThumbWidth:
					goto handle_ThumbWidth

				case ffjtInlineQueryResultVenueThumbHeight:
					goto handle_ThumbHeight

				case ffjtInlineQueryResultVenuenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Address:

	/* handler: j.Address type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Address = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FoursquareID:

	/* handler: j.FoursquareID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FoursquareID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FoursquareType:

	/* handler: j.FoursquareType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FoursquareType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbURL:

	/* handler: j.ThumbURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ThumbURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Latitude:

	/* handler: j.Latitude type=float32 kind=float32 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Latitude = float32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Longitude:

	/* handler: j.Longitude type=float32 kind=float32 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Longitude = float32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=telegram.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReplyMarkup = nil

		} else {

			if j.ReplyMarkup == nil {
				j.ReplyMarkup = new(InlineKeyboardMarkup)
			}

			err = j.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbWidth:

	/* handler: j.ThumbWidth type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ThumbWidth = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbHeight:

	/* handler: j.ThumbHeight type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ThumbHeight = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultVideo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultVideo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"video_url":`)
	fflib.WriteJsonString(buf, string(j.VideoURL))
	buf.WriteString(`,"mime_type":`)
	fflib.WriteJsonString(buf, string(j.MimeType))
	buf.WriteString(`,"thumb_url":`)
	fflib.WriteJsonString(buf, string(j.ThumbURL))
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteByte(',')
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if len(j.ParseMode) != 0 {
		buf.WriteString(`"parse_mode":`)
		fflib.WriteJsonString(buf, string(j.ParseMode))
		buf.WriteByte(',')
	}
	if len(j.Description) != 0 {
		buf.WriteString(`"description":`)
		fflib.WriteJsonString(buf, string(j.Description))
		buf.WriteByte(',')
	}
	if j.VideoWidth != 0 {
		buf.WriteString(`"video_width":`)
		fflib.FormatBits2(buf, uint64(j.VideoWidth), 10, j.VideoWidth < 0)
		buf.WriteByte(',')
	}
	if j.VideoHeight != 0 {
		buf.WriteString(`"video_height":`)
		fflib.FormatBits2(buf, uint64(j.VideoHeight), 10, j.VideoHeight < 0)
		buf.WriteByte(',')
	}
	if j.VideoDuration != 0 {
		buf.WriteString(`"video_duration":`)
		fflib.FormatBits2(buf, uint64(j.VideoDuration), 10, j.VideoDuration < 0)
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = j.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultVideobase = iota
	ffjtInlineQueryResultVideonosuchkey

	ffjtInlineQueryResultVideoType

	ffjtInlineQueryResultVideoID

	ffjtInlineQueryResultVideoVideoURL

	ffjtInlineQueryResultVideoMimeType

	ffjtInlineQueryResultVideoThumbURL

	ffjtInlineQueryResultVideoTitle

	ffjtInlineQueryResultVideoCaption

	ffjtInlineQueryResultVideoParseMode

	ffjtInlineQueryResultVideoDescription

	ffjtInlineQueryResultVideoVideoWidth

	ffjtInlineQueryResultVideoVideoHeight

	ffjtInlineQueryResultVideoVideoDuration

	ffjtInlineQueryResultVideoReplyMarkup

	ffjtInlineQueryResultVideoInputMessageContent
)

var ffjKeyInlineQueryResultVideoType = []byte("type")

var ffjKeyInlineQueryResultVideoID = []byte("id")

var ffjKeyInlineQueryResultVideoVideoURL = []byte("video_url")

var ffjKeyInlineQueryResultVideoMimeType = []byte("mime_type")

var ffjKeyInlineQueryResultVideoThumbURL = []byte("thumb_url")

var ffjKeyInlineQueryResultVideoTitle = []byte("title")

var ffjKeyInlineQueryResultVideoCaption = []byte("caption")

var ffjKeyInlineQueryResultVideoParseMode = []byte("parse_mode")

var ffjKeyInlineQueryResultVideoDescription = []byte("description")

var ffjKeyInlineQueryResultVideoVideoWidth = []byte("video_width")

var ffjKeyInlineQueryResultVideoVideoHeight = []byte("video_height")

var ffjKeyInlineQueryResultVideoVideoDuration = []byte("video_duration")

var ffjKeyInlineQueryResultVideoReplyMarkup = []byte("reply_markup")

var ffjKeyInlineQueryResultVideoInputMessageContent = []byte("input_message_content")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultVideo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultVideo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultVideobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultVideonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInlineQueryResultVideoCaption, kn) {
						currentKey = ffjtInlineQueryResultVideoCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyInlineQueryResultVideoDescription, kn) {
						currentKey = ffjtInlineQueryResultVideoDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultVideoID, kn) {
						currentKey = ffjtInlineQueryResultVideoID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVideoInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultVideoInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyInlineQueryResultVideoMimeType, kn) {
						currentKey = ffjtInlineQueryResultVideoMimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInlineQueryResultVideoParseMode, kn) {
						currentKey = ffjtInlineQueryResultVideoParseMode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultVideoReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultVideoReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultVideoType, kn) {
						currentKey = ffjtInlineQueryResultVideoType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVideoThumbURL, kn) {
						currentKey = ffjtInlineQueryResultVideoThumbURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVideoTitle, kn) {
						currentKey = ffjtInlineQueryResultVideoTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyInlineQueryResultVideoVideoURL, kn) {
						currentKey = ffjtInlineQueryResultVideoVideoURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVideoVideoWidth, kn) {
						currentKey = ffjtInlineQueryResultVideoVideoWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVideoVideoHeight, kn) {
						currentKey = ffjtInlineQueryResultVideoVideoHeight
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVideoVideoDuration, kn) {
						currentKey = ffjtInlineQueryResultVideoVideoDuration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultVideoInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultVideoInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultVideoReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultVideoReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultVideoVideoDuration, kn) {
					currentKey = ffjtInlineQueryResultVideoVideoDuration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultVideoVideoHeight, kn) {
					currentKey = ffjtInlineQueryResultVideoVideoHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultVideoVideoWidth, kn) {
					currentKey = ffjtInlineQueryResultVideoVideoWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultVideoDescription, kn) {
					currentKey = ffjtInlineQueryResultVideoDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultVideoParseMode, kn) {
					currentKey = ffjtInlineQueryResultVideoParseMode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultVideoCaption, kn) {
					currentKey = ffjtInlineQueryResultVideoCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultVideoTitle, kn) {
					currentKey = ffjtInlineQueryResultVideoTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultVideoThumbURL, kn) {
					currentKey = ffjtInlineQueryResultVideoThumbURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultVideoMimeType, kn) {
					currentKey = ffjtInlineQueryResultVideoMimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultVideoVideoURL, kn) {
					currentKey = ffjtInlineQueryResultVideoVideoURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultVideoID, kn) {
					currentKey = ffjtInlineQueryResultVideoID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultVideoType, kn) {
					currentKey = ffjtInlineQueryResultVideoType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultVideonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultVideoType:
					goto handle_Type

				case ffjtInlineQueryResultVideoID:
					goto handle_ID

				case ffjtInlineQueryResultVideoVideoURL:
					goto handle_VideoURL

				case ffjtInlineQueryResultVideoMimeType:
					goto handle_MimeType

				case ffjtInlineQueryResultVideoThumbURL:
					goto handle_ThumbURL

				case ffjtInlineQueryResultVideoTitle:
					goto handle_Title

				case ffjtInlineQueryResultVideoCaption:
					goto handle_Caption

				case ffjtInlineQueryResultVideoParseMode:
					goto handle_ParseMode

				case ffjtInlineQueryResultVideoDescription:
					goto handle_Description

				case ffjtInlineQueryResultVideoVideoWidth:
					goto handle_VideoWidth

				case ffjtInlineQueryResultVideoVideoHeight:
					goto handle_VideoHeight

				case ffjtInlineQueryResultVideoVideoDuration:
					goto handle_VideoDuration

				case ffjtInlineQueryResultVideoReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultVideoInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultVideonosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VideoURL:

	/* handler: j.VideoURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.VideoURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeType:

	/* handler: j.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbURL:

	/* handler: j.ThumbURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ThumbURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ParseMode:

	/* handler: j.ParseMode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ParseMode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VideoWidth:

	/* handler: j.VideoWidth type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.VideoWidth = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VideoHeight:

	/* handler: j.VideoHeight type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.VideoHeight = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VideoDuration:

	/* handler: j.VideoDuration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.VideoDuration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=telegram.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReplyMarkup = nil

		} else {

			if j.ReplyMarkup == nil {
				j.ReplyMarkup = new(InlineKeyboardMarkup)
			}

			err = j.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultVoice) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultVoice) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"voice_url":`)
	fflib.WriteJsonString(buf, string(j.VoiceURL))
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteByte(',')
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if len(j.ParseMode) != 0 {
		buf.WriteString(`"parse_mode":`)
		fflib.WriteJsonString(buf, string(j.ParseMode))
		buf.WriteByte(',')
	}
	if j.VoiceDuration != 0 {
		buf.WriteString(`"voice_duration":`)
		fflib.FormatBits2(buf, uint64(j.VoiceDuration), 10, j.VoiceDuration < 0)
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = j.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultVoicebase = iota
	ffjtInlineQueryResultVoicenosuchkey

	ffjtInlineQueryResultVoiceType

	ffjtInlineQueryResultVoiceID

	ffjtInlineQueryResultVoiceVoiceURL

	ffjtInlineQueryResultVoiceTitle

	ffjtInlineQueryResultVoiceCaption

	ffjtInlineQueryResultVoiceParseMode

	ffjtInlineQueryResultVoiceVoiceDuration

	ffjtInlineQueryResultVoiceReplyMarkup

	ffjtInlineQueryResultVoiceInputMessageContent
)

var ffjKeyInlineQueryResultVoiceType = []byte("type")

var ffjKeyInlineQueryResultVoiceID = []byte("id")

var ffjKeyInlineQueryResultVoiceVoiceURL = []byte("voice_url")

var ffjKeyInlineQueryResultVoiceTitle = []byte("title")

var ffjKeyInlineQueryResultVoiceCaption = []byte("caption")

var ffjKeyInlineQueryResultVoiceParseMode = []byte("parse_mode")

var ffjKeyInlineQueryResultVoiceVoiceDuration = []byte("voice_duration")

var ffjKeyInlineQueryResultVoiceReplyMarkup = []byte("reply_markup")

var ffjKeyInlineQueryResultVoiceInputMessageContent = []byte("input_message_content")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultVoice) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultVoice) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultVoicebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultVoicenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInlineQueryResultVoiceCaption, kn) {
						currentKey = ffjtInlineQueryResultVoiceCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultVoiceID, kn) {
						currentKey = ffjtInlineQueryResultVoiceID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVoiceInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultVoiceInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInlineQueryResultVoiceParseMode, kn) {
						currentKey = ffjtInlineQueryResultVoiceParseMode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultVoiceReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultVoiceReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultVoiceType, kn) {
						currentKey = ffjtInlineQueryResultVoiceType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVoiceTitle, kn) {
						currentKey = ffjtInlineQueryResultVoiceTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyInlineQueryResultVoiceVoiceURL, kn) {
						currentKey = ffjtInlineQueryResultVoiceVoiceURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVoiceVoiceDuration, kn) {
						currentKey = ffjtInlineQueryResultVoiceVoiceDuration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultVoiceInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultVoiceInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultVoiceReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultVoiceReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultVoiceVoiceDuration, kn) {
					currentKey = ffjtInlineQueryResultVoiceVoiceDuration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultVoiceParseMode, kn) {
					currentKey = ffjtInlineQueryResultVoiceParseMode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultVoiceCaption, kn) {
					currentKey = ffjtInlineQueryResultVoiceCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultVoiceTitle, kn) {
					currentKey = ffjtInlineQueryResultVoiceTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultVoiceVoiceURL, kn) {
					currentKey = ffjtInlineQueryResultVoiceVoiceURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultVoiceID, kn) {
					currentKey = ffjtInlineQueryResultVoiceID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultVoiceType, kn) {
					currentKey = ffjtInlineQueryResultVoiceType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultVoicenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultVoiceType:
					goto handle_Type

				case ffjtInlineQueryResultVoiceID:
					goto handle_ID

				case ffjtInlineQueryResultVoiceVoiceURL:
					goto handle_VoiceURL

				case ffjtInlineQueryResultVoiceTitle:
					goto handle_Title

				case ffjtInlineQueryResultVoiceCaption:
					goto handle_Caption

				case ffjtInlineQueryResultVoiceParseMode:
					goto handle_ParseMode

				case ffjtInlineQueryResultVoiceVoiceDuration:
					goto handle_VoiceDuration

				case ffjtInlineQueryResultVoiceReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultVoiceInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultVoicenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VoiceURL:

	/* handler: j.VoiceURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.VoiceURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ParseMode:

	/* handler: j.ParseMode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ParseMode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VoiceDuration:

	/* handler: j.VoiceDuration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.VoiceDuration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=telegram.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReplyMarkup = nil

		} else {

			if j.ReplyMarkup == nil {
				j.ReplyMarkup = new(InlineKeyboardMarkup)
			}

			err = j.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InputContactMessageContent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InputContactMessageContent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "phone_number":`)
	fflib.WriteJsonString(buf, string(j.PhoneNumber))
	buf.WriteString(`,"first_name":`)
	fflib.WriteJsonString(buf, string(j.FirstName))
	buf.WriteByte(',')
	if len(j.LastName) != 0 {
		buf.WriteString(`"last_name":`)
		fflib.WriteJsonString(buf, string(j.LastName))
		buf.WriteByte(',')
	}
	if len(j.VCard) != 0 {
		buf.WriteString(`"vcard":`)
		fflib.WriteJsonString(buf, string(j.VCard))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInputContactMessageContentbase = iota
	ffjtInputContactMessageContentnosuchkey

	ffjtInputContactMessageContentPhoneNumber

	ffjtInputContactMessageContentFirstName

	ffjtInputContactMessageContentLastName

	ffjtInputContactMessageContentVCard
)

var ffjKeyInputContactMessageContentPhoneNumber = []byte("phone_number")

var ffjKeyInputContactMessageContentFirstName = []byte("first_name")

var ffjKeyInputContactMessageContentLastName = []byte("last_name")

var ffjKeyInputContactMessageContentVCard = []byte("vcard")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InputContactMessageContent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InputContactMessageContent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInputContactMessageContentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInputContactMessageContentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyInputContactMessageContentFirstName, kn) {
						currentKey = ffjtInputContactMessageContentFirstName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyInputContactMessageContentLastName, kn) {
						currentKey = ffjtInputContactMessageContentLastName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInputContactMessageContentPhoneNumber, kn) {
						currentKey = ffjtInputContactMessageContentPhoneNumber
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyInputContactMessageContentVCard, kn) {
						currentKey = ffjtInputContactMessageContentVCard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputContactMessageContentVCard, kn) {
					currentKey = ffjtInputContactMessageContentVCard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInputContactMessageContentLastName, kn) {
					currentKey = ffjtInputContactMessageContentLastName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInputContactMessageContentFirstName, kn) {
					currentKey = ffjtInputContactMessageContentFirstName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInputContactMessageContentPhoneNumber, kn) {
					currentKey = ffjtInputContactMessageContentPhoneNumber
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInputContactMessageContentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInputContactMessageContentPhoneNumber:
					goto handle_PhoneNumber

				case ffjtInputContactMessageContentFirstName:
					goto handle_FirstName

				case ffjtInputContactMessageContentLastName:
					goto handle_LastName

				case ffjtInputContactMessageContentVCard:
					goto handle_VCard

				case ffjtInputContactMessageContentnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_PhoneNumber:

	/* handler: j.PhoneNumber type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PhoneNumber = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FirstName:

	/* handler: j.FirstName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FirstName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastName:

	/* handler: j.LastName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LastName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VCard:

	/* handler: j.VCard type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.VCard = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InputLocationMessageContent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InputLocationMessageContent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"latitude":`)
	fflib.AppendFloat(buf, float64(j.Latitude), 'g', -1, 32)
	buf.WriteString(`,"longitude":`)
	fflib.AppendFloat(buf, float64(j.Longitude), 'g', -1, 32)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInputLocationMessageContentbase = iota
	ffjtInputLocationMessageContentnosuchkey

	ffjtInputLocationMessageContentLatitude

	ffjtInputLocationMessageContentLongitude
)

var ffjKeyInputLocationMessageContentLatitude = []byte("latitude")

var ffjKeyInputLocationMessageContentLongitude = []byte("longitude")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InputLocationMessageContent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InputLocationMessageContent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInputLocationMessageContentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInputLocationMessageContentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffjKeyInputLocationMessageContentLatitude, kn) {
						currentKey = ffjtInputLocationMessageContentLatitude
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInputLocationMessageContentLongitude, kn) {
						currentKey = ffjtInputLocationMessageContentLongitude
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputLocationMessageContentLongitude, kn) {
					currentKey = ffjtInputLocationMessageContentLongitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputLocationMessageContentLatitude, kn) {
					currentKey = ffjtInputLocationMessageContentLatitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInputLocationMessageContentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInputLocationMessageContentLatitude:
					goto handle_Latitude

				case ffjtInputLocationMessageContentLongitude:
					goto handle_Longitude

				case ffjtInputLocationMessageContentnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Latitude:

	/* handler: j.Latitude type=float32 kind=float32 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Latitude = float32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Longitude:

	/* handler: j.Longitude type=float32 kind=float32 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Longitude = float32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InputMediaAnimation) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InputMediaAnimation) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"media":`)
	fflib.WriteJsonString(buf, string(j.Media))
	buf.WriteByte(',')
	if j.Thumb != nil {
		buf.WriteString(`"thumb":`)
		/* Interface types must use runtime reflection. type=telegram.InputFile kind=interface */
		err = buf.Encode(j.Thumb)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if len(j.ParseMode) != 0 {
		buf.WriteString(`"parse_mode":`)
		fflib.WriteJsonString(buf, string(j.ParseMode))
		buf.WriteByte(',')
	}
	if j.Width != 0 {
		buf.WriteString(`"width":`)
		fflib.FormatBits2(buf, uint64(j.Width), 10, j.Width < 0)
		buf.WriteByte(',')
	}
	if j.Height != 0 {
		buf.WriteString(`"height":`)
		fflib.FormatBits2(buf, uint64(j.Height), 10, j.Height < 0)
		buf.WriteByte(',')
	}
	if j.Duration != 0 {
		buf.WriteString(`"duration":`)
		fflib.FormatBits2(buf, uint64(j.Duration), 10, j.Duration < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInputMediaAnimationbase = iota
	ffjtInputMediaAnimationnosuchkey

	ffjtInputMediaAnimationType

	ffjtInputMediaAnimationMedia

	ffjtInputMediaAnimationThumb

	ffjtInputMediaAnimationCaption

	ffjtInputMediaAnimationParseMode

	ffjtInputMediaAnimationWidth

	ffjtInputMediaAnimationHeight

	ffjtInputMediaAnimationDuration
)

var ffjKeyInputMediaAnimationType = []byte("type")

var ffjKeyInputMediaAnimationMedia = []byte("media")

var ffjKeyInputMediaAnimationThumb = []byte("thumb")

var ffjKeyInputMediaAnimationCaption = []byte("caption")

var ffjKeyInputMediaAnimationParseMode = []byte("parse_mode")

var ffjKeyInputMediaAnimationWidth = []byte("width")

var ffjKeyInputMediaAnimationHeight = []byte("height")

var ffjKeyInputMediaAnimationDuration = []byte("duration")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InputMediaAnimation) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InputMediaAnimation) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInputMediaAnimationbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInputMediaAnimationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInputMediaAnimationCaption, kn) {
						currentKey = ffjtInputMediaAnimationCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyInputMediaAnimationDuration, kn) {
						currentKey = ffjtInputMediaAnimationDuration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyInputMediaAnimationHeight, kn) {
						currentKey = ffjtInputMediaAnimationHeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyInputMediaAnimationMedia, kn) {
						currentKey = ffjtInputMediaAnimationMedia
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInputMediaAnimationParseMode, kn) {
						currentKey = ffjtInputMediaAnimationParseMode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInputMediaAnimationType, kn) {
						currentKey = ffjtInputMediaAnimationType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInputMediaAnimationThumb, kn) {
						currentKey = ffjtInputMediaAnimationThumb
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyInputMediaAnimationWidth, kn) {
						currentKey = ffjtInputMediaAnimationWidth
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaAnimationDuration, kn) {
					currentKey = ffjtInputMediaAnimationDuration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaAnimationHeight, kn) {
					currentKey = ffjtInputMediaAnimationHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaAnimationWidth, kn) {
					currentKey = ffjtInputMediaAnimationWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInputMediaAnimationParseMode, kn) {
					currentKey = ffjtInputMediaAnimationParseMode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaAnimationCaption, kn) {
					currentKey = ffjtInputMediaAnimationCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaAnimationThumb, kn) {
					currentKey = ffjtInputMediaAnimationThumb
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaAnimationMedia, kn) {
					currentKey = ffjtInputMediaAnimationMedia
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaAnimationType, kn) {
					currentKey = ffjtInputMediaAnimationType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInputMediaAnimationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInputMediaAnimationType:
					goto handle_Type

				case ffjtInputMediaAnimationMedia:
					goto handle_Media

				case ffjtInputMediaAnimationThumb:
					goto handle_Thumb

				case ffjtInputMediaAnimationCaption:
					goto handle_Caption

				case ffjtInputMediaAnimationParseMode:
					goto handle_ParseMode

				case ffjtInputMediaAnimationWidth:
					goto handle_Width

				case ffjtInputMediaAnimationHeight:
					goto handle_Height

				case ffjtInputMediaAnimationDuration:
					goto handle_Duration

				case ffjtInputMediaAnimationnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Media:

	/* handler: j.Media type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Media = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Thumb:

	/* handler: j.Thumb type=telegram.InputFile kind=interface quoted=false*/

	{
		/* Falling back. type=telegram.InputFile kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Thumb)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ParseMode:

	/* handler: j.ParseMode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ParseMode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Width:

	/* handler: j.Width type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Width = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Height:

	/* handler: j.Height type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Height = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: j.Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InputMediaAudio) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InputMediaAudio) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"media":`)
	fflib.WriteJsonString(buf, string(j.Media))
	buf.WriteByte(',')
	if j.Thumb != nil {
		buf.WriteString(`"thumb":`)
		/* Interface types must use runtime reflection. type=telegram.InputFile kind=interface */
		err = buf.Encode(j.Thumb)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if len(j.ParseMode) != 0 {
		buf.WriteString(`"parse_mode":`)
		fflib.WriteJsonString(buf, string(j.ParseMode))
		buf.WriteByte(',')
	}
	if j.Duration != 0 {
		buf.WriteString(`"duration":`)
		fflib.FormatBits2(buf, uint64(j.Duration), 10, j.Duration < 0)
		buf.WriteByte(',')
	}
	if len(j.Performer) != 0 {
		buf.WriteString(`"performer":`)
		fflib.WriteJsonString(buf, string(j.Performer))
		buf.WriteByte(',')
	}
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInputMediaAudiobase = iota
	ffjtInputMediaAudionosuchkey

	ffjtInputMediaAudioType

	ffjtInputMediaAudioMedia

	ffjtInputMediaAudioThumb

	ffjtInputMediaAudioCaption

	ffjtInputMediaAudioParseMode

	ffjtInputMediaAudioDuration

	ffjtInputMediaAudioPerformer

	ffjtInputMediaAudioTitle
)

var ffjKeyInputMediaAudioType = []byte("type")

var ffjKeyInputMediaAudioMedia = []byte("media")

var ffjKeyInputMediaAudioThumb = []byte("thumb")

var ffjKeyInputMediaAudioCaption = []byte("caption")

var ffjKeyInputMediaAudioParseMode = []byte("parse_mode")

var ffjKeyInputMediaAudioDuration = []byte("duration")

var ffjKeyInputMediaAudioPerformer = []byte("performer")

var ffjKeyInputMediaAudioTitle = []byte("title")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InputMediaAudio) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InputMediaAudio) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInputMediaAudiobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInputMediaAudionosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInputMediaAudioCaption, kn) {
						currentKey = ffjtInputMediaAudioCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyInputMediaAudioDuration, kn) {
						currentKey = ffjtInputMediaAudioDuration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyInputMediaAudioMedia, kn) {
						currentKey = ffjtInputMediaAudioMedia
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInputMediaAudioParseMode, kn) {
						currentKey = ffjtInputMediaAudioParseMode
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInputMediaAudioPerformer, kn) {
						currentKey = ffjtInputMediaAudioPerformer
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInputMediaAudioType, kn) {
						currentKey = ffjtInputMediaAudioType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInputMediaAudioThumb, kn) {
						currentKey = ffjtInputMediaAudioThumb
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInputMediaAudioTitle, kn) {
						currentKey = ffjtInputMediaAudioTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaAudioTitle, kn) {
					currentKey = ffjtInputMediaAudioTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaAudioPerformer, kn) {
					currentKey = ffjtInputMediaAudioPerformer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaAudioDuration, kn) {
					currentKey = ffjtInputMediaAudioDuration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInputMediaAudioParseMode, kn) {
					currentKey = ffjtInputMediaAudioParseMode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaAudioCaption, kn) {
					currentKey = ffjtInputMediaAudioCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaAudioThumb, kn) {
					currentKey = ffjtInputMediaAudioThumb
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaAudioMedia, kn) {
					currentKey = ffjtInputMediaAudioMedia
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaAudioType, kn) {
					currentKey = ffjtInputMediaAudioType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInputMediaAudionosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInputMediaAudioType:
					goto handle_Type

				case ffjtInputMediaAudioMedia:
					goto handle_Media

				case ffjtInputMediaAudioThumb:
					goto handle_Thumb

				case ffjtInputMediaAudioCaption:
					goto handle_Caption

				case ffjtInputMediaAudioParseMode:
					goto handle_ParseMode

				case ffjtInputMediaAudioDuration:
					goto handle_Duration

				case ffjtInputMediaAudioPerformer:
					goto handle_Performer

				case ffjtInputMediaAudioTitle:
					goto handle_Title

				case ffjtInputMediaAudionosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Media:

	/* handler: j.Media type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Media = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Thumb:

	/* handler: j.Thumb type=telegram.InputFile kind=interface quoted=false*/

	{
		/* Falling back. type=telegram.InputFile kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Thumb)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ParseMode:

	/* handler: j.ParseMode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ParseMode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: j.Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Performer:

	/* handler: j.Performer type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Performer = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InputMediaDocument) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InputMediaDocument) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"media":`)
	fflib.WriteJsonString(buf, string(j.Media))
	buf.WriteByte(',')
	if j.Thumb != nil {
		buf.WriteString(`"thumb":`)
		/* Interface types must use runtime reflection. type=telegram.InputFile kind=interface */
		err = buf.Encode(j.Thumb)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if len(j.ParseMode) != 0 {
		buf.WriteString(`"parse_mode":`)
		fflib.WriteJsonString(buf, string(j.ParseMode))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInputMediaDocumentbase = iota
	ffjtInputMediaDocumentnosuchkey

	ffjtInputMediaDocumentType

	ffjtInputMediaDocumentMedia

	ffjtInputMediaDocumentThumb

	ffjtInputMediaDocumentCaption

	ffjtInputMediaDocumentParseMode
)

var ffjKeyInputMediaDocumentType = []byte("type")

var ffjKeyInputMediaDocumentMedia = []byte("media")

var ffjKeyInputMediaDocumentThumb = []byte("thumb")

var ffjKeyInputMediaDocumentCaption = []byte("caption")

var ffjKeyInputMediaDocumentParseMode = []byte("parse_mode")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InputMediaDocument) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InputMediaDocument) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInputMediaDocumentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInputMediaDocumentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInputMediaDocumentCaption, kn) {
						currentKey = ffjtInputMediaDocumentCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyInputMediaDocumentMedia, kn) {
						currentKey = ffjtInputMediaDocumentMedia
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInputMediaDocumentParseMode, kn) {
						currentKey = ffjtInputMediaDocumentParseMode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInputMediaDocumentType, kn) {
						currentKey = ffjtInputMediaDocumentType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInputMediaDocumentThumb, kn) {
						currentKey = ffjtInputMediaDocumentThumb
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInputMediaDocumentParseMode, kn) {
					currentKey = ffjtInputMediaDocumentParseMode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaDocumentCaption, kn) {
					currentKey = ffjtInputMediaDocumentCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaDocumentThumb, kn) {
					currentKey = ffjtInputMediaDocumentThumb
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaDocumentMedia, kn) {
					currentKey = ffjtInputMediaDocumentMedia
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaDocumentType, kn) {
					currentKey = ffjtInputMediaDocumentType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInputMediaDocumentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInputMediaDocumentType:
					goto handle_Type

				case ffjtInputMediaDocumentMedia:
					goto handle_Media

				case ffjtInputMediaDocumentThumb:
					goto handle_Thumb

				case ffjtInputMediaDocumentCaption:
					goto handle_Caption

				case ffjtInputMediaDocumentParseMode:
					goto handle_ParseMode

				case ffjtInputMediaDocumentnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Media:

	/* handler: j.Media type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Media = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Thumb:

	/* handler: j.Thumb type=telegram.InputFile kind=interface quoted=false*/

	{
		/* Falling back. type=telegram.InputFile kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Thumb)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ParseMode:

	/* handler: j.ParseMode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ParseMode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InputMediaPhoto) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InputMediaPhoto) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"media":`)
	fflib.WriteJsonString(buf, string(j.Media))
	buf.WriteByte(',')
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if len(j.ParseMode) != 0 {
		buf.WriteString(`"parse_mode":`)
		fflib.WriteJsonString(buf, string(j.ParseMode))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInputMediaPhotobase = iota
	ffjtInputMediaPhotonosuchkey

	ffjtInputMediaPhotoType

	ffjtInputMediaPhotoMedia

	ffjtInputMediaPhotoCaption

	ffjtInputMediaPhotoParseMode
)

var ffjKeyInputMediaPhotoType = []byte("type")

var ffjKeyInputMediaPhotoMedia = []byte("media")

var ffjKeyInputMediaPhotoCaption = []byte("caption")

var ffjKeyInputMediaPhotoParseMode = []byte("parse_mode")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InputMediaPhoto) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InputMediaPhoto) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInputMediaPhotobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInputMediaPhotonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInputMediaPhotoCaption, kn) {
						currentKey = ffjtInputMediaPhotoCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyInputMediaPhotoMedia, kn) {
						currentKey = ffjtInputMediaPhotoMedia
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInputMediaPhotoParseMode, kn) {
						currentKey = ffjtInputMediaPhotoParseMode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInputMediaPhotoType, kn) {
						currentKey = ffjtInputMediaPhotoType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInputMediaPhotoParseMode, kn) {
					currentKey = ffjtInputMediaPhotoParseMode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaPhotoCaption, kn) {
					currentKey = ffjtInputMediaPhotoCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaPhotoMedia, kn) {
					currentKey = ffjtInputMediaPhotoMedia
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaPhotoType, kn) {
					currentKey = ffjtInputMediaPhotoType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInputMediaPhotonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInputMediaPhotoType:
					goto handle_Type

				case ffjtInputMediaPhotoMedia:
					goto handle_Media

				case ffjtInputMediaPhotoCaption:
					goto handle_Caption

				case ffjtInputMediaPhotoParseMode:
					goto handle_ParseMode

				case ffjtInputMediaPhotonosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Media:

	/* handler: j.Media type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Media = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ParseMode:

	/* handler: j.ParseMode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ParseMode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InputMediaVideo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InputMediaVideo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"media":`)
	fflib.WriteJsonString(buf, string(j.Media))
	buf.WriteByte(',')
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if len(j.ParseMode) != 0 {
		buf.WriteString(`"parse_mode":`)
		fflib.WriteJsonString(buf, string(j.ParseMode))
		buf.WriteByte(',')
	}
	if j.Width != 0 {
		buf.WriteString(`"width":`)
		fflib.FormatBits2(buf, uint64(j.Width), 10, j.Width < 0)
		buf.WriteByte(',')
	}
	if j.Height != 0 {
		buf.WriteString(`"height":`)
		fflib.FormatBits2(buf, uint64(j.Height), 10, j.Height < 0)
		buf.WriteByte(',')
	}
	if j.Duration != 0 {
		buf.WriteString(`"duration":`)
		fflib.FormatBits2(buf, uint64(j.Duration), 10, j.Duration < 0)
		buf.WriteByte(',')
	}
	if j.SupportsStreaming != false {
		if j.SupportsStreaming {
			buf.WriteString(`"supports_streaming":true`)
		} else {
			buf.WriteString(`"supports_streaming":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInputMediaVideobase = iota
	ffjtInputMediaVideonosuchkey

	ffjtInputMediaVideoType

	ffjtInputMediaVideoMedia

	ffjtInputMediaVideoCaption

	ffjtInputMediaVideoParseMode

	ffjtInputMediaVideoWidth

	ffjtInputMediaVideoHeight

	ffjtInputMediaVideoDuration

	ffjtInputMediaVideoSupportsStreaming
)

var ffjKeyInputMediaVideoType = []byte("type")

var ffjKeyInputMediaVideoMedia = []byte("media")

var ffjKeyInputMediaVideoCaption = []byte("caption")

var ffjKeyInputMediaVideoParseMode = []byte("parse_mode")

var ffjKeyInputMediaVideoWidth = []byte("width")

var ffjKeyInputMediaVideoHeight = []byte("height")

var ffjKeyInputMediaVideoDuration = []byte("duration")

var ffjKeyInputMediaVideoSupportsStreaming = []byte("supports_streaming")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InputMediaVideo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InputMediaVideo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInputMediaVideobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInputMediaVideonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInputMediaVideoCaption, kn) {
						currentKey = ffjtInputMediaVideoCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyInputMediaVideoDuration, kn) {
						currentKey = ffjtInputMediaVideoDuration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyInputMediaVideoHeight, kn) {
						currentKey = ffjtInputMediaVideoHeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyInputMediaVideoMedia, kn) {
						currentKey = ffjtInputMediaVideoMedia
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInputMediaVideoParseMode, kn) {
						currentKey = ffjtInputMediaVideoParseMode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyInputMediaVideoSupportsStreaming, kn) {
						currentKey = ffjtInputMediaVideoSupportsStreaming
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInputMediaVideoType, kn) {
						currentKey = ffjtInputMediaVideoType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyInputMediaVideoWidth, kn) {
						currentKey = ffjtInputMediaVideoWidth
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInputMediaVideoSupportsStreaming, kn) {
					currentKey = ffjtInputMediaVideoSupportsStreaming
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaVideoDuration, kn) {
					currentKey = ffjtInputMediaVideoDuration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaVideoHeight, kn) {
					currentKey = ffjtInputMediaVideoHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaVideoWidth, kn) {
					currentKey = ffjtInputMediaVideoWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInputMediaVideoParseMode, kn) {
					currentKey = ffjtInputMediaVideoParseMode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaVideoCaption, kn) {
					currentKey = ffjtInputMediaVideoCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaVideoMedia, kn) {
					currentKey = ffjtInputMediaVideoMedia
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputMediaVideoType, kn) {
					currentKey = ffjtInputMediaVideoType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInputMediaVideonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInputMediaVideoType:
					goto handle_Type

				case ffjtInputMediaVideoMedia:
					goto handle_Media

				case ffjtInputMediaVideoCaption:
					goto handle_Caption

				case ffjtInputMediaVideoParseMode:
					goto handle_ParseMode

				case ffjtInputMediaVideoWidth:
					goto handle_Width

				case ffjtInputMediaVideoHeight:
					goto handle_Height

				case ffjtInputMediaVideoDuration:
					goto handle_Duration

				case ffjtInputMediaVideoSupportsStreaming:
					goto handle_SupportsStreaming

				case ffjtInputMediaVideonosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Media:

	/* handler: j.Media type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Media = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ParseMode:

	/* handler: j.ParseMode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ParseMode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Width:

	/* handler: j.Width type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Width = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Height:

	/* handler: j.Height type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Height = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: j.Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SupportsStreaming:

	/* handler: j.SupportsStreaming type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.SupportsStreaming = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.SupportsStreaming = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InputTextMessageContent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InputTextMessageContent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "message_text":`)
	fflib.WriteJsonString(buf, string(j.MessageText))
	buf.WriteByte(',')
	if len(j.ParseMode) != 0 {
		buf.WriteString(`"parse_mode":`)
		fflib.WriteJsonString(buf, string(j.ParseMode))
		buf.WriteByte(',')
	}
	if j.DisableWebPagePreview != false {
		if j.DisableWebPagePreview {
			buf.WriteString(`"disable_web_page_preview":true`)
		} else {
			buf.WriteString(`"disable_web_page_preview":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInputTextMessageContentbase = iota
	ffjtInputTextMessageContentnosuchkey

	ffjtInputTextMessageContentMessageText

	ffjtInputTextMessageContentParseMode

	ffjtInputTextMessageContentDisableWebPagePreview
)

var ffjKeyInputTextMessageContentMessageText = []byte("message_text")

var ffjKeyInputTextMessageContentParseMode = []byte("parse_mode")

var ffjKeyInputTextMessageContentDisableWebPagePreview = []byte("disable_web_page_preview")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InputTextMessageContent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InputTextMessageContent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInputTextMessageContentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInputTextMessageContentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyInputTextMessageContentDisableWebPagePreview, kn) {
						currentKey = ffjtInputTextMessageContentDisableWebPagePreview
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyInputTextMessageContentMessageText, kn) {
						currentKey = ffjtInputTextMessageContentMessageText
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInputTextMessageContentParseMode, kn) {
						currentKey = ffjtInputTextMessageContentParseMode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInputTextMessageContentDisableWebPagePreview, kn) {
					currentKey = ffjtInputTextMessageContentDisableWebPagePreview
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInputTextMessageContentParseMode, kn) {
					currentKey = ffjtInputTextMessageContentParseMode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInputTextMessageContentMessageText, kn) {
					currentKey = ffjtInputTextMessageContentMessageText
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInputTextMessageContentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInputTextMessageContentMessageText:
					goto handle_MessageText

				case ffjtInputTextMessageContentParseMode:
					goto handle_ParseMode

				case ffjtInputTextMessageContentDisableWebPagePreview:
					goto handle_DisableWebPagePreview

				case ffjtInputTextMessageContentnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_MessageText:

	/* handler: j.MessageText type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MessageText = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ParseMode:

	/* handler: j.ParseMode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ParseMode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DisableWebPagePreview:

	/* handler: j.DisableWebPagePreview type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DisableWebPagePreview = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DisableWebPagePreview = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InputVenueMessageContent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InputVenueMessageContent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "latitude":`)
	fflib.AppendFloat(buf, float64(j.Latitude), 'g', -1, 32)
	buf.WriteString(`,"longitude":`)
	fflib.AppendFloat(buf, float64(j.Longitude), 'g', -1, 32)
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteString(`,"address":`)
	fflib.WriteJsonString(buf, string(j.Address))
	buf.WriteByte(',')
	if len(j.FoursquareID) != 0 {
		buf.WriteString(`"foursquare_id":`)
		fflib.WriteJsonString(buf, string(j.FoursquareID))
		buf.WriteByte(',')
	}
	if len(j.FoursquareType) != 0 {
		buf.WriteString(`"foursquare_type":`)
		fflib.WriteJsonString(buf, string(j.FoursquareType))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInputVenueMessageContentbase = iota
	ffjtInputVenueMessageContentnosuchkey

	ffjtInputVenueMessageContentLatitude

	ffjtInputVenueMessageContentLongitude

	ffjtInputVenueMessageContentTitle

	ffjtInputVenueMessageContentAddress

	ffjtInputVenueMessageContentFoursquareID

	ffjtInputVenueMessageContentFoursquareType
)

var ffjKeyInputVenueMessageContentLatitude = []byte("latitude")

var ffjKeyInputVenueMessageContentLongitude = []byte("longitude")

var ffjKeyInputVenueMessageContentTitle = []byte("title")

var ffjKeyInputVenueMessageContentAddress = []byte("address")

var ffjKeyInputVenueMessageContentFoursquareID = []byte("foursquare_id")

var ffjKeyInputVenueMessageContentFoursquareType = []byte("foursquare_type")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InputVenueMessageContent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InputVenueMessageContent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInputVenueMessageContentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInputVenueMessageContentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyInputVenueMessageContentAddress, kn) {
						currentKey = ffjtInputVenueMessageContentAddress
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyInputVenueMessageContentFoursquareID, kn) {
						currentKey = ffjtInputVenueMessageContentFoursquareID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInputVenueMessageContentFoursquareType, kn) {
						currentKey = ffjtInputVenueMessageContentFoursquareType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyInputVenueMessageContentLatitude, kn) {
						currentKey = ffjtInputVenueMessageContentLatitude
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInputVenueMessageContentLongitude, kn) {
						currentKey = ffjtInputVenueMessageContentLongitude
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInputVenueMessageContentTitle, kn) {
						currentKey = ffjtInputVenueMessageContentTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInputVenueMessageContentFoursquareType, kn) {
					currentKey = ffjtInputVenueMessageContentFoursquareType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInputVenueMessageContentFoursquareID, kn) {
					currentKey = ffjtInputVenueMessageContentFoursquareID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInputVenueMessageContentAddress, kn) {
					currentKey = ffjtInputVenueMessageContentAddress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputVenueMessageContentTitle, kn) {
					currentKey = ffjtInputVenueMessageContentTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputVenueMessageContentLongitude, kn) {
					currentKey = ffjtInputVenueMessageContentLongitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInputVenueMessageContentLatitude, kn) {
					currentKey = ffjtInputVenueMessageContentLatitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInputVenueMessageContentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInputVenueMessageContentLatitude:
					goto handle_Latitude

				case ffjtInputVenueMessageContentLongitude:
					goto handle_Longitude

				case ffjtInputVenueMessageContentTitle:
					goto handle_Title

				case ffjtInputVenueMessageContentAddress:
					goto handle_Address

				case ffjtInputVenueMessageContentFoursquareID:
					goto handle_FoursquareID

				case ffjtInputVenueMessageContentFoursquareType:
					goto handle_FoursquareType

				case ffjtInputVenueMessageContentnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Latitude:

	/* handler: j.Latitude type=float32 kind=float32 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Latitude = float32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Longitude:

	/* handler: j.Longitude type=float32 kind=float32 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Longitude = float32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Address:

	/* handler: j.Address type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Address = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FoursquareID:

	/* handler: j.FoursquareID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FoursquareID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FoursquareType:

	/* handler: j.FoursquareType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FoursquareType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Invoice) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Invoice) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteString(`,"description":`)
	fflib.WriteJsonString(buf, string(j.Description))
	buf.WriteString(`,"start_parameter":`)
	fflib.WriteJsonString(buf, string(j.StartParameter))
	buf.WriteString(`,"currency":`)
	fflib.WriteJsonString(buf, string(j.Currency))
	buf.WriteString(`,"total_amount":`)
	fflib.FormatBits2(buf, uint64(j.TotalAmount), 10, j.TotalAmount < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInvoicebase = iota
	ffjtInvoicenosuchkey

	ffjtInvoiceTitle

	ffjtInvoiceDescription

	ffjtInvoiceStartParameter

	ffjtInvoiceCurrency

	ffjtInvoiceTotalAmount
)

var ffjKeyInvoiceTitle = []byte("title")

var ffjKeyInvoiceDescription = []byte("description")

var ffjKeyInvoiceStartParameter = []byte("start_parameter")

var ffjKeyInvoiceCurrency = []byte("currency")

var ffjKeyInvoiceTotalAmount = []byte("total_amount")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Invoice) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Invoice) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInvoicebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInvoicenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInvoiceCurrency, kn) {
						currentKey = ffjtInvoiceCurrency
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyInvoiceDescription, kn) {
						currentKey = ffjtInvoiceDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyInvoiceStartParameter, kn) {
						currentKey = ffjtInvoiceStartParameter
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInvoiceTitle, kn) {
						currentKey = ffjtInvoiceTitle
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInvoiceTotalAmount, kn) {
						currentKey = ffjtInvoiceTotalAmount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyInvoiceTotalAmount, kn) {
					currentKey = ffjtInvoiceTotalAmount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInvoiceCurrency, kn) {
					currentKey = ffjtInvoiceCurrency
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInvoiceStartParameter, kn) {
					currentKey = ffjtInvoiceStartParameter
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInvoiceDescription, kn) {
					currentKey = ffjtInvoiceDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInvoiceTitle, kn) {
					currentKey = ffjtInvoiceTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInvoicenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInvoiceTitle:
					goto handle_Title

				case ffjtInvoiceDescription:
					goto handle_Description

				case ffjtInvoiceStartParameter:
					goto handle_StartParameter

				case ffjtInvoiceCurrency:
					goto handle_Currency

				case ffjtInvoiceTotalAmount:
					goto handle_TotalAmount

				case ffjtInvoicenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StartParameter:

	/* handler: j.StartParameter type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.StartParameter = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Currency:

	/* handler: j.Currency type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Currency = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalAmount:

	/* handler: j.TotalAmount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.TotalAmount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *KeyboardButton) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *KeyboardButton) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "text":`)
	fflib.WriteJsonString(buf, string(j.Text))
	buf.WriteByte(',')
	if j.RequestContact != false {
		if j.RequestContact {
			buf.WriteString(`"request_contact":true`)
		} else {
			buf.WriteString(`"request_contact":false`)
		}
		buf.WriteByte(',')
	}
	if j.RequestLocation != false {
		if j.RequestLocation {
			buf.WriteString(`"request_location":true`)
		} else {
			buf.WriteString(`"request_location":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtKeyboardButtonbase = iota
	ffjtKeyboardButtonnosuchkey

	ffjtKeyboardButtonText

	ffjtKeyboardButtonRequestContact

	ffjtKeyboardButtonRequestLocation
)

var ffjKeyKeyboardButtonText = []byte("text")

var ffjKeyKeyboardButtonRequestContact = []byte("request_contact")

var ffjKeyKeyboardButtonRequestLocation = []byte("request_location")

// UnmarshalJSON umarshall json - template of ffjson
func (j *KeyboardButton) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *KeyboardButton) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtKeyboardButtonbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtKeyboardButtonnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffjKeyKeyboardButtonRequestContact, kn) {
						currentKey = ffjtKeyboardButtonRequestContact
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyKeyboardButtonRequestLocation, kn) {
						currentKey = ffjtKeyboardButtonRequestLocation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyKeyboardButtonText, kn) {
						currentKey = ffjtKeyboardButtonText
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyKeyboardButtonRequestLocation, kn) {
					currentKey = ffjtKeyboardButtonRequestLocation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyKeyboardButtonRequestContact, kn) {
					currentKey = ffjtKeyboardButtonRequestContact
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyKeyboardButtonText, kn) {
					currentKey = ffjtKeyboardButtonText
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtKeyboardButtonnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtKeyboardButtonText:
					goto handle_Text

				case ffjtKeyboardButtonRequestContact:
					goto handle_RequestContact

				case ffjtKeyboardButtonRequestLocation:
					goto handle_RequestLocation

				case ffjtKeyboardButtonnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Text:

	/* handler: j.Text type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Text = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestContact:

	/* handler: j.RequestContact type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.RequestContact = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.RequestContact = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestLocation:

	/* handler: j.RequestLocation type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.RequestLocation = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.RequestLocation = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *LabeledPrice) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *LabeledPrice) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"label":`)
	fflib.WriteJsonString(buf, string(j.Label))
	buf.WriteString(`,"amount":`)
	fflib.FormatBits2(buf, uint64(j.Amount), 10, j.Amount < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtLabeledPricebase = iota
	ffjtLabeledPricenosuchkey

	ffjtLabeledPriceLabel

	ffjtLabeledPriceAmount
)

var ffjKeyLabeledPriceLabel = []byte("label")

var ffjKeyLabeledPriceAmount = []byte("amount")

// UnmarshalJSON umarshall json - template of ffjson
func (j *LabeledPrice) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *LabeledPrice) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtLabeledPricebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtLabeledPricenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyLabeledPriceAmount, kn) {
						currentKey = ffjtLabeledPriceAmount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyLabeledPriceLabel, kn) {
						currentKey = ffjtLabeledPriceLabel
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyLabeledPriceAmount, kn) {
					currentKey = ffjtLabeledPriceAmount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyLabeledPriceLabel, kn) {
					currentKey = ffjtLabeledPriceLabel
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtLabeledPricenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtLabeledPriceLabel:
					goto handle_Label

				case ffjtLabeledPriceAmount:
					goto handle_Amount

				case ffjtLabeledPricenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Label:

	/* handler: j.Label type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Label = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Amount:

	/* handler: j.Amount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Amount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Location) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Location) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"longitude":`)
	fflib.AppendFloat(buf, float64(j.Longitude), 'g', -1, 32)
	buf.WriteString(`,"latitude":`)
	fflib.AppendFloat(buf, float64(j.Latitude), 'g', -1, 32)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtLocationbase = iota
	ffjtLocationnosuchkey

	ffjtLocationLongitude

	ffjtLocationLatitude
)

var ffjKeyLocationLongitude = []byte("longitude")

var ffjKeyLocationLatitude = []byte("latitude")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Location) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Location) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtLocationbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtLocationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffjKeyLocationLongitude, kn) {
						currentKey = ffjtLocationLongitude
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyLocationLatitude, kn) {
						currentKey = ffjtLocationLatitude
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyLocationLatitude, kn) {
					currentKey = ffjtLocationLatitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyLocationLongitude, kn) {
					currentKey = ffjtLocationLongitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtLocationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtLocationLongitude:
					goto handle_Longitude

				case ffjtLocationLatitude:
					goto handle_Latitude

				case ffjtLocationnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Longitude:

	/* handler: j.Longitude type=float32 kind=float32 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Longitude = float32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Latitude:

	/* handler: j.Latitude type=float32 kind=float32 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Latitude = float32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *LoginURL) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *LoginURL) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "url":`)
	fflib.WriteJsonString(buf, string(j.URL))
	buf.WriteByte(',')
	if len(j.ForwardText) != 0 {
		buf.WriteString(`"forward_text":`)
		fflib.WriteJsonString(buf, string(j.ForwardText))
		buf.WriteByte(',')
	}
	if len(j.BotUsername) != 0 {
		buf.WriteString(`"bot_username":`)
		fflib.WriteJsonString(buf, string(j.BotUsername))
		buf.WriteByte(',')
	}
	if j.RequestWriteAccess != false {
		if j.RequestWriteAccess {
			buf.WriteString(`"request_write_access":true`)
		} else {
			buf.WriteString(`"request_write_access":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtLoginURLbase = iota
	ffjtLoginURLnosuchkey

	ffjtLoginURLURL

	ffjtLoginURLForwardText

	ffjtLoginURLBotUsername

	ffjtLoginURLRequestWriteAccess
)

var ffjKeyLoginURLURL = []byte("url")

var ffjKeyLoginURLForwardText = []byte("forward_text")

var ffjKeyLoginURLBotUsername = []byte("bot_username")

var ffjKeyLoginURLRequestWriteAccess = []byte("request_write_access")

// UnmarshalJSON umarshall json - template of ffjson
func (j *LoginURL) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *LoginURL) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtLoginURLbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtLoginURLnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffjKeyLoginURLBotUsername, kn) {
						currentKey = ffjtLoginURLBotUsername
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyLoginURLForwardText, kn) {
						currentKey = ffjtLoginURLForwardText
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyLoginURLRequestWriteAccess, kn) {
						currentKey = ffjtLoginURLRequestWriteAccess
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyLoginURLURL, kn) {
						currentKey = ffjtLoginURLURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyLoginURLRequestWriteAccess, kn) {
					currentKey = ffjtLoginURLRequestWriteAccess
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyLoginURLBotUsername, kn) {
					currentKey = ffjtLoginURLBotUsername
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyLoginURLForwardText, kn) {
					currentKey = ffjtLoginURLForwardText
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyLoginURLURL, kn) {
					currentKey = ffjtLoginURLURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtLoginURLnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtLoginURLURL:
					goto handle_URL

				case ffjtLoginURLForwardText:
					goto handle_ForwardText

				case ffjtLoginURLBotUsername:
					goto handle_BotUsername

				case ffjtLoginURLRequestWriteAccess:
					goto handle_RequestWriteAccess

				case ffjtLoginURLnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_URL:

	/* handler: j.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwardText:

	/* handler: j.ForwardText type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ForwardText = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BotUsername:

	/* handler: j.BotUsername type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.BotUsername = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestWriteAccess:

	/* handler: j.RequestWriteAccess type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.RequestWriteAccess = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.RequestWriteAccess = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *MaskPosition) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *MaskPosition) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"point":`)
	fflib.WriteJsonString(buf, string(j.Point))
	buf.WriteString(`,"x_shift":`)
	fflib.AppendFloat(buf, float64(j.XShift), 'g', -1, 32)
	buf.WriteString(`,"y_shift":`)
	fflib.AppendFloat(buf, float64(j.YShift), 'g', -1, 32)
	buf.WriteString(`,"scale":`)
	fflib.AppendFloat(buf, float64(j.Scale), 'g', -1, 32)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtMaskPositionbase = iota
	ffjtMaskPositionnosuchkey

	ffjtMaskPositionPoint

	ffjtMaskPositionXShift

	ffjtMaskPositionYShift

	ffjtMaskPositionScale
)

var ffjKeyMaskPositionPoint = []byte("point")

var ffjKeyMaskPositionXShift = []byte("x_shift")

var ffjKeyMaskPositionYShift = []byte("y_shift")

var ffjKeyMaskPositionScale = []byte("scale")

// UnmarshalJSON umarshall json - template of ffjson
func (j *MaskPosition) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *MaskPosition) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtMaskPositionbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtMaskPositionnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffjKeyMaskPositionPoint, kn) {
						currentKey = ffjtMaskPositionPoint
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyMaskPositionScale, kn) {
						currentKey = ffjtMaskPositionScale
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'x':

					if bytes.Equal(ffjKeyMaskPositionXShift, kn) {
						currentKey = ffjtMaskPositionXShift
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'y':

					if bytes.Equal(ffjKeyMaskPositionYShift, kn) {
						currentKey = ffjtMaskPositionYShift
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyMaskPositionScale, kn) {
					currentKey = ffjtMaskPositionScale
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMaskPositionYShift, kn) {
					currentKey = ffjtMaskPositionYShift
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMaskPositionXShift, kn) {
					currentKey = ffjtMaskPositionXShift
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMaskPositionPoint, kn) {
					currentKey = ffjtMaskPositionPoint
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtMaskPositionnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtMaskPositionPoint:
					goto handle_Point

				case ffjtMaskPositionXShift:
					goto handle_XShift

				case ffjtMaskPositionYShift:
					goto handle_YShift

				case ffjtMaskPositionScale:
					goto handle_Scale

				case ffjtMaskPositionnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Point:

	/* handler: j.Point type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Point = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_XShift:

	/* handler: j.XShift type=float32 kind=float32 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.XShift = float32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_YShift:

	/* handler: j.YShift type=float32 kind=float32 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.YShift = float32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Scale:

	/* handler: j.Scale type=float32 kind=float32 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Scale = float32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Message) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Message) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "message_id":`)
	fflib.FormatBits2(buf, uint64(j.ID), 10, j.ID < 0)
	buf.WriteByte(',')
	if j.From != nil {
		if true {
			buf.WriteString(`"from":`)

			{

				err = j.From.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"date":`)
	fflib.FormatBits2(buf, uint64(j.Date), 10, j.Date < 0)
	if j.Chat != nil {
		buf.WriteString(`,"chat":`)

		{

			err = j.Chat.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"chat":null`)
	}
	buf.WriteByte(',')
	if j.ForwardFrom != nil {
		if true {
			buf.WriteString(`"forward_from":`)

			{

				err = j.ForwardFrom.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ForwardFromChat != nil {
		if true {
			buf.WriteString(`"forward_from_chat":`)

			{

				err = j.ForwardFromChat.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ForwardFromMessageID != 0 {
		buf.WriteString(`"forward_from_message_id":`)
		fflib.FormatBits2(buf, uint64(j.ForwardFromMessageID), 10, j.ForwardFromMessageID < 0)
		buf.WriteByte(',')
	}
	if len(j.ForwardSignature) != 0 {
		buf.WriteString(`"forward_signature":`)
		fflib.WriteJsonString(buf, string(j.ForwardSignature))
		buf.WriteByte(',')
	}
	if len(j.ForwardSenderName) != 0 {
		buf.WriteString(`"forward_sender_name":`)
		fflib.WriteJsonString(buf, string(j.ForwardSenderName))
		buf.WriteByte(',')
	}
	if j.ForwardDate != 0 {
		buf.WriteString(`"forward_date":`)
		fflib.FormatBits2(buf, uint64(j.ForwardDate), 10, j.ForwardDate < 0)
		buf.WriteByte(',')
	}
	if j.ReplyToMessage != nil {
		if true {
			buf.WriteString(`"reply_to_message":`)

			{

				err = j.ReplyToMessage.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.EditDate != 0 {
		buf.WriteString(`"edit_date":`)
		fflib.FormatBits2(buf, uint64(j.EditDate), 10, j.EditDate < 0)
		buf.WriteByte(',')
	}
	if len(j.MediaGroupID) != 0 {
		buf.WriteString(`"media_group_id":`)
		fflib.WriteJsonString(buf, string(j.MediaGroupID))
		buf.WriteByte(',')
	}
	if len(j.AuthorSignature) != 0 {
		buf.WriteString(`"author_signature":`)
		fflib.WriteJsonString(buf, string(j.AuthorSignature))
		buf.WriteByte(',')
	}
	if len(j.Text) != 0 {
		buf.WriteString(`"text":`)
		fflib.WriteJsonString(buf, string(j.Text))
		buf.WriteByte(',')
	}
	if len(j.Entities) != 0 {
		buf.WriteString(`"entities":`)
		if j.Entities != nil {
			buf.WriteString(`[`)
			for i, v := range j.Entities {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.CaptionEntities) != 0 {
		buf.WriteString(`"caption_entities":`)
		if j.CaptionEntities != nil {
			buf.WriteString(`[`)
			for i, v := range j.CaptionEntities {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.Audio != nil {
		if true {
			buf.WriteString(`"audio":`)

			{

				err = j.Audio.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Document != nil {
		if true {
			buf.WriteString(`"document":`)

			{

				err = j.Document.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Animation != nil {
		if true {
			buf.WriteString(`"animation":`)

			{

				err = j.Animation.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Game != nil {
		if true {
			buf.WriteString(`"game":`)

			{

				err = j.Game.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.Photo) != 0 {
		buf.WriteString(`"photo":`)
		if j.Photo != nil {
			buf.WriteString(`[`)
			for i, v := range j.Photo {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.Sticker != nil {
		if true {
			buf.WriteString(`"sticker":`)

			{

				err = j.Sticker.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Video != nil {
		if true {
			buf.WriteString(`"video":`)

			{

				err = j.Video.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Voice != nil {
		if true {
			buf.WriteString(`"voice":`)

			{

				err = j.Voice.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.VideoNote != nil {
		if true {
			buf.WriteString(`"video_note":`)

			{

				err = j.VideoNote.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if j.Contact != nil {
		if true {
			buf.WriteString(`"contact":`)

			{

				err = j.Contact.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Location != nil {
		if true {
			buf.WriteString(`"location":`)

			{

				err = j.Location.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Venue != nil {
		if true {
			buf.WriteString(`"venue":`)

			{

				err = j.Venue.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Poll != nil {
		buf.WriteString(`"poll":`)

		{

			err = j.Poll.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`"poll":null`)
	}
	buf.WriteByte(',')
	if len(j.NewChatMembers) != 0 {
		buf.WriteString(`"new_chat_members":`)
		if j.NewChatMembers != nil {
			buf.WriteString(`[`)
			for i, v := range j.NewChatMembers {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.LeftChatMember != nil {
		if true {
			buf.WriteString(`"left_chat_member":`)

			{

				err = j.LeftChatMember.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.NewChatTitle) != 0 {
		buf.WriteString(`"new_chat_title":`)
		fflib.WriteJsonString(buf, string(j.NewChatTitle))
		buf.WriteByte(',')
	}
	if len(j.NewChatPhoto) != 0 {
		buf.WriteString(`"new_chat_photo":`)
		if j.NewChatPhoto != nil {
			buf.WriteString(`[`)
			for i, v := range j.NewChatPhoto {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.DeleteChatPhoto != false {
		if j.DeleteChatPhoto {
			buf.WriteString(`"delete_chat_photo":true`)
		} else {
			buf.WriteString(`"delete_chat_photo":false`)
		}
		buf.WriteByte(',')
	}
	if j.GroupChatCreated != false {
		if j.GroupChatCreated {
			buf.WriteString(`"group_chat_created":true`)
		} else {
			buf.WriteString(`"group_chat_created":false`)
		}
		buf.WriteByte(',')
	}
	if j.SupergroupChatCreated != false {
		if j.SupergroupChatCreated {
			buf.WriteString(`"supergroup_chat_created":true`)
		} else {
			buf.WriteString(`"supergroup_chat_created":false`)
		}
		buf.WriteByte(',')
	}
	if j.ChannelChatCreated != false {
		if j.ChannelChatCreated {
			buf.WriteString(`"channel_chat_created":true`)
		} else {
			buf.WriteString(`"channel_chat_created":false`)
		}
		buf.WriteByte(',')
	}
	if j.MigrateToChatID != 0 {
		buf.WriteString(`"migrate_to_chat_id":`)
		fflib.FormatBits2(buf, uint64(j.MigrateToChatID), 10, j.MigrateToChatID < 0)
		buf.WriteByte(',')
	}
	if j.MigrateFromChatID != 0 {
		buf.WriteString(`"migrate_from_chat_id":`)
		fflib.FormatBits2(buf, uint64(j.MigrateFromChatID), 10, j.MigrateFromChatID < 0)
		buf.WriteByte(',')
	}
	if j.PinnedMessage != nil {
		if true {
			buf.WriteString(`"pinned_message":`)

			{

				err = j.PinnedMessage.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Invoice != nil {
		if true {
			buf.WriteString(`"invoice":`)

			{

				err = j.Invoice.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.SuccessfulPayment != nil {
		if true {
			buf.WriteString(`"successful_payment":`)

			{

				err = j.SuccessfulPayment.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.ConnectedWebsite) != 0 {
		buf.WriteString(`"connected_website":`)
		fflib.WriteJsonString(buf, string(j.ConnectedWebsite))
		buf.WriteByte(',')
	}
	if j.PassportData != nil {
		if true {
			buf.WriteString(`"passport_data":`)

			{

				err = j.PassportData.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = j.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtMessagebase = iota
	ffjtMessagenosuchkey

	ffjtMessageID

	ffjtMessageFrom

	ffjtMessageDate

	ffjtMessageChat

	ffjtMessageForwardFrom

	ffjtMessageForwardFromChat

	ffjtMessageForwardFromMessageID

	ffjtMessageForwardSignature

	ffjtMessageForwardSenderName

	ffjtMessageForwardDate

	ffjtMessageReplyToMessage

	ffjtMessageEditDate

	ffjtMessageMediaGroupID

	ffjtMessageAuthorSignature

	ffjtMessageText

	ffjtMessageEntities

	ffjtMessageCaptionEntities

	ffjtMessageAudio

	ffjtMessageDocument

	ffjtMessageAnimation

	ffjtMessageGame

	ffjtMessagePhoto

	ffjtMessageSticker

	ffjtMessageVideo

	ffjtMessageVoice

	ffjtMessageVideoNote

	ffjtMessageCaption

	ffjtMessageContact

	ffjtMessageLocation

	ffjtMessageVenue

	ffjtMessagePoll

	ffjtMessageNewChatMembers

	ffjtMessageLeftChatMember

	ffjtMessageNewChatTitle

	ffjtMessageNewChatPhoto

	ffjtMessageDeleteChatPhoto

	ffjtMessageGroupChatCreated

	ffjtMessageSupergroupChatCreated

	ffjtMessageChannelChatCreated

	ffjtMessageMigrateToChatID

	ffjtMessageMigrateFromChatID

	ffjtMessagePinnedMessage

	ffjtMessageInvoice

	ffjtMessageSuccessfulPayment

	ffjtMessageConnectedWebsite

	ffjtMessagePassportData

	ffjtMessageReplyMarkup
)

var ffjKeyMessageID = []byte("message_id")

var ffjKeyMessageFrom = []byte("from")

var ffjKeyMessageDate = []byte("date")

var ffjKeyMessageChat = []byte("chat")

var ffjKeyMessageForwardFrom = []byte("forward_from")

var ffjKeyMessageForwardFromChat = []byte("forward_from_chat")

var ffjKeyMessageForwardFromMessageID = []byte("forward_from_message_id")

var ffjKeyMessageForwardSignature = []byte("forward_signature")

var ffjKeyMessageForwardSenderName = []byte("forward_sender_name")

var ffjKeyMessageForwardDate = []byte("forward_date")

var ffjKeyMessageReplyToMessage = []byte("reply_to_message")

var ffjKeyMessageEditDate = []byte("edit_date")

var ffjKeyMessageMediaGroupID = []byte("media_group_id")

var ffjKeyMessageAuthorSignature = []byte("author_signature")

var ffjKeyMessageText = []byte("text")

var ffjKeyMessageEntities = []byte("entities")

var ffjKeyMessageCaptionEntities = []byte("caption_entities")

var ffjKeyMessageAudio = []byte("audio")

var ffjKeyMessageDocument = []byte("document")

var ffjKeyMessageAnimation = []byte("animation")

var ffjKeyMessageGame = []byte("game")

var ffjKeyMessagePhoto = []byte("photo")

var ffjKeyMessageSticker = []byte("sticker")

var ffjKeyMessageVideo = []byte("video")

var ffjKeyMessageVoice = []byte("voice")

var ffjKeyMessageVideoNote = []byte("video_note")

var ffjKeyMessageCaption = []byte("caption")

var ffjKeyMessageContact = []byte("contact")

var ffjKeyMessageLocation = []byte("location")

var ffjKeyMessageVenue = []byte("venue")

var ffjKeyMessagePoll = []byte("poll")

var ffjKeyMessageNewChatMembers = []byte("new_chat_members")

var ffjKeyMessageLeftChatMember = []byte("left_chat_member")

var ffjKeyMessageNewChatTitle = []byte("new_chat_title")

var ffjKeyMessageNewChatPhoto = []byte("new_chat_photo")

var ffjKeyMessageDeleteChatPhoto = []byte("delete_chat_photo")

var ffjKeyMessageGroupChatCreated = []byte("group_chat_created")

var ffjKeyMessageSupergroupChatCreated = []byte("supergroup_chat_created")

var ffjKeyMessageChannelChatCreated = []byte("channel_chat_created")

var ffjKeyMessageMigrateToChatID = []byte("migrate_to_chat_id")

var ffjKeyMessageMigrateFromChatID = []byte("migrate_from_chat_id")

var ffjKeyMessagePinnedMessage = []byte("pinned_message")

var ffjKeyMessageInvoice = []byte("invoice")

var ffjKeyMessageSuccessfulPayment = []byte("successful_payment")

var ffjKeyMessageConnectedWebsite = []byte("connected_website")

var ffjKeyMessagePassportData = []byte("passport_data")

var ffjKeyMessageReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Message) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Message) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtMessagebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtMessagenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyMessageAuthorSignature, kn) {
						currentKey = ffjtMessageAuthorSignature
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageAudio, kn) {
						currentKey = ffjtMessageAudio
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageAnimation, kn) {
						currentKey = ffjtMessageAnimation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyMessageChat, kn) {
						currentKey = ffjtMessageChat
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageCaptionEntities, kn) {
						currentKey = ffjtMessageCaptionEntities
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageCaption, kn) {
						currentKey = ffjtMessageCaption
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageContact, kn) {
						currentKey = ffjtMessageContact
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageChannelChatCreated, kn) {
						currentKey = ffjtMessageChannelChatCreated
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageConnectedWebsite, kn) {
						currentKey = ffjtMessageConnectedWebsite
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyMessageDate, kn) {
						currentKey = ffjtMessageDate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageDocument, kn) {
						currentKey = ffjtMessageDocument
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageDeleteChatPhoto, kn) {
						currentKey = ffjtMessageDeleteChatPhoto
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyMessageEditDate, kn) {
						currentKey = ffjtMessageEditDate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageEntities, kn) {
						currentKey = ffjtMessageEntities
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyMessageFrom, kn) {
						currentKey = ffjtMessageFrom
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageForwardFrom, kn) {
						currentKey = ffjtMessageForwardFrom
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageForwardFromChat, kn) {
						currentKey = ffjtMessageForwardFromChat
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageForwardFromMessageID, kn) {
						currentKey = ffjtMessageForwardFromMessageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageForwardSignature, kn) {
						currentKey = ffjtMessageForwardSignature
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageForwardSenderName, kn) {
						currentKey = ffjtMessageForwardSenderName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageForwardDate, kn) {
						currentKey = ffjtMessageForwardDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyMessageGame, kn) {
						currentKey = ffjtMessageGame
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageGroupChatCreated, kn) {
						currentKey = ffjtMessageGroupChatCreated
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyMessageInvoice, kn) {
						currentKey = ffjtMessageInvoice
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyMessageLocation, kn) {
						currentKey = ffjtMessageLocation
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageLeftChatMember, kn) {
						currentKey = ffjtMessageLeftChatMember
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyMessageID, kn) {
						currentKey = ffjtMessageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageMediaGroupID, kn) {
						currentKey = ffjtMessageMediaGroupID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageMigrateToChatID, kn) {
						currentKey = ffjtMessageMigrateToChatID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageMigrateFromChatID, kn) {
						currentKey = ffjtMessageMigrateFromChatID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyMessageNewChatMembers, kn) {
						currentKey = ffjtMessageNewChatMembers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageNewChatTitle, kn) {
						currentKey = ffjtMessageNewChatTitle
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageNewChatPhoto, kn) {
						currentKey = ffjtMessageNewChatPhoto
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyMessagePhoto, kn) {
						currentKey = ffjtMessagePhoto
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessagePoll, kn) {
						currentKey = ffjtMessagePoll
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessagePinnedMessage, kn) {
						currentKey = ffjtMessagePinnedMessage
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessagePassportData, kn) {
						currentKey = ffjtMessagePassportData
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyMessageReplyToMessage, kn) {
						currentKey = ffjtMessageReplyToMessage
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageReplyMarkup, kn) {
						currentKey = ffjtMessageReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyMessageSticker, kn) {
						currentKey = ffjtMessageSticker
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageSupergroupChatCreated, kn) {
						currentKey = ffjtMessageSupergroupChatCreated
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageSuccessfulPayment, kn) {
						currentKey = ffjtMessageSuccessfulPayment
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyMessageText, kn) {
						currentKey = ffjtMessageText
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyMessageVideo, kn) {
						currentKey = ffjtMessageVideo
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageVoice, kn) {
						currentKey = ffjtMessageVoice
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageVideoNote, kn) {
						currentKey = ffjtMessageVideoNote
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageVenue, kn) {
						currentKey = ffjtMessageVenue
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyMessageReplyMarkup, kn) {
					currentKey = ffjtMessageReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessagePassportData, kn) {
					currentKey = ffjtMessagePassportData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageConnectedWebsite, kn) {
					currentKey = ffjtMessageConnectedWebsite
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageSuccessfulPayment, kn) {
					currentKey = ffjtMessageSuccessfulPayment
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageInvoice, kn) {
					currentKey = ffjtMessageInvoice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessagePinnedMessage, kn) {
					currentKey = ffjtMessagePinnedMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageMigrateFromChatID, kn) {
					currentKey = ffjtMessageMigrateFromChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageMigrateToChatID, kn) {
					currentKey = ffjtMessageMigrateToChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageChannelChatCreated, kn) {
					currentKey = ffjtMessageChannelChatCreated
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageSupergroupChatCreated, kn) {
					currentKey = ffjtMessageSupergroupChatCreated
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageGroupChatCreated, kn) {
					currentKey = ffjtMessageGroupChatCreated
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageDeleteChatPhoto, kn) {
					currentKey = ffjtMessageDeleteChatPhoto
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageNewChatPhoto, kn) {
					currentKey = ffjtMessageNewChatPhoto
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageNewChatTitle, kn) {
					currentKey = ffjtMessageNewChatTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageLeftChatMember, kn) {
					currentKey = ffjtMessageLeftChatMember
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageNewChatMembers, kn) {
					currentKey = ffjtMessageNewChatMembers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessagePoll, kn) {
					currentKey = ffjtMessagePoll
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageVenue, kn) {
					currentKey = ffjtMessageVenue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageLocation, kn) {
					currentKey = ffjtMessageLocation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageContact, kn) {
					currentKey = ffjtMessageContact
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageCaption, kn) {
					currentKey = ffjtMessageCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageVideoNote, kn) {
					currentKey = ffjtMessageVideoNote
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageVoice, kn) {
					currentKey = ffjtMessageVoice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageVideo, kn) {
					currentKey = ffjtMessageVideo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageSticker, kn) {
					currentKey = ffjtMessageSticker
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessagePhoto, kn) {
					currentKey = ffjtMessagePhoto
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageGame, kn) {
					currentKey = ffjtMessageGame
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageAnimation, kn) {
					currentKey = ffjtMessageAnimation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageDocument, kn) {
					currentKey = ffjtMessageDocument
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageAudio, kn) {
					currentKey = ffjtMessageAudio
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageCaptionEntities, kn) {
					currentKey = ffjtMessageCaptionEntities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageEntities, kn) {
					currentKey = ffjtMessageEntities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageText, kn) {
					currentKey = ffjtMessageText
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageAuthorSignature, kn) {
					currentKey = ffjtMessageAuthorSignature
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageMediaGroupID, kn) {
					currentKey = ffjtMessageMediaGroupID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageEditDate, kn) {
					currentKey = ffjtMessageEditDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageReplyToMessage, kn) {
					currentKey = ffjtMessageReplyToMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageForwardDate, kn) {
					currentKey = ffjtMessageForwardDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageForwardSenderName, kn) {
					currentKey = ffjtMessageForwardSenderName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageForwardSignature, kn) {
					currentKey = ffjtMessageForwardSignature
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageForwardFromMessageID, kn) {
					currentKey = ffjtMessageForwardFromMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageForwardFromChat, kn) {
					currentKey = ffjtMessageForwardFromChat
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageForwardFrom, kn) {
					currentKey = ffjtMessageForwardFrom
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageChat, kn) {
					currentKey = ffjtMessageChat
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageDate, kn) {
					currentKey = ffjtMessageDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageFrom, kn) {
					currentKey = ffjtMessageFrom
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageID, kn) {
					currentKey = ffjtMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtMessagenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtMessageID:
					goto handle_ID

				case ffjtMessageFrom:
					goto handle_From

				case ffjtMessageDate:
					goto handle_Date

				case ffjtMessageChat:
					goto handle_Chat

				case ffjtMessageForwardFrom:
					goto handle_ForwardFrom

				case ffjtMessageForwardFromChat:
					goto handle_ForwardFromChat

				case ffjtMessageForwardFromMessageID:
					goto handle_ForwardFromMessageID

				case ffjtMessageForwardSignature:
					goto handle_ForwardSignature

				case ffjtMessageForwardSenderName:
					goto handle_ForwardSenderName

				case ffjtMessageForwardDate:
					goto handle_ForwardDate

				case ffjtMessageReplyToMessage:
					goto handle_ReplyToMessage

				case ffjtMessageEditDate:
					goto handle_EditDate

				case ffjtMessageMediaGroupID:
					goto handle_MediaGroupID

				case ffjtMessageAuthorSignature:
					goto handle_AuthorSignature

				case ffjtMessageText:
					goto handle_Text

				case ffjtMessageEntities:
					goto handle_Entities

				case ffjtMessageCaptionEntities:
					goto handle_CaptionEntities

				case ffjtMessageAudio:
					goto handle_Audio

				case ffjtMessageDocument:
					goto handle_Document

				case ffjtMessageAnimation:
					goto handle_Animation

				case ffjtMessageGame:
					goto handle_Game

				case ffjtMessagePhoto:
					goto handle_Photo

				case ffjtMessageSticker:
					goto handle_Sticker

				case ffjtMessageVideo:
					goto handle_Video

				case ffjtMessageVoice:
					goto handle_Voice

				case ffjtMessageVideoNote:
					goto handle_VideoNote

				case ffjtMessageCaption:
					goto handle_Caption

				case ffjtMessageContact:
					goto handle_Contact

				case ffjtMessageLocation:
					goto handle_Location

				case ffjtMessageVenue:
					goto handle_Venue

				case ffjtMessagePoll:
					goto handle_Poll

				case ffjtMessageNewChatMembers:
					goto handle_NewChatMembers

				case ffjtMessageLeftChatMember:
					goto handle_LeftChatMember

				case ffjtMessageNewChatTitle:
					goto handle_NewChatTitle

				case ffjtMessageNewChatPhoto:
					goto handle_NewChatPhoto

				case ffjtMessageDeleteChatPhoto:
					goto handle_DeleteChatPhoto

				case ffjtMessageGroupChatCreated:
					goto handle_GroupChatCreated

				case ffjtMessageSupergroupChatCreated:
					goto handle_SupergroupChatCreated

				case ffjtMessageChannelChatCreated:
					goto handle_ChannelChatCreated

				case ffjtMessageMigrateToChatID:
					goto handle_MigrateToChatID

				case ffjtMessageMigrateFromChatID:
					goto handle_MigrateFromChatID

				case ffjtMessagePinnedMessage:
					goto handle_PinnedMessage

				case ffjtMessageInvoice:
					goto handle_Invoice

				case ffjtMessageSuccessfulPayment:
					goto handle_SuccessfulPayment

				case ffjtMessageConnectedWebsite:
					goto handle_ConnectedWebsite

				case ffjtMessagePassportData:
					goto handle_PassportData

				case ffjtMessageReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtMessagenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_From:

	/* handler: j.From type=telegram.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.From = nil

		} else {

			if j.From == nil {
				j.From = new(User)
			}

			err = j.From.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Date:

	/* handler: j.Date type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Date = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Chat:

	/* handler: j.Chat type=telegram.Chat kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Chat = nil

		} else {

			if j.Chat == nil {
				j.Chat = new(Chat)
			}

			err = j.Chat.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwardFrom:

	/* handler: j.ForwardFrom type=telegram.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ForwardFrom = nil

		} else {

			if j.ForwardFrom == nil {
				j.ForwardFrom = new(User)
			}

			err = j.ForwardFrom.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwardFromChat:

	/* handler: j.ForwardFromChat type=telegram.Chat kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ForwardFromChat = nil

		} else {

			if j.ForwardFromChat == nil {
				j.ForwardFromChat = new(Chat)
			}

			err = j.ForwardFromChat.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwardFromMessageID:

	/* handler: j.ForwardFromMessageID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ForwardFromMessageID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwardSignature:

	/* handler: j.ForwardSignature type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ForwardSignature = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwardSenderName:

	/* handler: j.ForwardSenderName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ForwardSenderName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwardDate:

	/* handler: j.ForwardDate type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ForwardDate = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyToMessage:

	/* handler: j.ReplyToMessage type=telegram.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReplyToMessage = nil

		} else {

			if j.ReplyToMessage == nil {
				j.ReplyToMessage = new(Message)
			}

			err = j.ReplyToMessage.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EditDate:

	/* handler: j.EditDate type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.EditDate = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MediaGroupID:

	/* handler: j.MediaGroupID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MediaGroupID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AuthorSignature:

	/* handler: j.AuthorSignature type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.AuthorSignature = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Text:

	/* handler: j.Text type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Text = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Entities:

	/* handler: j.Entities type=[]telegram.MessageEntity kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Entities = nil
		} else {

			j.Entities = []MessageEntity{}

			wantVal := true

			for {

				var tmpJEntities MessageEntity

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJEntities type=telegram.MessageEntity kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJEntities.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Entities = append(j.Entities, tmpJEntities)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CaptionEntities:

	/* handler: j.CaptionEntities type=[]telegram.MessageEntity kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.CaptionEntities = nil
		} else {

			j.CaptionEntities = []MessageEntity{}

			wantVal := true

			for {

				var tmpJCaptionEntities MessageEntity

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJCaptionEntities type=telegram.MessageEntity kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJCaptionEntities.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.CaptionEntities = append(j.CaptionEntities, tmpJCaptionEntities)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Audio:

	/* handler: j.Audio type=telegram.Audio kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Audio = nil

		} else {

			if j.Audio == nil {
				j.Audio = new(Audio)
			}

			err = j.Audio.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Document:

	/* handler: j.Document type=telegram.Document kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Document = nil

		} else {

			if j.Document == nil {
				j.Document = new(Document)
			}

			err = j.Document.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Animation:

	/* handler: j.Animation type=telegram.Animation kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Animation = nil

		} else {

			if j.Animation == nil {
				j.Animation = new(Animation)
			}

			err = j.Animation.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Game:

	/* handler: j.Game type=telegram.Game kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Game = nil

		} else {

			if j.Game == nil {
				j.Game = new(Game)
			}

			err = j.Game.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Photo:

	/* handler: j.Photo type=[]telegram.PhotoSize kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Photo = nil
		} else {

			j.Photo = []PhotoSize{}

			wantVal := true

			for {

				var tmpJPhoto PhotoSize

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJPhoto type=telegram.PhotoSize kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJPhoto.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Photo = append(j.Photo, tmpJPhoto)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sticker:

	/* handler: j.Sticker type=telegram.Sticker kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Sticker = nil

		} else {

			if j.Sticker == nil {
				j.Sticker = new(Sticker)
			}

			err = j.Sticker.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Video:

	/* handler: j.Video type=telegram.Video kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Video = nil

		} else {

			if j.Video == nil {
				j.Video = new(Video)
			}

			err = j.Video.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Voice:

	/* handler: j.Voice type=telegram.Voice kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Voice = nil

		} else {

			if j.Voice == nil {
				j.Voice = new(Voice)
			}

			err = j.Voice.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VideoNote:

	/* handler: j.VideoNote type=telegram.VideoNote kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.VideoNote = nil

		} else {

			if j.VideoNote == nil {
				j.VideoNote = new(VideoNote)
			}

			err = j.VideoNote.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Contact:

	/* handler: j.Contact type=telegram.Contact kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Contact = nil

		} else {

			if j.Contact == nil {
				j.Contact = new(Contact)
			}

			err = j.Contact.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Location:

	/* handler: j.Location type=telegram.Location kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Location = nil

		} else {

			if j.Location == nil {
				j.Location = new(Location)
			}

			err = j.Location.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Venue:

	/* handler: j.Venue type=telegram.Venue kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Venue = nil

		} else {

			if j.Venue == nil {
				j.Venue = new(Venue)
			}

			err = j.Venue.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Poll:

	/* handler: j.Poll type=telegram.Poll kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Poll = nil

		} else {

			if j.Poll == nil {
				j.Poll = new(Poll)
			}

			err = j.Poll.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NewChatMembers:

	/* handler: j.NewChatMembers type=[]telegram.User kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.NewChatMembers = nil
		} else {

			j.NewChatMembers = []User{}

			wantVal := true

			for {

				var tmpJNewChatMembers User

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJNewChatMembers type=telegram.User kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJNewChatMembers.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.NewChatMembers = append(j.NewChatMembers, tmpJNewChatMembers)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LeftChatMember:

	/* handler: j.LeftChatMember type=telegram.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.LeftChatMember = nil

		} else {

			if j.LeftChatMember == nil {
				j.LeftChatMember = new(User)
			}

			err = j.LeftChatMember.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NewChatTitle:

	/* handler: j.NewChatTitle type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.NewChatTitle = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NewChatPhoto:

	/* handler: j.NewChatPhoto type=[]telegram.PhotoSize kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.NewChatPhoto = nil
		} else {

			j.NewChatPhoto = []PhotoSize{}

			wantVal := true

			for {

				var tmpJNewChatPhoto PhotoSize

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJNewChatPhoto type=telegram.PhotoSize kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJNewChatPhoto.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.NewChatPhoto = append(j.NewChatPhoto, tmpJNewChatPhoto)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DeleteChatPhoto:

	/* handler: j.DeleteChatPhoto type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DeleteChatPhoto = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DeleteChatPhoto = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GroupChatCreated:

	/* handler: j.GroupChatCreated type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.GroupChatCreated = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.GroupChatCreated = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SupergroupChatCreated:

	/* handler: j.SupergroupChatCreated type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.SupergroupChatCreated = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.SupergroupChatCreated = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelChatCreated:

	/* handler: j.ChannelChatCreated type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.ChannelChatCreated = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.ChannelChatCreated = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MigrateToChatID:

	/* handler: j.MigrateToChatID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MigrateToChatID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MigrateFromChatID:

	/* handler: j.MigrateFromChatID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MigrateFromChatID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PinnedMessage:

	/* handler: j.PinnedMessage type=telegram.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.PinnedMessage = nil

		} else {

			if j.PinnedMessage == nil {
				j.PinnedMessage = new(Message)
			}

			err = j.PinnedMessage.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Invoice:

	/* handler: j.Invoice type=telegram.Invoice kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Invoice = nil

		} else {

			if j.Invoice == nil {
				j.Invoice = new(Invoice)
			}

			err = j.Invoice.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SuccessfulPayment:

	/* handler: j.SuccessfulPayment type=telegram.SuccessfulPayment kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.SuccessfulPayment = nil

		} else {

			if j.SuccessfulPayment == nil {
				j.SuccessfulPayment = new(SuccessfulPayment)
			}

			err = j.SuccessfulPayment.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ConnectedWebsite:

	/* handler: j.ConnectedWebsite type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ConnectedWebsite = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PassportData:

	/* handler: j.PassportData type=telegram.PassportData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.PassportData = nil

		} else {

			if j.PassportData == nil {
				j.PassportData = new(PassportData)
			}

			err = j.PassportData.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=telegram.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReplyMarkup = nil

		} else {

			if j.ReplyMarkup == nil {
				j.ReplyMarkup = new(InlineKeyboardMarkup)
			}

			err = j.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *MessageEntity) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *MessageEntity) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteByte(',')
	if len(j.URL) != 0 {
		buf.WriteString(`"url":`)
		fflib.WriteJsonString(buf, string(j.URL))
		buf.WriteByte(',')
	}
	buf.WriteString(`"offset":`)
	fflib.FormatBits2(buf, uint64(j.Offset), 10, j.Offset < 0)
	buf.WriteString(`,"length":`)
	fflib.FormatBits2(buf, uint64(j.Length), 10, j.Length < 0)
	buf.WriteByte(',')
	if j.User != nil {
		if true {
			buf.WriteString(`"user":`)

			{

				err = j.User.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtMessageEntitybase = iota
	ffjtMessageEntitynosuchkey

	ffjtMessageEntityType

	ffjtMessageEntityURL

	ffjtMessageEntityOffset

	ffjtMessageEntityLength

	ffjtMessageEntityUser
)

var ffjKeyMessageEntityType = []byte("type")

var ffjKeyMessageEntityURL = []byte("url")

var ffjKeyMessageEntityOffset = []byte("offset")

var ffjKeyMessageEntityLength = []byte("length")

var ffjKeyMessageEntityUser = []byte("user")

// UnmarshalJSON umarshall json - template of ffjson
func (j *MessageEntity) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *MessageEntity) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtMessageEntitybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtMessageEntitynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffjKeyMessageEntityLength, kn) {
						currentKey = ffjtMessageEntityLength
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyMessageEntityOffset, kn) {
						currentKey = ffjtMessageEntityOffset
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyMessageEntityType, kn) {
						currentKey = ffjtMessageEntityType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyMessageEntityURL, kn) {
						currentKey = ffjtMessageEntityURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageEntityUser, kn) {
						currentKey = ffjtMessageEntityUser
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyMessageEntityUser, kn) {
					currentKey = ffjtMessageEntityUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageEntityLength, kn) {
					currentKey = ffjtMessageEntityLength
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageEntityOffset, kn) {
					currentKey = ffjtMessageEntityOffset
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageEntityURL, kn) {
					currentKey = ffjtMessageEntityURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageEntityType, kn) {
					currentKey = ffjtMessageEntityType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtMessageEntitynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtMessageEntityType:
					goto handle_Type

				case ffjtMessageEntityURL:
					goto handle_URL

				case ffjtMessageEntityOffset:
					goto handle_Offset

				case ffjtMessageEntityLength:
					goto handle_Length

				case ffjtMessageEntityUser:
					goto handle_User

				case ffjtMessageEntitynosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_URL:

	/* handler: j.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Offset:

	/* handler: j.Offset type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Offset = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Length:

	/* handler: j.Length type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Length = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_User:

	/* handler: j.User type=telegram.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.User = nil

		} else {

			if j.User == nil {
				j.User = new(User)
			}

			err = j.User.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *OrderInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *OrderInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Name) != 0 {
		buf.WriteString(`"name":`)
		fflib.WriteJsonString(buf, string(j.Name))
		buf.WriteByte(',')
	}
	if len(j.PhoneNumber) != 0 {
		buf.WriteString(`"phone_number":`)
		fflib.WriteJsonString(buf, string(j.PhoneNumber))
		buf.WriteByte(',')
	}
	if len(j.Email) != 0 {
		buf.WriteString(`"email":`)
		fflib.WriteJsonString(buf, string(j.Email))
		buf.WriteByte(',')
	}
	if j.ShippingAddress != nil {
		if true {
			buf.WriteString(`"shipping_address":`)

			{

				err = j.ShippingAddress.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtOrderInfobase = iota
	ffjtOrderInfonosuchkey

	ffjtOrderInfoName

	ffjtOrderInfoPhoneNumber

	ffjtOrderInfoEmail

	ffjtOrderInfoShippingAddress
)

var ffjKeyOrderInfoName = []byte("name")

var ffjKeyOrderInfoPhoneNumber = []byte("phone_number")

var ffjKeyOrderInfoEmail = []byte("email")

var ffjKeyOrderInfoShippingAddress = []byte("shipping_address")

// UnmarshalJSON umarshall json - template of ffjson
func (j *OrderInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *OrderInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtOrderInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtOrderInfonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffjKeyOrderInfoEmail, kn) {
						currentKey = ffjtOrderInfoEmail
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyOrderInfoName, kn) {
						currentKey = ffjtOrderInfoName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyOrderInfoPhoneNumber, kn) {
						currentKey = ffjtOrderInfoPhoneNumber
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyOrderInfoShippingAddress, kn) {
						currentKey = ffjtOrderInfoShippingAddress
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyOrderInfoShippingAddress, kn) {
					currentKey = ffjtOrderInfoShippingAddress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyOrderInfoEmail, kn) {
					currentKey = ffjtOrderInfoEmail
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOrderInfoPhoneNumber, kn) {
					currentKey = ffjtOrderInfoPhoneNumber
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyOrderInfoName, kn) {
					currentKey = ffjtOrderInfoName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtOrderInfonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtOrderInfoName:
					goto handle_Name

				case ffjtOrderInfoPhoneNumber:
					goto handle_PhoneNumber

				case ffjtOrderInfoEmail:
					goto handle_Email

				case ffjtOrderInfoShippingAddress:
					goto handle_ShippingAddress

				case ffjtOrderInfonosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PhoneNumber:

	/* handler: j.PhoneNumber type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PhoneNumber = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Email:

	/* handler: j.Email type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Email = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShippingAddress:

	/* handler: j.ShippingAddress type=telegram.ShippingAddress kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ShippingAddress = nil

		} else {

			if j.ShippingAddress == nil {
				j.ShippingAddress = new(ShippingAddress)
			}

			err = j.ShippingAddress.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Passport) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Passport) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	/* Inline struct. type=struct { Data *telegram.PersonalDetails "json:\"data\"" } kind=struct */
	if j.PersonalDetails.Data != nil {
		buf.WriteString(`{"personal_details":{ "data":`)

		{

			err = j.PersonalDetails.Data.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`{"personal_details":{ "data":null`)
	}
	buf.WriteByte('}')
	/* Inline struct. type=struct { Data *telegram.IDDocumentData "json:\"data\""; FrontSide *telegram.PassportFile "json:\"front_side\""; Selfie *telegram.PassportFile "json:\"selfie,omitempty\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct */
	if j.Passport.Data != nil {
		buf.WriteString(`,"passport":{ "data":`)

		{

			err = j.Passport.Data.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"passport":{ "data":null`)
	}
	if j.Passport.FrontSide != nil {
		buf.WriteString(`,"front_side":`)

		{

			err = j.Passport.FrontSide.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"front_side":null`)
	}
	buf.WriteByte(',')
	if j.Passport.Selfie != nil {
		if true {
			buf.WriteString(`"selfie":`)

			{

				err = j.Passport.Selfie.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.j.Passport.Translation) != 0 {
		buf.WriteString(`"translation":`)
		if j.Passport.Translation != nil {
			buf.WriteString(`[`)
			for i, v := range j.Passport.Translation {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	/* Inline struct. type=struct { Data *telegram.IDDocumentData "json:\"data\""; FrontSide *telegram.PassportFile "json:\"front_side\""; Selfie *telegram.PassportFile "json:\"selfie,omitempty\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct */
	if j.InternalPassport.Data != nil {
		buf.WriteString(`,"internal_passport":{ "data":`)

		{

			err = j.InternalPassport.Data.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"internal_passport":{ "data":null`)
	}
	if j.InternalPassport.FrontSide != nil {
		buf.WriteString(`,"front_side":`)

		{

			err = j.InternalPassport.FrontSide.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"front_side":null`)
	}
	buf.WriteByte(',')
	if j.InternalPassport.Selfie != nil {
		if true {
			buf.WriteString(`"selfie":`)

			{

				err = j.InternalPassport.Selfie.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.j.InternalPassport.Translation) != 0 {
		buf.WriteString(`"translation":`)
		if j.InternalPassport.Translation != nil {
			buf.WriteString(`[`)
			for i, v := range j.InternalPassport.Translation {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	/* Inline struct. type=struct { Data *telegram.IDDocumentData "json:\"data\""; FrontSide *telegram.PassportFile "json:\"front_side\""; ReverseSide *telegram.PassportFile "json:\"reverse_side\""; Selfie *telegram.PassportFile "json:\"selfie,omitempty\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct */
	if j.DriverLicense.Data != nil {
		buf.WriteString(`,"driver_license":{ "data":`)

		{

			err = j.DriverLicense.Data.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"driver_license":{ "data":null`)
	}
	if j.DriverLicense.FrontSide != nil {
		buf.WriteString(`,"front_side":`)

		{

			err = j.DriverLicense.FrontSide.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"front_side":null`)
	}
	if j.DriverLicense.ReverseSide != nil {
		buf.WriteString(`,"reverse_side":`)

		{

			err = j.DriverLicense.ReverseSide.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"reverse_side":null`)
	}
	buf.WriteByte(',')
	if j.DriverLicense.Selfie != nil {
		if true {
			buf.WriteString(`"selfie":`)

			{

				err = j.DriverLicense.Selfie.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.j.DriverLicense.Translation) != 0 {
		buf.WriteString(`"translation":`)
		if j.DriverLicense.Translation != nil {
			buf.WriteString(`[`)
			for i, v := range j.DriverLicense.Translation {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	/* Inline struct. type=struct { Data *telegram.IDDocumentData "json:\"data\""; FrontSide *telegram.PassportFile "json:\"front_side\""; ReverseSide *telegram.PassportFile "json:\"reverse_side\""; Selfie *telegram.PassportFile "json:\"selfie,omitempty\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct */
	if j.IdentityCard.Data != nil {
		buf.WriteString(`,"identity_card":{ "data":`)

		{

			err = j.IdentityCard.Data.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"identity_card":{ "data":null`)
	}
	if j.IdentityCard.FrontSide != nil {
		buf.WriteString(`,"front_side":`)

		{

			err = j.IdentityCard.FrontSide.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"front_side":null`)
	}
	if j.IdentityCard.ReverseSide != nil {
		buf.WriteString(`,"reverse_side":`)

		{

			err = j.IdentityCard.ReverseSide.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"reverse_side":null`)
	}
	buf.WriteByte(',')
	if j.IdentityCard.Selfie != nil {
		if true {
			buf.WriteString(`"selfie":`)

			{

				err = j.IdentityCard.Selfie.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.j.IdentityCard.Translation) != 0 {
		buf.WriteString(`"translation":`)
		if j.IdentityCard.Translation != nil {
			buf.WriteString(`[`)
			for i, v := range j.IdentityCard.Translation {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	/* Inline struct. type=struct { Data *telegram.ResidentialAddress "json:\"data\"" } kind=struct */
	if j.Address.Data != nil {
		buf.WriteString(`,"address":{ "data":`)

		{

			err = j.Address.Data.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"address":{ "data":null`)
	}
	buf.WriteByte('}')
	/* Inline struct. type=struct { Files []telegram.PassportFile "json:\"files\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct */
	buf.WriteString(`,"utility_bill":{ "files":`)
	if j.UtilityBill.Files != nil {
		buf.WriteString(`[`)
		for i, v := range j.UtilityBill.Files {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(j.j.UtilityBill.Translation) != 0 {
		buf.WriteString(`"translation":`)
		if j.UtilityBill.Translation != nil {
			buf.WriteString(`[`)
			for i, v := range j.UtilityBill.Translation {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	/* Inline struct. type=struct { Files []telegram.PassportFile "json:\"files\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct */
	buf.WriteString(`,"bank_statement":{ "files":`)
	if j.BankStatement.Files != nil {
		buf.WriteString(`[`)
		for i, v := range j.BankStatement.Files {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(j.j.BankStatement.Translation) != 0 {
		buf.WriteString(`"translation":`)
		if j.BankStatement.Translation != nil {
			buf.WriteString(`[`)
			for i, v := range j.BankStatement.Translation {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	/* Inline struct. type=struct { Files []telegram.PassportFile "json:\"files\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct */
	buf.WriteString(`,"rental_agreement":{ "files":`)
	if j.RentalAgreement.Files != nil {
		buf.WriteString(`[`)
		for i, v := range j.RentalAgreement.Files {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(j.j.RentalAgreement.Translation) != 0 {
		buf.WriteString(`"translation":`)
		if j.RentalAgreement.Translation != nil {
			buf.WriteString(`[`)
			for i, v := range j.RentalAgreement.Translation {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	/* Inline struct. type=struct { Files []telegram.PassportFile "json:\"files\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct */
	buf.WriteString(`,"passport_registration":{ "files":`)
	if j.PassportRegistration.Files != nil {
		buf.WriteString(`[`)
		for i, v := range j.PassportRegistration.Files {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(j.j.PassportRegistration.Translation) != 0 {
		buf.WriteString(`"translation":`)
		if j.PassportRegistration.Translation != nil {
			buf.WriteString(`[`)
			for i, v := range j.PassportRegistration.Translation {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	/* Inline struct. type=struct { Files []telegram.PassportFile "json:\"files\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct */
	buf.WriteString(`,"temporary_registration":{ "files":`)
	if j.TemporaryRegistration.Files != nil {
		buf.WriteString(`[`)
		for i, v := range j.TemporaryRegistration.Files {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(j.j.TemporaryRegistration.Translation) != 0 {
		buf.WriteString(`"translation":`)
		if j.TemporaryRegistration.Translation != nil {
			buf.WriteString(`[`)
			for i, v := range j.TemporaryRegistration.Translation {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	buf.WriteString(`,"phone_number":`)
	fflib.WriteJsonString(buf, string(j.PhoneNumber))
	buf.WriteString(`,"email":`)
	fflib.WriteJsonString(buf, string(j.Email))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPassportbase = iota
	ffjtPassportnosuchkey

	ffjtPassportPersonalDetails

	ffjtPassportPassport

	ffjtPassportInternalPassport

	ffjtPassportDriverLicense

	ffjtPassportIdentityCard

	ffjtPassportAddress

	ffjtPassportUtilityBill

	ffjtPassportBankStatement

	ffjtPassportRentalAgreement

	ffjtPassportPassportRegistration

	ffjtPassportTemporaryRegistration

	ffjtPassportPhoneNumber

	ffjtPassportEmail
)

var ffjKeyPassportPersonalDetails = []byte("personal_details")

var ffjKeyPassportPassport = []byte("passport")

var ffjKeyPassportInternalPassport = []byte("internal_passport")

var ffjKeyPassportDriverLicense = []byte("driver_license")

var ffjKeyPassportIdentityCard = []byte("identity_card")

var ffjKeyPassportAddress = []byte("address")

var ffjKeyPassportUtilityBill = []byte("utility_bill")

var ffjKeyPassportBankStatement = []byte("bank_statement")

var ffjKeyPassportRentalAgreement = []byte("rental_agreement")

var ffjKeyPassportPassportRegistration = []byte("passport_registration")

var ffjKeyPassportTemporaryRegistration = []byte("temporary_registration")

var ffjKeyPassportPhoneNumber = []byte("phone_number")

var ffjKeyPassportEmail = []byte("email")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Passport) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Passport) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPassportbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPassportnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyPassportAddress, kn) {
						currentKey = ffjtPassportAddress
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffjKeyPassportBankStatement, kn) {
						currentKey = ffjtPassportBankStatement
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyPassportDriverLicense, kn) {
						currentKey = ffjtPassportDriverLicense
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyPassportEmail, kn) {
						currentKey = ffjtPassportEmail
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyPassportInternalPassport, kn) {
						currentKey = ffjtPassportInternalPassport
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPassportIdentityCard, kn) {
						currentKey = ffjtPassportIdentityCard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyPassportPersonalDetails, kn) {
						currentKey = ffjtPassportPersonalDetails
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPassportPassport, kn) {
						currentKey = ffjtPassportPassport
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPassportPassportRegistration, kn) {
						currentKey = ffjtPassportPassportRegistration
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPassportPhoneNumber, kn) {
						currentKey = ffjtPassportPhoneNumber
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyPassportRentalAgreement, kn) {
						currentKey = ffjtPassportRentalAgreement
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyPassportTemporaryRegistration, kn) {
						currentKey = ffjtPassportTemporaryRegistration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyPassportUtilityBill, kn) {
						currentKey = ffjtPassportUtilityBill
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyPassportEmail, kn) {
					currentKey = ffjtPassportEmail
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPassportPhoneNumber, kn) {
					currentKey = ffjtPassportPhoneNumber
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportTemporaryRegistration, kn) {
					currentKey = ffjtPassportTemporaryRegistration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportPassportRegistration, kn) {
					currentKey = ffjtPassportPassportRegistration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPassportRentalAgreement, kn) {
					currentKey = ffjtPassportRentalAgreement
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportBankStatement, kn) {
					currentKey = ffjtPassportBankStatement
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPassportUtilityBill, kn) {
					currentKey = ffjtPassportUtilityBill
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportAddress, kn) {
					currentKey = ffjtPassportAddress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPassportIdentityCard, kn) {
					currentKey = ffjtPassportIdentityCard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportDriverLicense, kn) {
					currentKey = ffjtPassportDriverLicense
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportInternalPassport, kn) {
					currentKey = ffjtPassportInternalPassport
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportPassport, kn) {
					currentKey = ffjtPassportPassport
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportPersonalDetails, kn) {
					currentKey = ffjtPassportPersonalDetails
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPassportnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPassportPersonalDetails:
					goto handle_PersonalDetails

				case ffjtPassportPassport:
					goto handle_Passport

				case ffjtPassportInternalPassport:
					goto handle_InternalPassport

				case ffjtPassportDriverLicense:
					goto handle_DriverLicense

				case ffjtPassportIdentityCard:
					goto handle_IdentityCard

				case ffjtPassportAddress:
					goto handle_Address

				case ffjtPassportUtilityBill:
					goto handle_UtilityBill

				case ffjtPassportBankStatement:
					goto handle_BankStatement

				case ffjtPassportRentalAgreement:
					goto handle_RentalAgreement

				case ffjtPassportPassportRegistration:
					goto handle_PassportRegistration

				case ffjtPassportTemporaryRegistration:
					goto handle_TemporaryRegistration

				case ffjtPassportPhoneNumber:
					goto handle_PhoneNumber

				case ffjtPassportEmail:
					goto handle_Email

				case ffjtPassportnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_PersonalDetails:

	/* handler: j.PersonalDetails type=struct { Data *telegram.PersonalDetails "json:\"data\"" } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { Data *telegram.PersonalDetails "json:\"data\"" } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.PersonalDetails)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Passport:

	/* handler: j.Passport type=struct { Data *telegram.IDDocumentData "json:\"data\""; FrontSide *telegram.PassportFile "json:\"front_side\""; Selfie *telegram.PassportFile "json:\"selfie,omitempty\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { Data *telegram.IDDocumentData "json:\"data\""; FrontSide *telegram.PassportFile "json:\"front_side\""; Selfie *telegram.PassportFile "json:\"selfie,omitempty\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Passport)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InternalPassport:

	/* handler: j.InternalPassport type=struct { Data *telegram.IDDocumentData "json:\"data\""; FrontSide *telegram.PassportFile "json:\"front_side\""; Selfie *telegram.PassportFile "json:\"selfie,omitempty\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { Data *telegram.IDDocumentData "json:\"data\""; FrontSide *telegram.PassportFile "json:\"front_side\""; Selfie *telegram.PassportFile "json:\"selfie,omitempty\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InternalPassport)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DriverLicense:

	/* handler: j.DriverLicense type=struct { Data *telegram.IDDocumentData "json:\"data\""; FrontSide *telegram.PassportFile "json:\"front_side\""; ReverseSide *telegram.PassportFile "json:\"reverse_side\""; Selfie *telegram.PassportFile "json:\"selfie,omitempty\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { Data *telegram.IDDocumentData "json:\"data\""; FrontSide *telegram.PassportFile "json:\"front_side\""; ReverseSide *telegram.PassportFile "json:\"reverse_side\""; Selfie *telegram.PassportFile "json:\"selfie,omitempty\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.DriverLicense)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IdentityCard:

	/* handler: j.IdentityCard type=struct { Data *telegram.IDDocumentData "json:\"data\""; FrontSide *telegram.PassportFile "json:\"front_side\""; ReverseSide *telegram.PassportFile "json:\"reverse_side\""; Selfie *telegram.PassportFile "json:\"selfie,omitempty\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { Data *telegram.IDDocumentData "json:\"data\""; FrontSide *telegram.PassportFile "json:\"front_side\""; ReverseSide *telegram.PassportFile "json:\"reverse_side\""; Selfie *telegram.PassportFile "json:\"selfie,omitempty\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.IdentityCard)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Address:

	/* handler: j.Address type=struct { Data *telegram.ResidentialAddress "json:\"data\"" } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { Data *telegram.ResidentialAddress "json:\"data\"" } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Address)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UtilityBill:

	/* handler: j.UtilityBill type=struct { Files []telegram.PassportFile "json:\"files\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { Files []telegram.PassportFile "json:\"files\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.UtilityBill)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BankStatement:

	/* handler: j.BankStatement type=struct { Files []telegram.PassportFile "json:\"files\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { Files []telegram.PassportFile "json:\"files\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.BankStatement)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RentalAgreement:

	/* handler: j.RentalAgreement type=struct { Files []telegram.PassportFile "json:\"files\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { Files []telegram.PassportFile "json:\"files\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.RentalAgreement)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PassportRegistration:

	/* handler: j.PassportRegistration type=struct { Files []telegram.PassportFile "json:\"files\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { Files []telegram.PassportFile "json:\"files\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.PassportRegistration)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TemporaryRegistration:

	/* handler: j.TemporaryRegistration type=struct { Files []telegram.PassportFile "json:\"files\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { Files []telegram.PassportFile "json:\"files\""; Translation []telegram.PassportFile "json:\"translation,omitempty\"" } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.TemporaryRegistration)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PhoneNumber:

	/* handler: j.PhoneNumber type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PhoneNumber = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Email:

	/* handler: j.Email type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Email = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PassportData) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PassportData) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"data":`)
	if j.Data != nil {
		buf.WriteString(`[`)
		for i, v := range j.Data {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	if j.Credentials != nil {
		buf.WriteString(`,"credentials":`)

		{

			err = j.Credentials.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"credentials":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPassportDatabase = iota
	ffjtPassportDatanosuchkey

	ffjtPassportDataData

	ffjtPassportDataCredentials
)

var ffjKeyPassportDataData = []byte("data")

var ffjKeyPassportDataCredentials = []byte("credentials")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PassportData) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PassportData) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPassportDatabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPassportDatanosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyPassportDataCredentials, kn) {
						currentKey = ffjtPassportDataCredentials
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyPassportDataData, kn) {
						currentKey = ffjtPassportDataData
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyPassportDataCredentials, kn) {
					currentKey = ffjtPassportDataCredentials
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPassportDataData, kn) {
					currentKey = ffjtPassportDataData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPassportDatanosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPassportDataData:
					goto handle_Data

				case ffjtPassportDataCredentials:
					goto handle_Credentials

				case ffjtPassportDatanosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Data:

	/* handler: j.Data type=[]telegram.EncryptedPassportElement kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Data = nil
		} else {

			j.Data = []EncryptedPassportElement{}

			wantVal := true

			for {

				var tmpJData EncryptedPassportElement

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJData type=telegram.EncryptedPassportElement kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJData.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Data = append(j.Data, tmpJData)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Credentials:

	/* handler: j.Credentials type=telegram.EncryptedCredentials kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Credentials = nil

		} else {

			if j.Credentials == nil {
				j.Credentials = new(EncryptedCredentials)
			}

			err = j.Credentials.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PassportElementErrorDataField) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PassportElementErrorDataField) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"source":`)
	fflib.WriteJsonString(buf, string(j.Source))
	buf.WriteString(`,"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"field_name":`)
	fflib.WriteJsonString(buf, string(j.FieldName))
	buf.WriteString(`,"data_hash":`)
	fflib.WriteJsonString(buf, string(j.DataHash))
	buf.WriteString(`,"message":`)
	fflib.WriteJsonString(buf, string(j.Message))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPassportElementErrorDataFieldbase = iota
	ffjtPassportElementErrorDataFieldnosuchkey

	ffjtPassportElementErrorDataFieldSource

	ffjtPassportElementErrorDataFieldType

	ffjtPassportElementErrorDataFieldFieldName

	ffjtPassportElementErrorDataFieldDataHash

	ffjtPassportElementErrorDataFieldMessage
)

var ffjKeyPassportElementErrorDataFieldSource = []byte("source")

var ffjKeyPassportElementErrorDataFieldType = []byte("type")

var ffjKeyPassportElementErrorDataFieldFieldName = []byte("field_name")

var ffjKeyPassportElementErrorDataFieldDataHash = []byte("data_hash")

var ffjKeyPassportElementErrorDataFieldMessage = []byte("message")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PassportElementErrorDataField) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PassportElementErrorDataField) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPassportElementErrorDataFieldbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPassportElementErrorDataFieldnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyPassportElementErrorDataFieldDataHash, kn) {
						currentKey = ffjtPassportElementErrorDataFieldDataHash
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyPassportElementErrorDataFieldFieldName, kn) {
						currentKey = ffjtPassportElementErrorDataFieldFieldName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyPassportElementErrorDataFieldMessage, kn) {
						currentKey = ffjtPassportElementErrorDataFieldMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyPassportElementErrorDataFieldSource, kn) {
						currentKey = ffjtPassportElementErrorDataFieldSource
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyPassportElementErrorDataFieldType, kn) {
						currentKey = ffjtPassportElementErrorDataFieldType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorDataFieldMessage, kn) {
					currentKey = ffjtPassportElementErrorDataFieldMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorDataFieldDataHash, kn) {
					currentKey = ffjtPassportElementErrorDataFieldDataHash
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPassportElementErrorDataFieldFieldName, kn) {
					currentKey = ffjtPassportElementErrorDataFieldFieldName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPassportElementErrorDataFieldType, kn) {
					currentKey = ffjtPassportElementErrorDataFieldType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorDataFieldSource, kn) {
					currentKey = ffjtPassportElementErrorDataFieldSource
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPassportElementErrorDataFieldnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPassportElementErrorDataFieldSource:
					goto handle_Source

				case ffjtPassportElementErrorDataFieldType:
					goto handle_Type

				case ffjtPassportElementErrorDataFieldFieldName:
					goto handle_FieldName

				case ffjtPassportElementErrorDataFieldDataHash:
					goto handle_DataHash

				case ffjtPassportElementErrorDataFieldMessage:
					goto handle_Message

				case ffjtPassportElementErrorDataFieldnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Source:

	/* handler: j.Source type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Source = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FieldName:

	/* handler: j.FieldName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FieldName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DataHash:

	/* handler: j.DataHash type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.DataHash = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: j.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PassportElementErrorFile) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PassportElementErrorFile) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"source":`)
	fflib.WriteJsonString(buf, string(j.Source))
	buf.WriteString(`,"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"file_hash":`)
	fflib.WriteJsonString(buf, string(j.FileHash))
	buf.WriteString(`,"message":`)
	fflib.WriteJsonString(buf, string(j.Message))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPassportElementErrorFilebase = iota
	ffjtPassportElementErrorFilenosuchkey

	ffjtPassportElementErrorFileSource

	ffjtPassportElementErrorFileType

	ffjtPassportElementErrorFileFileHash

	ffjtPassportElementErrorFileMessage
)

var ffjKeyPassportElementErrorFileSource = []byte("source")

var ffjKeyPassportElementErrorFileType = []byte("type")

var ffjKeyPassportElementErrorFileFileHash = []byte("file_hash")

var ffjKeyPassportElementErrorFileMessage = []byte("message")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PassportElementErrorFile) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PassportElementErrorFile) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPassportElementErrorFilebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPassportElementErrorFilenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyPassportElementErrorFileFileHash, kn) {
						currentKey = ffjtPassportElementErrorFileFileHash
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyPassportElementErrorFileMessage, kn) {
						currentKey = ffjtPassportElementErrorFileMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyPassportElementErrorFileSource, kn) {
						currentKey = ffjtPassportElementErrorFileSource
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyPassportElementErrorFileType, kn) {
						currentKey = ffjtPassportElementErrorFileType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorFileMessage, kn) {
					currentKey = ffjtPassportElementErrorFileMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorFileFileHash, kn) {
					currentKey = ffjtPassportElementErrorFileFileHash
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPassportElementErrorFileType, kn) {
					currentKey = ffjtPassportElementErrorFileType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorFileSource, kn) {
					currentKey = ffjtPassportElementErrorFileSource
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPassportElementErrorFilenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPassportElementErrorFileSource:
					goto handle_Source

				case ffjtPassportElementErrorFileType:
					goto handle_Type

				case ffjtPassportElementErrorFileFileHash:
					goto handle_FileHash

				case ffjtPassportElementErrorFileMessage:
					goto handle_Message

				case ffjtPassportElementErrorFilenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Source:

	/* handler: j.Source type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Source = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileHash:

	/* handler: j.FileHash type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileHash = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: j.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PassportElementErrorFiles) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PassportElementErrorFiles) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"source":`)
	fflib.WriteJsonString(buf, string(j.Source))
	buf.WriteString(`,"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"file_hashes":`)
	if j.FileHashes != nil {
		buf.WriteString(`[`)
		for i, v := range j.FileHashes {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"message":`)
	fflib.WriteJsonString(buf, string(j.Message))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPassportElementErrorFilesbase = iota
	ffjtPassportElementErrorFilesnosuchkey

	ffjtPassportElementErrorFilesSource

	ffjtPassportElementErrorFilesType

	ffjtPassportElementErrorFilesFileHashes

	ffjtPassportElementErrorFilesMessage
)

var ffjKeyPassportElementErrorFilesSource = []byte("source")

var ffjKeyPassportElementErrorFilesType = []byte("type")

var ffjKeyPassportElementErrorFilesFileHashes = []byte("file_hashes")

var ffjKeyPassportElementErrorFilesMessage = []byte("message")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PassportElementErrorFiles) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PassportElementErrorFiles) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPassportElementErrorFilesbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPassportElementErrorFilesnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyPassportElementErrorFilesFileHashes, kn) {
						currentKey = ffjtPassportElementErrorFilesFileHashes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyPassportElementErrorFilesMessage, kn) {
						currentKey = ffjtPassportElementErrorFilesMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyPassportElementErrorFilesSource, kn) {
						currentKey = ffjtPassportElementErrorFilesSource
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyPassportElementErrorFilesType, kn) {
						currentKey = ffjtPassportElementErrorFilesType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorFilesMessage, kn) {
					currentKey = ffjtPassportElementErrorFilesMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorFilesFileHashes, kn) {
					currentKey = ffjtPassportElementErrorFilesFileHashes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPassportElementErrorFilesType, kn) {
					currentKey = ffjtPassportElementErrorFilesType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorFilesSource, kn) {
					currentKey = ffjtPassportElementErrorFilesSource
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPassportElementErrorFilesnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPassportElementErrorFilesSource:
					goto handle_Source

				case ffjtPassportElementErrorFilesType:
					goto handle_Type

				case ffjtPassportElementErrorFilesFileHashes:
					goto handle_FileHashes

				case ffjtPassportElementErrorFilesMessage:
					goto handle_Message

				case ffjtPassportElementErrorFilesnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Source:

	/* handler: j.Source type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Source = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileHashes:

	/* handler: j.FileHashes type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.FileHashes = nil
		} else {

			j.FileHashes = []string{}

			wantVal := true

			for {

				var tmpJFileHashes string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJFileHashes type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJFileHashes = string(string(outBuf))

					}
				}

				j.FileHashes = append(j.FileHashes, tmpJFileHashes)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: j.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PassportElementErrorFrontSide) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PassportElementErrorFrontSide) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"source":`)
	fflib.WriteJsonString(buf, string(j.Source))
	buf.WriteString(`,"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"file_hash":`)
	fflib.WriteJsonString(buf, string(j.FileHash))
	buf.WriteString(`,"message":`)
	fflib.WriteJsonString(buf, string(j.Message))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPassportElementErrorFrontSidebase = iota
	ffjtPassportElementErrorFrontSidenosuchkey

	ffjtPassportElementErrorFrontSideSource

	ffjtPassportElementErrorFrontSideType

	ffjtPassportElementErrorFrontSideFileHash

	ffjtPassportElementErrorFrontSideMessage
)

var ffjKeyPassportElementErrorFrontSideSource = []byte("source")

var ffjKeyPassportElementErrorFrontSideType = []byte("type")

var ffjKeyPassportElementErrorFrontSideFileHash = []byte("file_hash")

var ffjKeyPassportElementErrorFrontSideMessage = []byte("message")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PassportElementErrorFrontSide) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PassportElementErrorFrontSide) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPassportElementErrorFrontSidebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPassportElementErrorFrontSidenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyPassportElementErrorFrontSideFileHash, kn) {
						currentKey = ffjtPassportElementErrorFrontSideFileHash
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyPassportElementErrorFrontSideMessage, kn) {
						currentKey = ffjtPassportElementErrorFrontSideMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyPassportElementErrorFrontSideSource, kn) {
						currentKey = ffjtPassportElementErrorFrontSideSource
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyPassportElementErrorFrontSideType, kn) {
						currentKey = ffjtPassportElementErrorFrontSideType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorFrontSideMessage, kn) {
					currentKey = ffjtPassportElementErrorFrontSideMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorFrontSideFileHash, kn) {
					currentKey = ffjtPassportElementErrorFrontSideFileHash
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPassportElementErrorFrontSideType, kn) {
					currentKey = ffjtPassportElementErrorFrontSideType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorFrontSideSource, kn) {
					currentKey = ffjtPassportElementErrorFrontSideSource
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPassportElementErrorFrontSidenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPassportElementErrorFrontSideSource:
					goto handle_Source

				case ffjtPassportElementErrorFrontSideType:
					goto handle_Type

				case ffjtPassportElementErrorFrontSideFileHash:
					goto handle_FileHash

				case ffjtPassportElementErrorFrontSideMessage:
					goto handle_Message

				case ffjtPassportElementErrorFrontSidenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Source:

	/* handler: j.Source type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Source = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileHash:

	/* handler: j.FileHash type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileHash = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: j.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PassportElementErrorReverseSide) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PassportElementErrorReverseSide) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"source":`)
	fflib.WriteJsonString(buf, string(j.Source))
	buf.WriteString(`,"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"file_hash":`)
	fflib.WriteJsonString(buf, string(j.FileHash))
	buf.WriteString(`,"message":`)
	fflib.WriteJsonString(buf, string(j.Message))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPassportElementErrorReverseSidebase = iota
	ffjtPassportElementErrorReverseSidenosuchkey

	ffjtPassportElementErrorReverseSideSource

	ffjtPassportElementErrorReverseSideType

	ffjtPassportElementErrorReverseSideFileHash

	ffjtPassportElementErrorReverseSideMessage
)

var ffjKeyPassportElementErrorReverseSideSource = []byte("source")

var ffjKeyPassportElementErrorReverseSideType = []byte("type")

var ffjKeyPassportElementErrorReverseSideFileHash = []byte("file_hash")

var ffjKeyPassportElementErrorReverseSideMessage = []byte("message")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PassportElementErrorReverseSide) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PassportElementErrorReverseSide) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPassportElementErrorReverseSidebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPassportElementErrorReverseSidenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyPassportElementErrorReverseSideFileHash, kn) {
						currentKey = ffjtPassportElementErrorReverseSideFileHash
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyPassportElementErrorReverseSideMessage, kn) {
						currentKey = ffjtPassportElementErrorReverseSideMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyPassportElementErrorReverseSideSource, kn) {
						currentKey = ffjtPassportElementErrorReverseSideSource
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyPassportElementErrorReverseSideType, kn) {
						currentKey = ffjtPassportElementErrorReverseSideType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorReverseSideMessage, kn) {
					currentKey = ffjtPassportElementErrorReverseSideMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorReverseSideFileHash, kn) {
					currentKey = ffjtPassportElementErrorReverseSideFileHash
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPassportElementErrorReverseSideType, kn) {
					currentKey = ffjtPassportElementErrorReverseSideType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorReverseSideSource, kn) {
					currentKey = ffjtPassportElementErrorReverseSideSource
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPassportElementErrorReverseSidenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPassportElementErrorReverseSideSource:
					goto handle_Source

				case ffjtPassportElementErrorReverseSideType:
					goto handle_Type

				case ffjtPassportElementErrorReverseSideFileHash:
					goto handle_FileHash

				case ffjtPassportElementErrorReverseSideMessage:
					goto handle_Message

				case ffjtPassportElementErrorReverseSidenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Source:

	/* handler: j.Source type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Source = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileHash:

	/* handler: j.FileHash type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileHash = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: j.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PassportElementErrorSelfie) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PassportElementErrorSelfie) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"source":`)
	fflib.WriteJsonString(buf, string(j.Source))
	buf.WriteString(`,"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"file_hash":`)
	fflib.WriteJsonString(buf, string(j.FileHash))
	buf.WriteString(`,"message":`)
	fflib.WriteJsonString(buf, string(j.Message))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPassportElementErrorSelfiebase = iota
	ffjtPassportElementErrorSelfienosuchkey

	ffjtPassportElementErrorSelfieSource

	ffjtPassportElementErrorSelfieType

	ffjtPassportElementErrorSelfieFileHash

	ffjtPassportElementErrorSelfieMessage
)

var ffjKeyPassportElementErrorSelfieSource = []byte("source")

var ffjKeyPassportElementErrorSelfieType = []byte("type")

var ffjKeyPassportElementErrorSelfieFileHash = []byte("file_hash")

var ffjKeyPassportElementErrorSelfieMessage = []byte("message")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PassportElementErrorSelfie) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PassportElementErrorSelfie) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPassportElementErrorSelfiebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPassportElementErrorSelfienosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyPassportElementErrorSelfieFileHash, kn) {
						currentKey = ffjtPassportElementErrorSelfieFileHash
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyPassportElementErrorSelfieMessage, kn) {
						currentKey = ffjtPassportElementErrorSelfieMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyPassportElementErrorSelfieSource, kn) {
						currentKey = ffjtPassportElementErrorSelfieSource
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyPassportElementErrorSelfieType, kn) {
						currentKey = ffjtPassportElementErrorSelfieType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorSelfieMessage, kn) {
					currentKey = ffjtPassportElementErrorSelfieMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorSelfieFileHash, kn) {
					currentKey = ffjtPassportElementErrorSelfieFileHash
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPassportElementErrorSelfieType, kn) {
					currentKey = ffjtPassportElementErrorSelfieType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorSelfieSource, kn) {
					currentKey = ffjtPassportElementErrorSelfieSource
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPassportElementErrorSelfienosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPassportElementErrorSelfieSource:
					goto handle_Source

				case ffjtPassportElementErrorSelfieType:
					goto handle_Type

				case ffjtPassportElementErrorSelfieFileHash:
					goto handle_FileHash

				case ffjtPassportElementErrorSelfieMessage:
					goto handle_Message

				case ffjtPassportElementErrorSelfienosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Source:

	/* handler: j.Source type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Source = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileHash:

	/* handler: j.FileHash type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileHash = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: j.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PassportElementErrorTranslationFile) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PassportElementErrorTranslationFile) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"source":`)
	fflib.WriteJsonString(buf, string(j.Source))
	buf.WriteString(`,"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"file_hash":`)
	fflib.WriteJsonString(buf, string(j.FileHash))
	buf.WriteString(`,"message":`)
	fflib.WriteJsonString(buf, string(j.Message))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPassportElementErrorTranslationFilebase = iota
	ffjtPassportElementErrorTranslationFilenosuchkey

	ffjtPassportElementErrorTranslationFileSource

	ffjtPassportElementErrorTranslationFileType

	ffjtPassportElementErrorTranslationFileFileHash

	ffjtPassportElementErrorTranslationFileMessage
)

var ffjKeyPassportElementErrorTranslationFileSource = []byte("source")

var ffjKeyPassportElementErrorTranslationFileType = []byte("type")

var ffjKeyPassportElementErrorTranslationFileFileHash = []byte("file_hash")

var ffjKeyPassportElementErrorTranslationFileMessage = []byte("message")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PassportElementErrorTranslationFile) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PassportElementErrorTranslationFile) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPassportElementErrorTranslationFilebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPassportElementErrorTranslationFilenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyPassportElementErrorTranslationFileFileHash, kn) {
						currentKey = ffjtPassportElementErrorTranslationFileFileHash
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyPassportElementErrorTranslationFileMessage, kn) {
						currentKey = ffjtPassportElementErrorTranslationFileMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyPassportElementErrorTranslationFileSource, kn) {
						currentKey = ffjtPassportElementErrorTranslationFileSource
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyPassportElementErrorTranslationFileType, kn) {
						currentKey = ffjtPassportElementErrorTranslationFileType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorTranslationFileMessage, kn) {
					currentKey = ffjtPassportElementErrorTranslationFileMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorTranslationFileFileHash, kn) {
					currentKey = ffjtPassportElementErrorTranslationFileFileHash
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPassportElementErrorTranslationFileType, kn) {
					currentKey = ffjtPassportElementErrorTranslationFileType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorTranslationFileSource, kn) {
					currentKey = ffjtPassportElementErrorTranslationFileSource
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPassportElementErrorTranslationFilenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPassportElementErrorTranslationFileSource:
					goto handle_Source

				case ffjtPassportElementErrorTranslationFileType:
					goto handle_Type

				case ffjtPassportElementErrorTranslationFileFileHash:
					goto handle_FileHash

				case ffjtPassportElementErrorTranslationFileMessage:
					goto handle_Message

				case ffjtPassportElementErrorTranslationFilenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Source:

	/* handler: j.Source type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Source = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileHash:

	/* handler: j.FileHash type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileHash = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: j.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PassportElementErrorTranslationFiles) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PassportElementErrorTranslationFiles) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"source":`)
	fflib.WriteJsonString(buf, string(j.Source))
	buf.WriteString(`,"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"file_hashes":`)
	if j.FileHashes != nil {
		buf.WriteString(`[`)
		for i, v := range j.FileHashes {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"message":`)
	fflib.WriteJsonString(buf, string(j.Message))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPassportElementErrorTranslationFilesbase = iota
	ffjtPassportElementErrorTranslationFilesnosuchkey

	ffjtPassportElementErrorTranslationFilesSource

	ffjtPassportElementErrorTranslationFilesType

	ffjtPassportElementErrorTranslationFilesFileHashes

	ffjtPassportElementErrorTranslationFilesMessage
)

var ffjKeyPassportElementErrorTranslationFilesSource = []byte("source")

var ffjKeyPassportElementErrorTranslationFilesType = []byte("type")

var ffjKeyPassportElementErrorTranslationFilesFileHashes = []byte("file_hashes")

var ffjKeyPassportElementErrorTranslationFilesMessage = []byte("message")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PassportElementErrorTranslationFiles) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PassportElementErrorTranslationFiles) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPassportElementErrorTranslationFilesbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPassportElementErrorTranslationFilesnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyPassportElementErrorTranslationFilesFileHashes, kn) {
						currentKey = ffjtPassportElementErrorTranslationFilesFileHashes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyPassportElementErrorTranslationFilesMessage, kn) {
						currentKey = ffjtPassportElementErrorTranslationFilesMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyPassportElementErrorTranslationFilesSource, kn) {
						currentKey = ffjtPassportElementErrorTranslationFilesSource
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyPassportElementErrorTranslationFilesType, kn) {
						currentKey = ffjtPassportElementErrorTranslationFilesType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorTranslationFilesMessage, kn) {
					currentKey = ffjtPassportElementErrorTranslationFilesMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorTranslationFilesFileHashes, kn) {
					currentKey = ffjtPassportElementErrorTranslationFilesFileHashes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPassportElementErrorTranslationFilesType, kn) {
					currentKey = ffjtPassportElementErrorTranslationFilesType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorTranslationFilesSource, kn) {
					currentKey = ffjtPassportElementErrorTranslationFilesSource
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPassportElementErrorTranslationFilesnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPassportElementErrorTranslationFilesSource:
					goto handle_Source

				case ffjtPassportElementErrorTranslationFilesType:
					goto handle_Type

				case ffjtPassportElementErrorTranslationFilesFileHashes:
					goto handle_FileHashes

				case ffjtPassportElementErrorTranslationFilesMessage:
					goto handle_Message

				case ffjtPassportElementErrorTranslationFilesnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Source:

	/* handler: j.Source type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Source = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileHashes:

	/* handler: j.FileHashes type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.FileHashes = nil
		} else {

			j.FileHashes = []string{}

			wantVal := true

			for {

				var tmpJFileHashes string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJFileHashes type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJFileHashes = string(string(outBuf))

					}
				}

				j.FileHashes = append(j.FileHashes, tmpJFileHashes)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: j.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PassportElementErrorUnspecified) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PassportElementErrorUnspecified) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"source":`)
	fflib.WriteJsonString(buf, string(j.Source))
	buf.WriteString(`,"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"element_hash":`)
	fflib.WriteJsonString(buf, string(j.ElementHash))
	buf.WriteString(`,"message":`)
	fflib.WriteJsonString(buf, string(j.Message))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPassportElementErrorUnspecifiedbase = iota
	ffjtPassportElementErrorUnspecifiednosuchkey

	ffjtPassportElementErrorUnspecifiedSource

	ffjtPassportElementErrorUnspecifiedType

	ffjtPassportElementErrorUnspecifiedElementHash

	ffjtPassportElementErrorUnspecifiedMessage
)

var ffjKeyPassportElementErrorUnspecifiedSource = []byte("source")

var ffjKeyPassportElementErrorUnspecifiedType = []byte("type")

var ffjKeyPassportElementErrorUnspecifiedElementHash = []byte("element_hash")

var ffjKeyPassportElementErrorUnspecifiedMessage = []byte("message")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PassportElementErrorUnspecified) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PassportElementErrorUnspecified) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPassportElementErrorUnspecifiedbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPassportElementErrorUnspecifiednosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffjKeyPassportElementErrorUnspecifiedElementHash, kn) {
						currentKey = ffjtPassportElementErrorUnspecifiedElementHash
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyPassportElementErrorUnspecifiedMessage, kn) {
						currentKey = ffjtPassportElementErrorUnspecifiedMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyPassportElementErrorUnspecifiedSource, kn) {
						currentKey = ffjtPassportElementErrorUnspecifiedSource
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyPassportElementErrorUnspecifiedType, kn) {
						currentKey = ffjtPassportElementErrorUnspecifiedType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorUnspecifiedMessage, kn) {
					currentKey = ffjtPassportElementErrorUnspecifiedMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorUnspecifiedElementHash, kn) {
					currentKey = ffjtPassportElementErrorUnspecifiedElementHash
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPassportElementErrorUnspecifiedType, kn) {
					currentKey = ffjtPassportElementErrorUnspecifiedType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportElementErrorUnspecifiedSource, kn) {
					currentKey = ffjtPassportElementErrorUnspecifiedSource
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPassportElementErrorUnspecifiednosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPassportElementErrorUnspecifiedSource:
					goto handle_Source

				case ffjtPassportElementErrorUnspecifiedType:
					goto handle_Type

				case ffjtPassportElementErrorUnspecifiedElementHash:
					goto handle_ElementHash

				case ffjtPassportElementErrorUnspecifiedMessage:
					goto handle_Message

				case ffjtPassportElementErrorUnspecifiednosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Source:

	/* handler: j.Source type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Source = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ElementHash:

	/* handler: j.ElementHash type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ElementHash = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: j.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PassportFile) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PassportFile) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"file_id":`)
	fflib.WriteJsonString(buf, string(j.FileID))
	buf.WriteString(`,"file_size":`)
	fflib.FormatBits2(buf, uint64(j.FileSize), 10, j.FileSize < 0)
	buf.WriteString(`,"file_date":`)
	fflib.FormatBits2(buf, uint64(j.FileDate), 10, j.FileDate < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPassportFilebase = iota
	ffjtPassportFilenosuchkey

	ffjtPassportFileFileID

	ffjtPassportFileFileSize

	ffjtPassportFileFileDate
)

var ffjKeyPassportFileFileID = []byte("file_id")

var ffjKeyPassportFileFileSize = []byte("file_size")

var ffjKeyPassportFileFileDate = []byte("file_date")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PassportFile) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PassportFile) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPassportFilebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPassportFilenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyPassportFileFileID, kn) {
						currentKey = ffjtPassportFileFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPassportFileFileSize, kn) {
						currentKey = ffjtPassportFileFileSize
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPassportFileFileDate, kn) {
						currentKey = ffjtPassportFileFileDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyPassportFileFileDate, kn) {
					currentKey = ffjtPassportFileFileDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportFileFileSize, kn) {
					currentKey = ffjtPassportFileFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPassportFileFileID, kn) {
					currentKey = ffjtPassportFileFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPassportFilenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPassportFileFileID:
					goto handle_FileID

				case ffjtPassportFileFileSize:
					goto handle_FileSize

				case ffjtPassportFileFileDate:
					goto handle_FileDate

				case ffjtPassportFilenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: j.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: j.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileDate:

	/* handler: j.FileDate type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileDate = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PassportScope) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PassportScope) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"data":`)
	if j.Data != nil {
		buf.WriteString(`[`)
		for i, v := range j.Data {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Interface types must use runtime reflection. type=telegram.PassportScopeElement kind=interface */
			err = buf.Encode(v)
			if err != nil {
				return err
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"v":`)
	fflib.FormatBits2(buf, uint64(j.V), 10, j.V < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPassportScopebase = iota
	ffjtPassportScopenosuchkey

	ffjtPassportScopeData

	ffjtPassportScopeV
)

var ffjKeyPassportScopeData = []byte("data")

var ffjKeyPassportScopeV = []byte("v")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PassportScope) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PassportScope) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPassportScopebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPassportScopenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyPassportScopeData, kn) {
						currentKey = ffjtPassportScopeData
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyPassportScopeV, kn) {
						currentKey = ffjtPassportScopeV
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyPassportScopeV, kn) {
					currentKey = ffjtPassportScopeV
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPassportScopeData, kn) {
					currentKey = ffjtPassportScopeData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPassportScopenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPassportScopeData:
					goto handle_Data

				case ffjtPassportScopeV:
					goto handle_V

				case ffjtPassportScopenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Data:

	/* handler: j.Data type=[]telegram.PassportScopeElement kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Data = nil
		} else {

			j.Data = []PassportScopeElement{}

			wantVal := true

			for {

				var tmpJData PassportScopeElement

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJData type=telegram.PassportScopeElement kind=interface quoted=false*/

				{
					/* Falling back. type=telegram.PassportScopeElement kind=interface */
					tbuf, err := fs.CaptureField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}

					err = json.Unmarshal(tbuf, &tmpJData)
					if err != nil {
						return fs.WrapErr(err)
					}
				}

				j.Data = append(j.Data, tmpJData)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_V:

	/* handler: j.V type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.V = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PassportScopeElementOne) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PassportScopeElementOne) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteByte(',')
	if j.Selfie != false {
		if j.Selfie {
			buf.WriteString(`"selfie":true`)
		} else {
			buf.WriteString(`"selfie":false`)
		}
		buf.WriteByte(',')
	}
	if j.Translation != false {
		if j.Translation {
			buf.WriteString(`"translation":true`)
		} else {
			buf.WriteString(`"translation":false`)
		}
		buf.WriteByte(',')
	}
	if j.NativeNames != false {
		if j.NativeNames {
			buf.WriteString(`"native_names":true`)
		} else {
			buf.WriteString(`"native_names":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPassportScopeElementOnebase = iota
	ffjtPassportScopeElementOnenosuchkey

	ffjtPassportScopeElementOneType

	ffjtPassportScopeElementOneSelfie

	ffjtPassportScopeElementOneTranslation

	ffjtPassportScopeElementOneNativeNames
)

var ffjKeyPassportScopeElementOneType = []byte("type")

var ffjKeyPassportScopeElementOneSelfie = []byte("selfie")

var ffjKeyPassportScopeElementOneTranslation = []byte("translation")

var ffjKeyPassportScopeElementOneNativeNames = []byte("native_names")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PassportScopeElementOne) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PassportScopeElementOne) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPassportScopeElementOnebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPassportScopeElementOnenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'n':

					if bytes.Equal(ffjKeyPassportScopeElementOneNativeNames, kn) {
						currentKey = ffjtPassportScopeElementOneNativeNames
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyPassportScopeElementOneSelfie, kn) {
						currentKey = ffjtPassportScopeElementOneSelfie
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyPassportScopeElementOneType, kn) {
						currentKey = ffjtPassportScopeElementOneType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPassportScopeElementOneTranslation, kn) {
						currentKey = ffjtPassportScopeElementOneTranslation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyPassportScopeElementOneNativeNames, kn) {
					currentKey = ffjtPassportScopeElementOneNativeNames
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportScopeElementOneTranslation, kn) {
					currentKey = ffjtPassportScopeElementOneTranslation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportScopeElementOneSelfie, kn) {
					currentKey = ffjtPassportScopeElementOneSelfie
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPassportScopeElementOneType, kn) {
					currentKey = ffjtPassportScopeElementOneType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPassportScopeElementOnenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPassportScopeElementOneType:
					goto handle_Type

				case ffjtPassportScopeElementOneSelfie:
					goto handle_Selfie

				case ffjtPassportScopeElementOneTranslation:
					goto handle_Translation

				case ffjtPassportScopeElementOneNativeNames:
					goto handle_NativeNames

				case ffjtPassportScopeElementOnenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Selfie:

	/* handler: j.Selfie type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Selfie = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Selfie = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Translation:

	/* handler: j.Translation type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Translation = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Translation = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NativeNames:

	/* handler: j.NativeNames type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.NativeNames = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.NativeNames = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PassportScopeElementOneOfSeveral) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PassportScopeElementOneOfSeveral) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "one_of":`)
	if j.OneOf != nil {
		buf.WriteString(`[`)
		for i, v := range j.OneOf {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if j.Selfie != false {
		if j.Selfie {
			buf.WriteString(`"selfie":true`)
		} else {
			buf.WriteString(`"selfie":false`)
		}
		buf.WriteByte(',')
	}
	if j.Translation != false {
		if j.Translation {
			buf.WriteString(`"translation":true`)
		} else {
			buf.WriteString(`"translation":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPassportScopeElementOneOfSeveralbase = iota
	ffjtPassportScopeElementOneOfSeveralnosuchkey

	ffjtPassportScopeElementOneOfSeveralOneOf

	ffjtPassportScopeElementOneOfSeveralSelfie

	ffjtPassportScopeElementOneOfSeveralTranslation
)

var ffjKeyPassportScopeElementOneOfSeveralOneOf = []byte("one_of")

var ffjKeyPassportScopeElementOneOfSeveralSelfie = []byte("selfie")

var ffjKeyPassportScopeElementOneOfSeveralTranslation = []byte("translation")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PassportScopeElementOneOfSeveral) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PassportScopeElementOneOfSeveral) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPassportScopeElementOneOfSeveralbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPassportScopeElementOneOfSeveralnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'o':

					if bytes.Equal(ffjKeyPassportScopeElementOneOfSeveralOneOf, kn) {
						currentKey = ffjtPassportScopeElementOneOfSeveralOneOf
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyPassportScopeElementOneOfSeveralSelfie, kn) {
						currentKey = ffjtPassportScopeElementOneOfSeveralSelfie
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyPassportScopeElementOneOfSeveralTranslation, kn) {
						currentKey = ffjtPassportScopeElementOneOfSeveralTranslation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyPassportScopeElementOneOfSeveralTranslation, kn) {
					currentKey = ffjtPassportScopeElementOneOfSeveralTranslation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportScopeElementOneOfSeveralSelfie, kn) {
					currentKey = ffjtPassportScopeElementOneOfSeveralSelfie
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPassportScopeElementOneOfSeveralOneOf, kn) {
					currentKey = ffjtPassportScopeElementOneOfSeveralOneOf
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPassportScopeElementOneOfSeveralnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPassportScopeElementOneOfSeveralOneOf:
					goto handle_OneOf

				case ffjtPassportScopeElementOneOfSeveralSelfie:
					goto handle_Selfie

				case ffjtPassportScopeElementOneOfSeveralTranslation:
					goto handle_Translation

				case ffjtPassportScopeElementOneOfSeveralnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_OneOf:

	/* handler: j.OneOf type=[]telegram.PassportScopeElementOne kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.OneOf = nil
		} else {

			j.OneOf = []PassportScopeElementOne{}

			wantVal := true

			for {

				var tmpJOneOf PassportScopeElementOne

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJOneOf type=telegram.PassportScopeElementOne kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJOneOf.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.OneOf = append(j.OneOf, tmpJOneOf)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Selfie:

	/* handler: j.Selfie type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Selfie = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Selfie = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Translation:

	/* handler: j.Translation type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Translation = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Translation = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PersonalDetails) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PersonalDetails) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "first_name":`)
	fflib.WriteJsonString(buf, string(j.FirstName))
	buf.WriteString(`,"last_name":`)
	fflib.WriteJsonString(buf, string(j.LastName))
	buf.WriteByte(',')
	if len(j.MiddleName) != 0 {
		buf.WriteString(`"middle_name":`)
		fflib.WriteJsonString(buf, string(j.MiddleName))
		buf.WriteByte(',')
	}
	buf.WriteString(`"birth_date":`)
	fflib.WriteJsonString(buf, string(j.BirthDate))
	buf.WriteString(`,"gender":`)
	fflib.WriteJsonString(buf, string(j.Gender))
	buf.WriteString(`,"country_code":`)
	fflib.WriteJsonString(buf, string(j.CountryCode))
	buf.WriteString(`,"residence_country_code":`)
	fflib.WriteJsonString(buf, string(j.ResidenceCountryCode))
	buf.WriteString(`,"first_name_native":`)
	fflib.WriteJsonString(buf, string(j.FirstNameNative))
	buf.WriteString(`,"last_name_native":`)
	fflib.WriteJsonString(buf, string(j.LastNameNative))
	buf.WriteByte(',')
	if len(j.MiddleNameNative) != 0 {
		buf.WriteString(`"middle_name_native":`)
		fflib.WriteJsonString(buf, string(j.MiddleNameNative))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPersonalDetailsbase = iota
	ffjtPersonalDetailsnosuchkey

	ffjtPersonalDetailsFirstName

	ffjtPersonalDetailsLastName

	ffjtPersonalDetailsMiddleName

	ffjtPersonalDetailsBirthDate

	ffjtPersonalDetailsGender

	ffjtPersonalDetailsCountryCode

	ffjtPersonalDetailsResidenceCountryCode

	ffjtPersonalDetailsFirstNameNative

	ffjtPersonalDetailsLastNameNative

	ffjtPersonalDetailsMiddleNameNative
)

var ffjKeyPersonalDetailsFirstName = []byte("first_name")

var ffjKeyPersonalDetailsLastName = []byte("last_name")

var ffjKeyPersonalDetailsMiddleName = []byte("middle_name")

var ffjKeyPersonalDetailsBirthDate = []byte("birth_date")

var ffjKeyPersonalDetailsGender = []byte("gender")

var ffjKeyPersonalDetailsCountryCode = []byte("country_code")

var ffjKeyPersonalDetailsResidenceCountryCode = []byte("residence_country_code")

var ffjKeyPersonalDetailsFirstNameNative = []byte("first_name_native")

var ffjKeyPersonalDetailsLastNameNative = []byte("last_name_native")

var ffjKeyPersonalDetailsMiddleNameNative = []byte("middle_name_native")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PersonalDetails) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PersonalDetails) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPersonalDetailsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPersonalDetailsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffjKeyPersonalDetailsBirthDate, kn) {
						currentKey = ffjtPersonalDetailsBirthDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyPersonalDetailsCountryCode, kn) {
						currentKey = ffjtPersonalDetailsCountryCode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyPersonalDetailsFirstName, kn) {
						currentKey = ffjtPersonalDetailsFirstName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPersonalDetailsFirstNameNative, kn) {
						currentKey = ffjtPersonalDetailsFirstNameNative
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyPersonalDetailsGender, kn) {
						currentKey = ffjtPersonalDetailsGender
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyPersonalDetailsLastName, kn) {
						currentKey = ffjtPersonalDetailsLastName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPersonalDetailsLastNameNative, kn) {
						currentKey = ffjtPersonalDetailsLastNameNative
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyPersonalDetailsMiddleName, kn) {
						currentKey = ffjtPersonalDetailsMiddleName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPersonalDetailsMiddleNameNative, kn) {
						currentKey = ffjtPersonalDetailsMiddleNameNative
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyPersonalDetailsResidenceCountryCode, kn) {
						currentKey = ffjtPersonalDetailsResidenceCountryCode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyPersonalDetailsMiddleNameNative, kn) {
					currentKey = ffjtPersonalDetailsMiddleNameNative
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPersonalDetailsLastNameNative, kn) {
					currentKey = ffjtPersonalDetailsLastNameNative
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPersonalDetailsFirstNameNative, kn) {
					currentKey = ffjtPersonalDetailsFirstNameNative
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPersonalDetailsResidenceCountryCode, kn) {
					currentKey = ffjtPersonalDetailsResidenceCountryCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPersonalDetailsCountryCode, kn) {
					currentKey = ffjtPersonalDetailsCountryCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPersonalDetailsGender, kn) {
					currentKey = ffjtPersonalDetailsGender
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPersonalDetailsBirthDate, kn) {
					currentKey = ffjtPersonalDetailsBirthDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPersonalDetailsMiddleName, kn) {
					currentKey = ffjtPersonalDetailsMiddleName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPersonalDetailsLastName, kn) {
					currentKey = ffjtPersonalDetailsLastName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPersonalDetailsFirstName, kn) {
					currentKey = ffjtPersonalDetailsFirstName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPersonalDetailsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPersonalDetailsFirstName:
					goto handle_FirstName

				case ffjtPersonalDetailsLastName:
					goto handle_LastName

				case ffjtPersonalDetailsMiddleName:
					goto handle_MiddleName

				case ffjtPersonalDetailsBirthDate:
					goto handle_BirthDate

				case ffjtPersonalDetailsGender:
					goto handle_Gender

				case ffjtPersonalDetailsCountryCode:
					goto handle_CountryCode

				case ffjtPersonalDetailsResidenceCountryCode:
					goto handle_ResidenceCountryCode

				case ffjtPersonalDetailsFirstNameNative:
					goto handle_FirstNameNative

				case ffjtPersonalDetailsLastNameNative:
					goto handle_LastNameNative

				case ffjtPersonalDetailsMiddleNameNative:
					goto handle_MiddleNameNative

				case ffjtPersonalDetailsnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FirstName:

	/* handler: j.FirstName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FirstName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastName:

	/* handler: j.LastName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LastName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MiddleName:

	/* handler: j.MiddleName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MiddleName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BirthDate:

	/* handler: j.BirthDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.BirthDate = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gender:

	/* handler: j.Gender type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Gender = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CountryCode:

	/* handler: j.CountryCode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CountryCode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ResidenceCountryCode:

	/* handler: j.ResidenceCountryCode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ResidenceCountryCode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FirstNameNative:

	/* handler: j.FirstNameNative type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FirstNameNative = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastNameNative:

	/* handler: j.LastNameNative type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LastNameNative = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MiddleNameNative:

	/* handler: j.MiddleNameNative type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MiddleNameNative = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PhotoSize) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PhotoSize) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(j.FileID))
	buf.WriteString(`,"width":`)
	fflib.FormatBits2(buf, uint64(j.Width), 10, j.Width < 0)
	buf.WriteString(`,"height":`)
	fflib.FormatBits2(buf, uint64(j.Height), 10, j.Height < 0)
	buf.WriteByte(',')
	if j.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(j.FileSize), 10, j.FileSize < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPhotoSizebase = iota
	ffjtPhotoSizenosuchkey

	ffjtPhotoSizeFileID

	ffjtPhotoSizeWidth

	ffjtPhotoSizeHeight

	ffjtPhotoSizeFileSize
)

var ffjKeyPhotoSizeFileID = []byte("file_id")

var ffjKeyPhotoSizeWidth = []byte("width")

var ffjKeyPhotoSizeHeight = []byte("height")

var ffjKeyPhotoSizeFileSize = []byte("file_size")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PhotoSize) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PhotoSize) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPhotoSizebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPhotoSizenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyPhotoSizeFileID, kn) {
						currentKey = ffjtPhotoSizeFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPhotoSizeFileSize, kn) {
						currentKey = ffjtPhotoSizeFileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyPhotoSizeHeight, kn) {
						currentKey = ffjtPhotoSizeHeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyPhotoSizeWidth, kn) {
						currentKey = ffjtPhotoSizeWidth
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyPhotoSizeFileSize, kn) {
					currentKey = ffjtPhotoSizeFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPhotoSizeHeight, kn) {
					currentKey = ffjtPhotoSizeHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPhotoSizeWidth, kn) {
					currentKey = ffjtPhotoSizeWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPhotoSizeFileID, kn) {
					currentKey = ffjtPhotoSizeFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPhotoSizenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPhotoSizeFileID:
					goto handle_FileID

				case ffjtPhotoSizeWidth:
					goto handle_Width

				case ffjtPhotoSizeHeight:
					goto handle_Height

				case ffjtPhotoSizeFileSize:
					goto handle_FileSize

				case ffjtPhotoSizenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: j.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Width:

	/* handler: j.Width type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Width = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Height:

	/* handler: j.Height type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Height = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: j.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Poll) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Poll) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"question":`)
	fflib.WriteJsonString(buf, string(j.Question))
	buf.WriteString(`,"options":`)
	if j.Options != nil {
		buf.WriteString(`[`)
		for i, v := range j.Options {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	if j.IsClosed {
		buf.WriteString(`,"is_closed":true`)
	} else {
		buf.WriteString(`,"is_closed":false`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPollbase = iota
	ffjtPollnosuchkey

	ffjtPollID

	ffjtPollQuestion

	ffjtPollOptions

	ffjtPollIsClosed
)

var ffjKeyPollID = []byte("id")

var ffjKeyPollQuestion = []byte("question")

var ffjKeyPollOptions = []byte("options")

var ffjKeyPollIsClosed = []byte("is_closed")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Poll) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Poll) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPollbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPollnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffjKeyPollID, kn) {
						currentKey = ffjtPollID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPollIsClosed, kn) {
						currentKey = ffjtPollIsClosed
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyPollOptions, kn) {
						currentKey = ffjtPollOptions
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'q':

					if bytes.Equal(ffjKeyPollQuestion, kn) {
						currentKey = ffjtPollQuestion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyPollIsClosed, kn) {
					currentKey = ffjtPollIsClosed
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPollOptions, kn) {
					currentKey = ffjtPollOptions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPollQuestion, kn) {
					currentKey = ffjtPollQuestion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPollID, kn) {
					currentKey = ffjtPollID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPollnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPollID:
					goto handle_ID

				case ffjtPollQuestion:
					goto handle_Question

				case ffjtPollOptions:
					goto handle_Options

				case ffjtPollIsClosed:
					goto handle_IsClosed

				case ffjtPollnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Question:

	/* handler: j.Question type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Question = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Options:

	/* handler: j.Options type=[]telegram.PollOption kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Options = nil
		} else {

			j.Options = []PollOption{}

			wantVal := true

			for {

				var tmpJOptions PollOption

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJOptions type=telegram.PollOption kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJOptions.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Options = append(j.Options, tmpJOptions)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsClosed:

	/* handler: j.IsClosed type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.IsClosed = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.IsClosed = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PollOption) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PollOption) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"text":`)
	fflib.WriteJsonString(buf, string(j.Text))
	buf.WriteString(`,"voter_count":`)
	fflib.FormatBits2(buf, uint64(j.VoterCount), 10, j.VoterCount < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPollOptionbase = iota
	ffjtPollOptionnosuchkey

	ffjtPollOptionText

	ffjtPollOptionVoterCount
)

var ffjKeyPollOptionText = []byte("text")

var ffjKeyPollOptionVoterCount = []byte("voter_count")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PollOption) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PollOption) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPollOptionbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPollOptionnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 't':

					if bytes.Equal(ffjKeyPollOptionText, kn) {
						currentKey = ffjtPollOptionText
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyPollOptionVoterCount, kn) {
						currentKey = ffjtPollOptionVoterCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyPollOptionVoterCount, kn) {
					currentKey = ffjtPollOptionVoterCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPollOptionText, kn) {
					currentKey = ffjtPollOptionText
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPollOptionnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPollOptionText:
					goto handle_Text

				case ffjtPollOptionVoterCount:
					goto handle_VoterCount

				case ffjtPollOptionnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Text:

	/* handler: j.Text type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Text = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VoterCount:

	/* handler: j.VoterCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.VoterCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PreCheckoutQuery) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PreCheckoutQuery) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"currency":`)
	fflib.WriteJsonString(buf, string(j.Currency))
	buf.WriteString(`,"invoice_payload":`)
	fflib.WriteJsonString(buf, string(j.InvoicePayload))
	buf.WriteByte(',')
	if len(j.ShippingOptionID) != 0 {
		buf.WriteString(`"shipping_option_id":`)
		fflib.WriteJsonString(buf, string(j.ShippingOptionID))
		buf.WriteByte(',')
	}
	if j.From != nil {
		buf.WriteString(`"from":`)

		{

			err = j.From.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`"from":null`)
	}
	buf.WriteString(`,"total_amount":`)
	fflib.FormatBits2(buf, uint64(j.TotalAmount), 10, j.TotalAmount < 0)
	buf.WriteByte(',')
	if j.OrderInfo != nil {
		if true {
			buf.WriteString(`"order_info":`)

			{

				err = j.OrderInfo.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPreCheckoutQuerybase = iota
	ffjtPreCheckoutQuerynosuchkey

	ffjtPreCheckoutQueryID

	ffjtPreCheckoutQueryCurrency

	ffjtPreCheckoutQueryInvoicePayload

	ffjtPreCheckoutQueryShippingOptionID

	ffjtPreCheckoutQueryFrom

	ffjtPreCheckoutQueryTotalAmount

	ffjtPreCheckoutQueryOrderInfo
)

var ffjKeyPreCheckoutQueryID = []byte("id")

var ffjKeyPreCheckoutQueryCurrency = []byte("currency")

var ffjKeyPreCheckoutQueryInvoicePayload = []byte("invoice_payload")

var ffjKeyPreCheckoutQueryShippingOptionID = []byte("shipping_option_id")

var ffjKeyPreCheckoutQueryFrom = []byte("from")

var ffjKeyPreCheckoutQueryTotalAmount = []byte("total_amount")

var ffjKeyPreCheckoutQueryOrderInfo = []byte("order_info")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PreCheckoutQuery) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PreCheckoutQuery) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPreCheckoutQuerybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPreCheckoutQuerynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyPreCheckoutQueryCurrency, kn) {
						currentKey = ffjtPreCheckoutQueryCurrency
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyPreCheckoutQueryFrom, kn) {
						currentKey = ffjtPreCheckoutQueryFrom
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyPreCheckoutQueryID, kn) {
						currentKey = ffjtPreCheckoutQueryID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPreCheckoutQueryInvoicePayload, kn) {
						currentKey = ffjtPreCheckoutQueryInvoicePayload
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyPreCheckoutQueryOrderInfo, kn) {
						currentKey = ffjtPreCheckoutQueryOrderInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyPreCheckoutQueryShippingOptionID, kn) {
						currentKey = ffjtPreCheckoutQueryShippingOptionID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyPreCheckoutQueryTotalAmount, kn) {
						currentKey = ffjtPreCheckoutQueryTotalAmount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyPreCheckoutQueryOrderInfo, kn) {
					currentKey = ffjtPreCheckoutQueryOrderInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPreCheckoutQueryTotalAmount, kn) {
					currentKey = ffjtPreCheckoutQueryTotalAmount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPreCheckoutQueryFrom, kn) {
					currentKey = ffjtPreCheckoutQueryFrom
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPreCheckoutQueryShippingOptionID, kn) {
					currentKey = ffjtPreCheckoutQueryShippingOptionID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPreCheckoutQueryInvoicePayload, kn) {
					currentKey = ffjtPreCheckoutQueryInvoicePayload
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPreCheckoutQueryCurrency, kn) {
					currentKey = ffjtPreCheckoutQueryCurrency
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPreCheckoutQueryID, kn) {
					currentKey = ffjtPreCheckoutQueryID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPreCheckoutQuerynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPreCheckoutQueryID:
					goto handle_ID

				case ffjtPreCheckoutQueryCurrency:
					goto handle_Currency

				case ffjtPreCheckoutQueryInvoicePayload:
					goto handle_InvoicePayload

				case ffjtPreCheckoutQueryShippingOptionID:
					goto handle_ShippingOptionID

				case ffjtPreCheckoutQueryFrom:
					goto handle_From

				case ffjtPreCheckoutQueryTotalAmount:
					goto handle_TotalAmount

				case ffjtPreCheckoutQueryOrderInfo:
					goto handle_OrderInfo

				case ffjtPreCheckoutQuerynosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Currency:

	/* handler: j.Currency type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Currency = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InvoicePayload:

	/* handler: j.InvoicePayload type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.InvoicePayload = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShippingOptionID:

	/* handler: j.ShippingOptionID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ShippingOptionID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_From:

	/* handler: j.From type=telegram.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.From = nil

		} else {

			if j.From == nil {
				j.From = new(User)
			}

			err = j.From.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalAmount:

	/* handler: j.TotalAmount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.TotalAmount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OrderInfo:

	/* handler: j.OrderInfo type=telegram.OrderInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.OrderInfo = nil

		} else {

			if j.OrderInfo == nil {
				j.OrderInfo = new(OrderInfo)
			}

			err = j.OrderInfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ReplyKeyboardMarkup) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ReplyKeyboardMarkup) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "keyboard":`)
	if j.Keyboard != nil {
		buf.WriteString(`[`)
		for i, v := range j.Keyboard {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				buf.WriteString(`[`)
				for i, v := range v {
					if i != 0 {
						buf.WriteString(`,`)
					}

					{

						err = v.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}
				}
				buf.WriteString(`]`)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if j.ResizeKeyboard != false {
		if j.ResizeKeyboard {
			buf.WriteString(`"resize_keyboard":true`)
		} else {
			buf.WriteString(`"resize_keyboard":false`)
		}
		buf.WriteByte(',')
	}
	if j.OneTimeKeyboard != false {
		if j.OneTimeKeyboard {
			buf.WriteString(`"one_time_keyboard":true`)
		} else {
			buf.WriteString(`"one_time_keyboard":false`)
		}
		buf.WriteByte(',')
	}
	if j.Selective != false {
		if j.Selective {
			buf.WriteString(`"selective":true`)
		} else {
			buf.WriteString(`"selective":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtReplyKeyboardMarkupbase = iota
	ffjtReplyKeyboardMarkupnosuchkey

	ffjtReplyKeyboardMarkupKeyboard

	ffjtReplyKeyboardMarkupResizeKeyboard

	ffjtReplyKeyboardMarkupOneTimeKeyboard

	ffjtReplyKeyboardMarkupSelective
)

var ffjKeyReplyKeyboardMarkupKeyboard = []byte("keyboard")

var ffjKeyReplyKeyboardMarkupResizeKeyboard = []byte("resize_keyboard")

var ffjKeyReplyKeyboardMarkupOneTimeKeyboard = []byte("one_time_keyboard")

var ffjKeyReplyKeyboardMarkupSelective = []byte("selective")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ReplyKeyboardMarkup) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ReplyKeyboardMarkup) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtReplyKeyboardMarkupbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtReplyKeyboardMarkupnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'k':

					if bytes.Equal(ffjKeyReplyKeyboardMarkupKeyboard, kn) {
						currentKey = ffjtReplyKeyboardMarkupKeyboard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyReplyKeyboardMarkupOneTimeKeyboard, kn) {
						currentKey = ffjtReplyKeyboardMarkupOneTimeKeyboard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyReplyKeyboardMarkupResizeKeyboard, kn) {
						currentKey = ffjtReplyKeyboardMarkupResizeKeyboard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyReplyKeyboardMarkupSelective, kn) {
						currentKey = ffjtReplyKeyboardMarkupSelective
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyReplyKeyboardMarkupSelective, kn) {
					currentKey = ffjtReplyKeyboardMarkupSelective
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyReplyKeyboardMarkupOneTimeKeyboard, kn) {
					currentKey = ffjtReplyKeyboardMarkupOneTimeKeyboard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyReplyKeyboardMarkupResizeKeyboard, kn) {
					currentKey = ffjtReplyKeyboardMarkupResizeKeyboard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyReplyKeyboardMarkupKeyboard, kn) {
					currentKey = ffjtReplyKeyboardMarkupKeyboard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtReplyKeyboardMarkupnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtReplyKeyboardMarkupKeyboard:
					goto handle_Keyboard

				case ffjtReplyKeyboardMarkupResizeKeyboard:
					goto handle_ResizeKeyboard

				case ffjtReplyKeyboardMarkupOneTimeKeyboard:
					goto handle_OneTimeKeyboard

				case ffjtReplyKeyboardMarkupSelective:
					goto handle_Selective

				case ffjtReplyKeyboardMarkupnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Keyboard:

	/* handler: j.Keyboard type=[][]telegram.KeyboardButton kind=slice quoted=false*/

	{
		/* Falling back. type=[][]telegram.KeyboardButton kind=slice */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Keyboard)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ResizeKeyboard:

	/* handler: j.ResizeKeyboard type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.ResizeKeyboard = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.ResizeKeyboard = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OneTimeKeyboard:

	/* handler: j.OneTimeKeyboard type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.OneTimeKeyboard = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.OneTimeKeyboard = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Selective:

	/* handler: j.Selective type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Selective = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Selective = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ReplyKeyboardRemove) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ReplyKeyboardRemove) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.RemoveKeyboard {
		buf.WriteString(`{ "remove_keyboard":true`)
	} else {
		buf.WriteString(`{ "remove_keyboard":false`)
	}
	buf.WriteByte(',')
	if j.Selective != false {
		if j.Selective {
			buf.WriteString(`"selective":true`)
		} else {
			buf.WriteString(`"selective":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtReplyKeyboardRemovebase = iota
	ffjtReplyKeyboardRemovenosuchkey

	ffjtReplyKeyboardRemoveRemoveKeyboard

	ffjtReplyKeyboardRemoveSelective
)

var ffjKeyReplyKeyboardRemoveRemoveKeyboard = []byte("remove_keyboard")

var ffjKeyReplyKeyboardRemoveSelective = []byte("selective")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ReplyKeyboardRemove) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ReplyKeyboardRemove) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtReplyKeyboardRemovebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtReplyKeyboardRemovenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffjKeyReplyKeyboardRemoveRemoveKeyboard, kn) {
						currentKey = ffjtReplyKeyboardRemoveRemoveKeyboard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyReplyKeyboardRemoveSelective, kn) {
						currentKey = ffjtReplyKeyboardRemoveSelective
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyReplyKeyboardRemoveSelective, kn) {
					currentKey = ffjtReplyKeyboardRemoveSelective
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyReplyKeyboardRemoveRemoveKeyboard, kn) {
					currentKey = ffjtReplyKeyboardRemoveRemoveKeyboard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtReplyKeyboardRemovenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtReplyKeyboardRemoveRemoveKeyboard:
					goto handle_RemoveKeyboard

				case ffjtReplyKeyboardRemoveSelective:
					goto handle_Selective

				case ffjtReplyKeyboardRemovenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_RemoveKeyboard:

	/* handler: j.RemoveKeyboard type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.RemoveKeyboard = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.RemoveKeyboard = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Selective:

	/* handler: j.Selective type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Selective = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Selective = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ResidentialAddress) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ResidentialAddress) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"street_line1":`)
	fflib.WriteJsonString(buf, string(j.StreetLine1))
	buf.WriteByte(',')
	if len(j.StreetLine2) != 0 {
		buf.WriteString(`"street_line2":`)
		fflib.WriteJsonString(buf, string(j.StreetLine2))
		buf.WriteByte(',')
	}
	buf.WriteString(`"city":`)
	fflib.WriteJsonString(buf, string(j.City))
	buf.WriteByte(',')
	if len(j.State) != 0 {
		buf.WriteString(`"state":`)
		fflib.WriteJsonString(buf, string(j.State))
		buf.WriteByte(',')
	}
	buf.WriteString(`"country_code":`)
	fflib.WriteJsonString(buf, string(j.CountryCode))
	buf.WriteString(`,"post_code":`)
	fflib.WriteJsonString(buf, string(j.PostCode))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtResidentialAddressbase = iota
	ffjtResidentialAddressnosuchkey

	ffjtResidentialAddressStreetLine1

	ffjtResidentialAddressStreetLine2

	ffjtResidentialAddressCity

	ffjtResidentialAddressState

	ffjtResidentialAddressCountryCode

	ffjtResidentialAddressPostCode
)

var ffjKeyResidentialAddressStreetLine1 = []byte("street_line1")

var ffjKeyResidentialAddressStreetLine2 = []byte("street_line2")

var ffjKeyResidentialAddressCity = []byte("city")

var ffjKeyResidentialAddressState = []byte("state")

var ffjKeyResidentialAddressCountryCode = []byte("country_code")

var ffjKeyResidentialAddressPostCode = []byte("post_code")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ResidentialAddress) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ResidentialAddress) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtResidentialAddressbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtResidentialAddressnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyResidentialAddressCity, kn) {
						currentKey = ffjtResidentialAddressCity
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyResidentialAddressCountryCode, kn) {
						currentKey = ffjtResidentialAddressCountryCode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyResidentialAddressPostCode, kn) {
						currentKey = ffjtResidentialAddressPostCode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyResidentialAddressStreetLine1, kn) {
						currentKey = ffjtResidentialAddressStreetLine1
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyResidentialAddressStreetLine2, kn) {
						currentKey = ffjtResidentialAddressStreetLine2
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyResidentialAddressState, kn) {
						currentKey = ffjtResidentialAddressState
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyResidentialAddressPostCode, kn) {
					currentKey = ffjtResidentialAddressPostCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyResidentialAddressCountryCode, kn) {
					currentKey = ffjtResidentialAddressCountryCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyResidentialAddressState, kn) {
					currentKey = ffjtResidentialAddressState
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyResidentialAddressCity, kn) {
					currentKey = ffjtResidentialAddressCity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyResidentialAddressStreetLine2, kn) {
					currentKey = ffjtResidentialAddressStreetLine2
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyResidentialAddressStreetLine1, kn) {
					currentKey = ffjtResidentialAddressStreetLine1
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtResidentialAddressnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtResidentialAddressStreetLine1:
					goto handle_StreetLine1

				case ffjtResidentialAddressStreetLine2:
					goto handle_StreetLine2

				case ffjtResidentialAddressCity:
					goto handle_City

				case ffjtResidentialAddressState:
					goto handle_State

				case ffjtResidentialAddressCountryCode:
					goto handle_CountryCode

				case ffjtResidentialAddressPostCode:
					goto handle_PostCode

				case ffjtResidentialAddressnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_StreetLine1:

	/* handler: j.StreetLine1 type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.StreetLine1 = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StreetLine2:

	/* handler: j.StreetLine2 type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.StreetLine2 = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_City:

	/* handler: j.City type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.City = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_State:

	/* handler: j.State type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.State = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CountryCode:

	/* handler: j.CountryCode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CountryCode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PostCode:

	/* handler: j.PostCode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PostCode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Response) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Response) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.Ok {
		buf.WriteString(`{ "ok":true`)
	} else {
		buf.WriteString(`{ "ok":false`)
	}
	buf.WriteByte(',')
	if j.ErrorCode != 0 {
		buf.WriteString(`"error_code":`)
		fflib.FormatBits2(buf, uint64(j.ErrorCode), 10, j.ErrorCode < 0)
		buf.WriteByte(',')
	}
	if len(j.Description) != 0 {
		buf.WriteString(`"description":`)
		fflib.WriteJsonString(buf, string(j.Description))
		buf.WriteByte(',')
	}
	if j.Result != nil {
		if true {
			buf.WriteString(`"result":`)

			{

				obj, err = j.Result.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if j.Parameters != nil {
		if true {
			buf.WriteString(`"parameters":`)

			{

				err = j.Parameters.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtResponsebase = iota
	ffjtResponsenosuchkey

	ffjtResponseOk

	ffjtResponseErrorCode

	ffjtResponseDescription

	ffjtResponseResult

	ffjtResponseParameters
)

var ffjKeyResponseOk = []byte("ok")

var ffjKeyResponseErrorCode = []byte("error_code")

var ffjKeyResponseDescription = []byte("description")

var ffjKeyResponseResult = []byte("result")

var ffjKeyResponseParameters = []byte("parameters")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Response) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Response) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtResponsebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtResponsenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyResponseDescription, kn) {
						currentKey = ffjtResponseDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyResponseErrorCode, kn) {
						currentKey = ffjtResponseErrorCode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyResponseOk, kn) {
						currentKey = ffjtResponseOk
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyResponseParameters, kn) {
						currentKey = ffjtResponseParameters
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyResponseResult, kn) {
						currentKey = ffjtResponseResult
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyResponseParameters, kn) {
					currentKey = ffjtResponseParameters
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyResponseResult, kn) {
					currentKey = ffjtResponseResult
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyResponseDescription, kn) {
					currentKey = ffjtResponseDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyResponseErrorCode, kn) {
					currentKey = ffjtResponseErrorCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyResponseOk, kn) {
					currentKey = ffjtResponseOk
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtResponsenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtResponseOk:
					goto handle_Ok

				case ffjtResponseErrorCode:
					goto handle_ErrorCode

				case ffjtResponseDescription:
					goto handle_Description

				case ffjtResponseResult:
					goto handle_Result

				case ffjtResponseParameters:
					goto handle_Parameters

				case ffjtResponsenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Ok:

	/* handler: j.Ok type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Ok = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Ok = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ErrorCode:

	/* handler: j.ErrorCode type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ErrorCode = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Result:

	/* handler: j.Result type=json.RawMessage kind=slice quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Result = nil

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			if j.Result == nil {
				j.Result = new(json.RawMessage)
			}

			err = j.Result.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Parameters:

	/* handler: j.Parameters type=telegram.ResponseParameters kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Parameters = nil

		} else {

			if j.Parameters == nil {
				j.Parameters = new(ResponseParameters)
			}

			err = j.Parameters.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ResponseParameters) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ResponseParameters) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if j.MigrateToChatID != 0 {
		buf.WriteString(`"migrate_to_chat_id":`)
		fflib.FormatBits2(buf, uint64(j.MigrateToChatID), 10, j.MigrateToChatID < 0)
		buf.WriteByte(',')
	}
	if j.RetryAfter != 0 {
		buf.WriteString(`"retry_after":`)
		fflib.FormatBits2(buf, uint64(j.RetryAfter), 10, j.RetryAfter < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtResponseParametersbase = iota
	ffjtResponseParametersnosuchkey

	ffjtResponseParametersMigrateToChatID

	ffjtResponseParametersRetryAfter
)

var ffjKeyResponseParametersMigrateToChatID = []byte("migrate_to_chat_id")

var ffjKeyResponseParametersRetryAfter = []byte("retry_after")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ResponseParameters) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ResponseParameters) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtResponseParametersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtResponseParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'm':

					if bytes.Equal(ffjKeyResponseParametersMigrateToChatID, kn) {
						currentKey = ffjtResponseParametersMigrateToChatID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyResponseParametersRetryAfter, kn) {
						currentKey = ffjtResponseParametersRetryAfter
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyResponseParametersRetryAfter, kn) {
					currentKey = ffjtResponseParametersRetryAfter
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyResponseParametersMigrateToChatID, kn) {
					currentKey = ffjtResponseParametersMigrateToChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtResponseParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtResponseParametersMigrateToChatID:
					goto handle_MigrateToChatID

				case ffjtResponseParametersRetryAfter:
					goto handle_RetryAfter

				case ffjtResponseParametersnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_MigrateToChatID:

	/* handler: j.MigrateToChatID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MigrateToChatID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RetryAfter:

	/* handler: j.RetryAfter type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.RetryAfter = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *SecureData) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *SecureData) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if j.PersonalDetails != nil {
		if true {
			buf.WriteString(`"personal_details":`)

			{

				err = j.PersonalDetails.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Passport != nil {
		if true {
			buf.WriteString(`"passport":`)

			{

				err = j.Passport.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.InternalPassport != nil {
		if true {
			buf.WriteString(`"internal_passport":`)

			{

				err = j.InternalPassport.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.DriverLicense != nil {
		if true {
			buf.WriteString(`"driver_license":`)

			{

				err = j.DriverLicense.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.IdentityCard != nil {
		if true {
			buf.WriteString(`"identity_card":`)

			{

				err = j.IdentityCard.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Address != nil {
		if true {
			buf.WriteString(`"address":`)

			{

				err = j.Address.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.UtilityBill != nil {
		if true {
			buf.WriteString(`"utility_bill":`)

			{

				err = j.UtilityBill.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.BankStatement != nil {
		if true {
			buf.WriteString(`"bank_statement":`)

			{

				err = j.BankStatement.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.RentalAgreement != nil {
		if true {
			buf.WriteString(`"rental_agreement":`)

			{

				err = j.RentalAgreement.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.PassportRegistration != nil {
		if true {
			buf.WriteString(`"passport_registration":`)

			{

				err = j.PassportRegistration.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.TemporaryRegistration != nil {
		if true {
			buf.WriteString(`"temporary_registration":`)

			{

				err = j.TemporaryRegistration.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtSecureDatabase = iota
	ffjtSecureDatanosuchkey

	ffjtSecureDataPersonalDetails

	ffjtSecureDataPassport

	ffjtSecureDataInternalPassport

	ffjtSecureDataDriverLicense

	ffjtSecureDataIdentityCard

	ffjtSecureDataAddress

	ffjtSecureDataUtilityBill

	ffjtSecureDataBankStatement

	ffjtSecureDataRentalAgreement

	ffjtSecureDataPassportRegistration

	ffjtSecureDataTemporaryRegistration
)

var ffjKeySecureDataPersonalDetails = []byte("personal_details")

var ffjKeySecureDataPassport = []byte("passport")

var ffjKeySecureDataInternalPassport = []byte("internal_passport")

var ffjKeySecureDataDriverLicense = []byte("driver_license")

var ffjKeySecureDataIdentityCard = []byte("identity_card")

var ffjKeySecureDataAddress = []byte("address")

var ffjKeySecureDataUtilityBill = []byte("utility_bill")

var ffjKeySecureDataBankStatement = []byte("bank_statement")

var ffjKeySecureDataRentalAgreement = []byte("rental_agreement")

var ffjKeySecureDataPassportRegistration = []byte("passport_registration")

var ffjKeySecureDataTemporaryRegistration = []byte("temporary_registration")

// UnmarshalJSON umarshall json - template of ffjson
func (j *SecureData) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *SecureData) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtSecureDatabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtSecureDatanosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeySecureDataAddress, kn) {
						currentKey = ffjtSecureDataAddress
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffjKeySecureDataBankStatement, kn) {
						currentKey = ffjtSecureDataBankStatement
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeySecureDataDriverLicense, kn) {
						currentKey = ffjtSecureDataDriverLicense
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeySecureDataInternalPassport, kn) {
						currentKey = ffjtSecureDataInternalPassport
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySecureDataIdentityCard, kn) {
						currentKey = ffjtSecureDataIdentityCard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeySecureDataPersonalDetails, kn) {
						currentKey = ffjtSecureDataPersonalDetails
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySecureDataPassport, kn) {
						currentKey = ffjtSecureDataPassport
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySecureDataPassportRegistration, kn) {
						currentKey = ffjtSecureDataPassportRegistration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeySecureDataRentalAgreement, kn) {
						currentKey = ffjtSecureDataRentalAgreement
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeySecureDataTemporaryRegistration, kn) {
						currentKey = ffjtSecureDataTemporaryRegistration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeySecureDataUtilityBill, kn) {
						currentKey = ffjtSecureDataUtilityBill
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeySecureDataTemporaryRegistration, kn) {
					currentKey = ffjtSecureDataTemporaryRegistration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySecureDataPassportRegistration, kn) {
					currentKey = ffjtSecureDataPassportRegistration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySecureDataRentalAgreement, kn) {
					currentKey = ffjtSecureDataRentalAgreement
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySecureDataBankStatement, kn) {
					currentKey = ffjtSecureDataBankStatement
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySecureDataUtilityBill, kn) {
					currentKey = ffjtSecureDataUtilityBill
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySecureDataAddress, kn) {
					currentKey = ffjtSecureDataAddress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySecureDataIdentityCard, kn) {
					currentKey = ffjtSecureDataIdentityCard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySecureDataDriverLicense, kn) {
					currentKey = ffjtSecureDataDriverLicense
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySecureDataInternalPassport, kn) {
					currentKey = ffjtSecureDataInternalPassport
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySecureDataPassport, kn) {
					currentKey = ffjtSecureDataPassport
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySecureDataPersonalDetails, kn) {
					currentKey = ffjtSecureDataPersonalDetails
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtSecureDatanosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtSecureDataPersonalDetails:
					goto handle_PersonalDetails

				case ffjtSecureDataPassport:
					goto handle_Passport

				case ffjtSecureDataInternalPassport:
					goto handle_InternalPassport

				case ffjtSecureDataDriverLicense:
					goto handle_DriverLicense

				case ffjtSecureDataIdentityCard:
					goto handle_IdentityCard

				case ffjtSecureDataAddress:
					goto handle_Address

				case ffjtSecureDataUtilityBill:
					goto handle_UtilityBill

				case ffjtSecureDataBankStatement:
					goto handle_BankStatement

				case ffjtSecureDataRentalAgreement:
					goto handle_RentalAgreement

				case ffjtSecureDataPassportRegistration:
					goto handle_PassportRegistration

				case ffjtSecureDataTemporaryRegistration:
					goto handle_TemporaryRegistration

				case ffjtSecureDatanosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_PersonalDetails:

	/* handler: j.PersonalDetails type=telegram.SecureValue kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.PersonalDetails = nil

		} else {

			if j.PersonalDetails == nil {
				j.PersonalDetails = new(SecureValue)
			}

			err = j.PersonalDetails.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Passport:

	/* handler: j.Passport type=telegram.SecureValue kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Passport = nil

		} else {

			if j.Passport == nil {
				j.Passport = new(SecureValue)
			}

			err = j.Passport.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InternalPassport:

	/* handler: j.InternalPassport type=telegram.SecureValue kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.InternalPassport = nil

		} else {

			if j.InternalPassport == nil {
				j.InternalPassport = new(SecureValue)
			}

			err = j.InternalPassport.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DriverLicense:

	/* handler: j.DriverLicense type=telegram.SecureValue kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.DriverLicense = nil

		} else {

			if j.DriverLicense == nil {
				j.DriverLicense = new(SecureValue)
			}

			err = j.DriverLicense.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IdentityCard:

	/* handler: j.IdentityCard type=telegram.SecureValue kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.IdentityCard = nil

		} else {

			if j.IdentityCard == nil {
				j.IdentityCard = new(SecureValue)
			}

			err = j.IdentityCard.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Address:

	/* handler: j.Address type=telegram.SecureValue kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Address = nil

		} else {

			if j.Address == nil {
				j.Address = new(SecureValue)
			}

			err = j.Address.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UtilityBill:

	/* handler: j.UtilityBill type=telegram.SecureValue kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.UtilityBill = nil

		} else {

			if j.UtilityBill == nil {
				j.UtilityBill = new(SecureValue)
			}

			err = j.UtilityBill.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BankStatement:

	/* handler: j.BankStatement type=telegram.SecureValue kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.BankStatement = nil

		} else {

			if j.BankStatement == nil {
				j.BankStatement = new(SecureValue)
			}

			err = j.BankStatement.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RentalAgreement:

	/* handler: j.RentalAgreement type=telegram.SecureValue kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.RentalAgreement = nil

		} else {

			if j.RentalAgreement == nil {
				j.RentalAgreement = new(SecureValue)
			}

			err = j.RentalAgreement.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PassportRegistration:

	/* handler: j.PassportRegistration type=telegram.SecureValue kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.PassportRegistration = nil

		} else {

			if j.PassportRegistration == nil {
				j.PassportRegistration = new(SecureValue)
			}

			err = j.PassportRegistration.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TemporaryRegistration:

	/* handler: j.TemporaryRegistration type=telegram.SecureValue kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.TemporaryRegistration = nil

		} else {

			if j.TemporaryRegistration == nil {
				j.TemporaryRegistration = new(SecureValue)
			}

			err = j.TemporaryRegistration.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *SecureValue) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *SecureValue) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if j.Data != nil {
		if true {
			buf.WriteString(`"data":`)

			{

				err = j.Data.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.FrontSide != nil {
		if true {
			buf.WriteString(`"front_side":`)

			{

				err = j.FrontSide.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ReverseSide != nil {
		if true {
			buf.WriteString(`"reverse_side":`)

			{

				err = j.ReverseSide.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Selfie != nil {
		if true {
			buf.WriteString(`"selfie":`)

			{

				err = j.Selfie.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.Translation) != 0 {
		buf.WriteString(`"translation":`)
		if j.Translation != nil {
			buf.WriteString(`[`)
			for i, v := range j.Translation {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Files) != 0 {
		buf.WriteString(`"files":`)
		if j.Files != nil {
			buf.WriteString(`[`)
			for i, v := range j.Files {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtSecureValuebase = iota
	ffjtSecureValuenosuchkey

	ffjtSecureValueData

	ffjtSecureValueFrontSide

	ffjtSecureValueReverseSide

	ffjtSecureValueSelfie

	ffjtSecureValueTranslation

	ffjtSecureValueFiles
)

var ffjKeySecureValueData = []byte("data")

var ffjKeySecureValueFrontSide = []byte("front_side")

var ffjKeySecureValueReverseSide = []byte("reverse_side")

var ffjKeySecureValueSelfie = []byte("selfie")

var ffjKeySecureValueTranslation = []byte("translation")

var ffjKeySecureValueFiles = []byte("files")

// UnmarshalJSON umarshall json - template of ffjson
func (j *SecureValue) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *SecureValue) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtSecureValuebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtSecureValuenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeySecureValueData, kn) {
						currentKey = ffjtSecureValueData
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeySecureValueFrontSide, kn) {
						currentKey = ffjtSecureValueFrontSide
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySecureValueFiles, kn) {
						currentKey = ffjtSecureValueFiles
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeySecureValueReverseSide, kn) {
						currentKey = ffjtSecureValueReverseSide
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeySecureValueSelfie, kn) {
						currentKey = ffjtSecureValueSelfie
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeySecureValueTranslation, kn) {
						currentKey = ffjtSecureValueTranslation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeySecureValueFiles, kn) {
					currentKey = ffjtSecureValueFiles
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySecureValueTranslation, kn) {
					currentKey = ffjtSecureValueTranslation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySecureValueSelfie, kn) {
					currentKey = ffjtSecureValueSelfie
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySecureValueReverseSide, kn) {
					currentKey = ffjtSecureValueReverseSide
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySecureValueFrontSide, kn) {
					currentKey = ffjtSecureValueFrontSide
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySecureValueData, kn) {
					currentKey = ffjtSecureValueData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtSecureValuenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtSecureValueData:
					goto handle_Data

				case ffjtSecureValueFrontSide:
					goto handle_FrontSide

				case ffjtSecureValueReverseSide:
					goto handle_ReverseSide

				case ffjtSecureValueSelfie:
					goto handle_Selfie

				case ffjtSecureValueTranslation:
					goto handle_Translation

				case ffjtSecureValueFiles:
					goto handle_Files

				case ffjtSecureValuenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Data:

	/* handler: j.Data type=telegram.DataCredentials kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Data = nil

		} else {

			if j.Data == nil {
				j.Data = new(DataCredentials)
			}

			err = j.Data.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FrontSide:

	/* handler: j.FrontSide type=telegram.FileCredentials kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.FrontSide = nil

		} else {

			if j.FrontSide == nil {
				j.FrontSide = new(FileCredentials)
			}

			err = j.FrontSide.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReverseSide:

	/* handler: j.ReverseSide type=telegram.FileCredentials kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReverseSide = nil

		} else {

			if j.ReverseSide == nil {
				j.ReverseSide = new(FileCredentials)
			}

			err = j.ReverseSide.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Selfie:

	/* handler: j.Selfie type=telegram.FileCredentials kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Selfie = nil

		} else {

			if j.Selfie == nil {
				j.Selfie = new(FileCredentials)
			}

			err = j.Selfie.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Translation:

	/* handler: j.Translation type=[]telegram.FileCredentials kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Translation = nil
		} else {

			j.Translation = []FileCredentials{}

			wantVal := true

			for {

				var tmpJTranslation FileCredentials

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJTranslation type=telegram.FileCredentials kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJTranslation.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Translation = append(j.Translation, tmpJTranslation)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Files:

	/* handler: j.Files type=[]telegram.FileCredentials kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Files = nil
		} else {

			j.Files = []FileCredentials{}

			wantVal := true

			for {

				var tmpJFiles FileCredentials

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJFiles type=telegram.FileCredentials kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJFiles.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Files = append(j.Files, tmpJFiles)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ShippingAddress) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ShippingAddress) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"country_code":`)
	fflib.WriteJsonString(buf, string(j.CountryCode))
	buf.WriteString(`,"state":`)
	fflib.WriteJsonString(buf, string(j.State))
	buf.WriteString(`,"city":`)
	fflib.WriteJsonString(buf, string(j.City))
	buf.WriteString(`,"street_line1":`)
	fflib.WriteJsonString(buf, string(j.StreetLine1))
	buf.WriteString(`,"street_line2":`)
	fflib.WriteJsonString(buf, string(j.StreetLine2))
	buf.WriteString(`,"post_code":`)
	fflib.WriteJsonString(buf, string(j.PostCode))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtShippingAddressbase = iota
	ffjtShippingAddressnosuchkey

	ffjtShippingAddressCountryCode

	ffjtShippingAddressState

	ffjtShippingAddressCity

	ffjtShippingAddressStreetLine1

	ffjtShippingAddressStreetLine2

	ffjtShippingAddressPostCode
)

var ffjKeyShippingAddressCountryCode = []byte("country_code")

var ffjKeyShippingAddressState = []byte("state")

var ffjKeyShippingAddressCity = []byte("city")

var ffjKeyShippingAddressStreetLine1 = []byte("street_line1")

var ffjKeyShippingAddressStreetLine2 = []byte("street_line2")

var ffjKeyShippingAddressPostCode = []byte("post_code")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ShippingAddress) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ShippingAddress) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtShippingAddressbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtShippingAddressnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyShippingAddressCountryCode, kn) {
						currentKey = ffjtShippingAddressCountryCode
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyShippingAddressCity, kn) {
						currentKey = ffjtShippingAddressCity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyShippingAddressPostCode, kn) {
						currentKey = ffjtShippingAddressPostCode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyShippingAddressState, kn) {
						currentKey = ffjtShippingAddressState
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyShippingAddressStreetLine1, kn) {
						currentKey = ffjtShippingAddressStreetLine1
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyShippingAddressStreetLine2, kn) {
						currentKey = ffjtShippingAddressStreetLine2
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyShippingAddressPostCode, kn) {
					currentKey = ffjtShippingAddressPostCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShippingAddressStreetLine2, kn) {
					currentKey = ffjtShippingAddressStreetLine2
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShippingAddressStreetLine1, kn) {
					currentKey = ffjtShippingAddressStreetLine1
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyShippingAddressCity, kn) {
					currentKey = ffjtShippingAddressCity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShippingAddressState, kn) {
					currentKey = ffjtShippingAddressState
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyShippingAddressCountryCode, kn) {
					currentKey = ffjtShippingAddressCountryCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtShippingAddressnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtShippingAddressCountryCode:
					goto handle_CountryCode

				case ffjtShippingAddressState:
					goto handle_State

				case ffjtShippingAddressCity:
					goto handle_City

				case ffjtShippingAddressStreetLine1:
					goto handle_StreetLine1

				case ffjtShippingAddressStreetLine2:
					goto handle_StreetLine2

				case ffjtShippingAddressPostCode:
					goto handle_PostCode

				case ffjtShippingAddressnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_CountryCode:

	/* handler: j.CountryCode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CountryCode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_State:

	/* handler: j.State type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.State = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_City:

	/* handler: j.City type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.City = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StreetLine1:

	/* handler: j.StreetLine1 type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.StreetLine1 = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StreetLine2:

	/* handler: j.StreetLine2 type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.StreetLine2 = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PostCode:

	/* handler: j.PostCode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PostCode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ShippingOption) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ShippingOption) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteString(`,"prices":`)
	if j.Prices != nil {
		buf.WriteString(`[`)
		for i, v := range j.Prices {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtShippingOptionbase = iota
	ffjtShippingOptionnosuchkey

	ffjtShippingOptionID

	ffjtShippingOptionTitle

	ffjtShippingOptionPrices
)

var ffjKeyShippingOptionID = []byte("id")

var ffjKeyShippingOptionTitle = []byte("title")

var ffjKeyShippingOptionPrices = []byte("prices")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ShippingOption) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ShippingOption) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtShippingOptionbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtShippingOptionnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffjKeyShippingOptionID, kn) {
						currentKey = ffjtShippingOptionID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyShippingOptionPrices, kn) {
						currentKey = ffjtShippingOptionPrices
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyShippingOptionTitle, kn) {
						currentKey = ffjtShippingOptionTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyShippingOptionPrices, kn) {
					currentKey = ffjtShippingOptionPrices
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyShippingOptionTitle, kn) {
					currentKey = ffjtShippingOptionTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyShippingOptionID, kn) {
					currentKey = ffjtShippingOptionID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtShippingOptionnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtShippingOptionID:
					goto handle_ID

				case ffjtShippingOptionTitle:
					goto handle_Title

				case ffjtShippingOptionPrices:
					goto handle_Prices

				case ffjtShippingOptionnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Prices:

	/* handler: j.Prices type=[]telegram.LabeledPrice kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Prices = nil
		} else {

			j.Prices = []LabeledPrice{}

			wantVal := true

			for {

				var tmpJPrices LabeledPrice

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJPrices type=telegram.LabeledPrice kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJPrices.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Prices = append(j.Prices, tmpJPrices)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ShippingQuery) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ShippingQuery) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"invoice_payload":`)
	fflib.WriteJsonString(buf, string(j.InvoicePayload))
	if j.From != nil {
		buf.WriteString(`,"from":`)

		{

			err = j.From.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"from":null`)
	}
	if j.ShippingAddress != nil {
		buf.WriteString(`,"shipping_address":`)

		{

			err = j.ShippingAddress.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"shipping_address":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtShippingQuerybase = iota
	ffjtShippingQuerynosuchkey

	ffjtShippingQueryID

	ffjtShippingQueryInvoicePayload

	ffjtShippingQueryFrom

	ffjtShippingQueryShippingAddress
)

var ffjKeyShippingQueryID = []byte("id")

var ffjKeyShippingQueryInvoicePayload = []byte("invoice_payload")

var ffjKeyShippingQueryFrom = []byte("from")

var ffjKeyShippingQueryShippingAddress = []byte("shipping_address")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ShippingQuery) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ShippingQuery) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtShippingQuerybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtShippingQuerynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyShippingQueryFrom, kn) {
						currentKey = ffjtShippingQueryFrom
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyShippingQueryID, kn) {
						currentKey = ffjtShippingQueryID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyShippingQueryInvoicePayload, kn) {
						currentKey = ffjtShippingQueryInvoicePayload
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyShippingQueryShippingAddress, kn) {
						currentKey = ffjtShippingQueryShippingAddress
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyShippingQueryShippingAddress, kn) {
					currentKey = ffjtShippingQueryShippingAddress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyShippingQueryFrom, kn) {
					currentKey = ffjtShippingQueryFrom
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyShippingQueryInvoicePayload, kn) {
					currentKey = ffjtShippingQueryInvoicePayload
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyShippingQueryID, kn) {
					currentKey = ffjtShippingQueryID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtShippingQuerynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtShippingQueryID:
					goto handle_ID

				case ffjtShippingQueryInvoicePayload:
					goto handle_InvoicePayload

				case ffjtShippingQueryFrom:
					goto handle_From

				case ffjtShippingQueryShippingAddress:
					goto handle_ShippingAddress

				case ffjtShippingQuerynosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InvoicePayload:

	/* handler: j.InvoicePayload type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.InvoicePayload = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_From:

	/* handler: j.From type=telegram.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.From = nil

		} else {

			if j.From == nil {
				j.From = new(User)
			}

			err = j.From.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShippingAddress:

	/* handler: j.ShippingAddress type=telegram.ShippingAddress kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ShippingAddress = nil

		} else {

			if j.ShippingAddress == nil {
				j.ShippingAddress = new(ShippingAddress)
			}

			err = j.ShippingAddress.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Sticker) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Sticker) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(j.FileID))
	buf.WriteByte(',')
	if len(j.Emoji) != 0 {
		buf.WriteString(`"emoji":`)
		fflib.WriteJsonString(buf, string(j.Emoji))
		buf.WriteByte(',')
	}
	if len(j.SetName) != 0 {
		buf.WriteString(`"set_name":`)
		fflib.WriteJsonString(buf, string(j.SetName))
		buf.WriteByte(',')
	}
	buf.WriteString(`"width":`)
	fflib.FormatBits2(buf, uint64(j.Width), 10, j.Width < 0)
	buf.WriteString(`,"height":`)
	fflib.FormatBits2(buf, uint64(j.Height), 10, j.Height < 0)
	buf.WriteByte(',')
	if j.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(j.FileSize), 10, j.FileSize < 0)
		buf.WriteByte(',')
	}
	if j.Thumb != nil {
		if true {
			buf.WriteString(`"thumb":`)

			{

				err = j.Thumb.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.MaskPosition != nil {
		if true {
			buf.WriteString(`"mask_position":`)

			{

				err = j.MaskPosition.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtStickerbase = iota
	ffjtStickernosuchkey

	ffjtStickerFileID

	ffjtStickerEmoji

	ffjtStickerSetName

	ffjtStickerWidth

	ffjtStickerHeight

	ffjtStickerFileSize

	ffjtStickerThumb

	ffjtStickerMaskPosition
)

var ffjKeyStickerFileID = []byte("file_id")

var ffjKeyStickerEmoji = []byte("emoji")

var ffjKeyStickerSetName = []byte("set_name")

var ffjKeyStickerWidth = []byte("width")

var ffjKeyStickerHeight = []byte("height")

var ffjKeyStickerFileSize = []byte("file_size")

var ffjKeyStickerThumb = []byte("thumb")

var ffjKeyStickerMaskPosition = []byte("mask_position")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Sticker) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Sticker) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtStickerbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtStickernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffjKeyStickerEmoji, kn) {
						currentKey = ffjtStickerEmoji
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyStickerFileID, kn) {
						currentKey = ffjtStickerFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyStickerFileSize, kn) {
						currentKey = ffjtStickerFileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyStickerHeight, kn) {
						currentKey = ffjtStickerHeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyStickerMaskPosition, kn) {
						currentKey = ffjtStickerMaskPosition
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyStickerSetName, kn) {
						currentKey = ffjtStickerSetName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyStickerThumb, kn) {
						currentKey = ffjtStickerThumb
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyStickerWidth, kn) {
						currentKey = ffjtStickerWidth
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyStickerMaskPosition, kn) {
					currentKey = ffjtStickerMaskPosition
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyStickerThumb, kn) {
					currentKey = ffjtStickerThumb
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyStickerFileSize, kn) {
					currentKey = ffjtStickerFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyStickerHeight, kn) {
					currentKey = ffjtStickerHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyStickerWidth, kn) {
					currentKey = ffjtStickerWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyStickerSetName, kn) {
					currentKey = ffjtStickerSetName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyStickerEmoji, kn) {
					currentKey = ffjtStickerEmoji
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyStickerFileID, kn) {
					currentKey = ffjtStickerFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtStickernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtStickerFileID:
					goto handle_FileID

				case ffjtStickerEmoji:
					goto handle_Emoji

				case ffjtStickerSetName:
					goto handle_SetName

				case ffjtStickerWidth:
					goto handle_Width

				case ffjtStickerHeight:
					goto handle_Height

				case ffjtStickerFileSize:
					goto handle_FileSize

				case ffjtStickerThumb:
					goto handle_Thumb

				case ffjtStickerMaskPosition:
					goto handle_MaskPosition

				case ffjtStickernosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: j.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Emoji:

	/* handler: j.Emoji type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Emoji = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SetName:

	/* handler: j.SetName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.SetName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Width:

	/* handler: j.Width type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Width = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Height:

	/* handler: j.Height type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Height = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: j.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Thumb:

	/* handler: j.Thumb type=telegram.PhotoSize kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Thumb = nil

		} else {

			if j.Thumb == nil {
				j.Thumb = new(PhotoSize)
			}

			err = j.Thumb.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaskPosition:

	/* handler: j.MaskPosition type=telegram.MaskPosition kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.MaskPosition = nil

		} else {

			if j.MaskPosition == nil {
				j.MaskPosition = new(MaskPosition)
			}

			err = j.MaskPosition.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *StickerSet) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *StickerSet) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"name":`)
	fflib.WriteJsonString(buf, string(j.Name))
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	if j.ContainsMasks {
		buf.WriteString(`,"contains_masks":true`)
	} else {
		buf.WriteString(`,"contains_masks":false`)
	}
	buf.WriteString(`,"stickers":`)
	if j.Stickers != nil {
		buf.WriteString(`[`)
		for i, v := range j.Stickers {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtStickerSetbase = iota
	ffjtStickerSetnosuchkey

	ffjtStickerSetName

	ffjtStickerSetTitle

	ffjtStickerSetContainsMasks

	ffjtStickerSetStickers
)

var ffjKeyStickerSetName = []byte("name")

var ffjKeyStickerSetTitle = []byte("title")

var ffjKeyStickerSetContainsMasks = []byte("contains_masks")

var ffjKeyStickerSetStickers = []byte("stickers")

// UnmarshalJSON umarshall json - template of ffjson
func (j *StickerSet) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *StickerSet) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtStickerSetbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtStickerSetnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyStickerSetContainsMasks, kn) {
						currentKey = ffjtStickerSetContainsMasks
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyStickerSetName, kn) {
						currentKey = ffjtStickerSetName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyStickerSetStickers, kn) {
						currentKey = ffjtStickerSetStickers
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyStickerSetTitle, kn) {
						currentKey = ffjtStickerSetTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyStickerSetStickers, kn) {
					currentKey = ffjtStickerSetStickers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyStickerSetContainsMasks, kn) {
					currentKey = ffjtStickerSetContainsMasks
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyStickerSetTitle, kn) {
					currentKey = ffjtStickerSetTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyStickerSetName, kn) {
					currentKey = ffjtStickerSetName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtStickerSetnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtStickerSetName:
					goto handle_Name

				case ffjtStickerSetTitle:
					goto handle_Title

				case ffjtStickerSetContainsMasks:
					goto handle_ContainsMasks

				case ffjtStickerSetStickers:
					goto handle_Stickers

				case ffjtStickerSetnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContainsMasks:

	/* handler: j.ContainsMasks type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.ContainsMasks = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.ContainsMasks = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Stickers:

	/* handler: j.Stickers type=[]telegram.Sticker kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Stickers = nil
		} else {

			j.Stickers = []Sticker{}

			wantVal := true

			for {

				var tmpJStickers Sticker

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJStickers type=telegram.Sticker kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJStickers.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Stickers = append(j.Stickers, tmpJStickers)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *SuccessfulPayment) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *SuccessfulPayment) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "currency":`)
	fflib.WriteJsonString(buf, string(j.Currency))
	buf.WriteString(`,"invoice_payload":`)
	fflib.WriteJsonString(buf, string(j.InvoicePayload))
	buf.WriteByte(',')
	if len(j.ShippingOptionID) != 0 {
		buf.WriteString(`"shipping_option_id":`)
		fflib.WriteJsonString(buf, string(j.ShippingOptionID))
		buf.WriteByte(',')
	}
	buf.WriteString(`"telegram_payment_charge_id":`)
	fflib.WriteJsonString(buf, string(j.TelegramPaymentChargeID))
	buf.WriteString(`,"provider_payment_charge_id":`)
	fflib.WriteJsonString(buf, string(j.ProviderPaymentChargeID))
	buf.WriteString(`,"total_amount":`)
	fflib.FormatBits2(buf, uint64(j.TotalAmount), 10, j.TotalAmount < 0)
	buf.WriteByte(',')
	if j.OrderInfo != nil {
		if true {
			buf.WriteString(`"order_info":`)

			{

				err = j.OrderInfo.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtSuccessfulPaymentbase = iota
	ffjtSuccessfulPaymentnosuchkey

	ffjtSuccessfulPaymentCurrency

	ffjtSuccessfulPaymentInvoicePayload

	ffjtSuccessfulPaymentShippingOptionID

	ffjtSuccessfulPaymentTelegramPaymentChargeID

	ffjtSuccessfulPaymentProviderPaymentChargeID

	ffjtSuccessfulPaymentTotalAmount

	ffjtSuccessfulPaymentOrderInfo
)

var ffjKeySuccessfulPaymentCurrency = []byte("currency")

var ffjKeySuccessfulPaymentInvoicePayload = []byte("invoice_payload")

var ffjKeySuccessfulPaymentShippingOptionID = []byte("shipping_option_id")

var ffjKeySuccessfulPaymentTelegramPaymentChargeID = []byte("telegram_payment_charge_id")

var ffjKeySuccessfulPaymentProviderPaymentChargeID = []byte("provider_payment_charge_id")

var ffjKeySuccessfulPaymentTotalAmount = []byte("total_amount")

var ffjKeySuccessfulPaymentOrderInfo = []byte("order_info")

// UnmarshalJSON umarshall json - template of ffjson
func (j *SuccessfulPayment) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *SuccessfulPayment) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtSuccessfulPaymentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtSuccessfulPaymentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeySuccessfulPaymentCurrency, kn) {
						currentKey = ffjtSuccessfulPaymentCurrency
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeySuccessfulPaymentInvoicePayload, kn) {
						currentKey = ffjtSuccessfulPaymentInvoicePayload
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeySuccessfulPaymentOrderInfo, kn) {
						currentKey = ffjtSuccessfulPaymentOrderInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeySuccessfulPaymentProviderPaymentChargeID, kn) {
						currentKey = ffjtSuccessfulPaymentProviderPaymentChargeID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeySuccessfulPaymentShippingOptionID, kn) {
						currentKey = ffjtSuccessfulPaymentShippingOptionID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeySuccessfulPaymentTelegramPaymentChargeID, kn) {
						currentKey = ffjtSuccessfulPaymentTelegramPaymentChargeID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySuccessfulPaymentTotalAmount, kn) {
						currentKey = ffjtSuccessfulPaymentTotalAmount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeySuccessfulPaymentOrderInfo, kn) {
					currentKey = ffjtSuccessfulPaymentOrderInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySuccessfulPaymentTotalAmount, kn) {
					currentKey = ffjtSuccessfulPaymentTotalAmount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySuccessfulPaymentProviderPaymentChargeID, kn) {
					currentKey = ffjtSuccessfulPaymentProviderPaymentChargeID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySuccessfulPaymentTelegramPaymentChargeID, kn) {
					currentKey = ffjtSuccessfulPaymentTelegramPaymentChargeID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySuccessfulPaymentShippingOptionID, kn) {
					currentKey = ffjtSuccessfulPaymentShippingOptionID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySuccessfulPaymentInvoicePayload, kn) {
					currentKey = ffjtSuccessfulPaymentInvoicePayload
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySuccessfulPaymentCurrency, kn) {
					currentKey = ffjtSuccessfulPaymentCurrency
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtSuccessfulPaymentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtSuccessfulPaymentCurrency:
					goto handle_Currency

				case ffjtSuccessfulPaymentInvoicePayload:
					goto handle_InvoicePayload

				case ffjtSuccessfulPaymentShippingOptionID:
					goto handle_ShippingOptionID

				case ffjtSuccessfulPaymentTelegramPaymentChargeID:
					goto handle_TelegramPaymentChargeID

				case ffjtSuccessfulPaymentProviderPaymentChargeID:
					goto handle_ProviderPaymentChargeID

				case ffjtSuccessfulPaymentTotalAmount:
					goto handle_TotalAmount

				case ffjtSuccessfulPaymentOrderInfo:
					goto handle_OrderInfo

				case ffjtSuccessfulPaymentnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Currency:

	/* handler: j.Currency type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Currency = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InvoicePayload:

	/* handler: j.InvoicePayload type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.InvoicePayload = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShippingOptionID:

	/* handler: j.ShippingOptionID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ShippingOptionID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TelegramPaymentChargeID:

	/* handler: j.TelegramPaymentChargeID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.TelegramPaymentChargeID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProviderPaymentChargeID:

	/* handler: j.ProviderPaymentChargeID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ProviderPaymentChargeID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalAmount:

	/* handler: j.TotalAmount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.TotalAmount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OrderInfo:

	/* handler: j.OrderInfo type=telegram.OrderInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.OrderInfo = nil

		} else {

			if j.OrderInfo == nil {
				j.OrderInfo = new(OrderInfo)
			}

			err = j.OrderInfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Update) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Update) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "update_id":`)
	fflib.FormatBits2(buf, uint64(j.ID), 10, j.ID < 0)
	buf.WriteByte(',')
	if j.Message != nil {
		if true {
			buf.WriteString(`"message":`)

			{

				err = j.Message.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.EditedMessage != nil {
		if true {
			buf.WriteString(`"edited_message":`)

			{

				err = j.EditedMessage.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ChannelPost != nil {
		if true {
			buf.WriteString(`"channel_post":`)

			{

				err = j.ChannelPost.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.EditedChannelPost != nil {
		if true {
			buf.WriteString(`"adited_channel_post":`)

			{

				err = j.EditedChannelPost.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.InlineQuery != nil {
		if true {
			buf.WriteString(`"inline_query":`)

			{

				err = j.InlineQuery.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ChosenInlineResult != nil {
		if true {
			buf.WriteString(`"chosen_inline_result":`)

			{

				err = j.ChosenInlineResult.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.CallbackQuery != nil {
		if true {
			buf.WriteString(`"callback_query":`)

			{

				err = j.CallbackQuery.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ShippingQuery != nil {
		if true {
			buf.WriteString(`"shipping_query":`)

			{

				err = j.ShippingQuery.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.PreCheckoutQuery != nil {
		if true {
			buf.WriteString(`"pre_checkout_query":`)

			{

				err = j.PreCheckoutQuery.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Poll != nil {
		if true {
			buf.WriteString(`"poll":`)

			{

				err = j.Poll.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtUpdatebase = iota
	ffjtUpdatenosuchkey

	ffjtUpdateID

	ffjtUpdateMessage

	ffjtUpdateEditedMessage

	ffjtUpdateChannelPost

	ffjtUpdateEditedChannelPost

	ffjtUpdateInlineQuery

	ffjtUpdateChosenInlineResult

	ffjtUpdateCallbackQuery

	ffjtUpdateShippingQuery

	ffjtUpdatePreCheckoutQuery

	ffjtUpdatePoll
)

var ffjKeyUpdateID = []byte("update_id")

var ffjKeyUpdateMessage = []byte("message")

var ffjKeyUpdateEditedMessage = []byte("edited_message")

var ffjKeyUpdateChannelPost = []byte("channel_post")

var ffjKeyUpdateEditedChannelPost = []byte("adited_channel_post")

var ffjKeyUpdateInlineQuery = []byte("inline_query")

var ffjKeyUpdateChosenInlineResult = []byte("chosen_inline_result")

var ffjKeyUpdateCallbackQuery = []byte("callback_query")

var ffjKeyUpdateShippingQuery = []byte("shipping_query")

var ffjKeyUpdatePreCheckoutQuery = []byte("pre_checkout_query")

var ffjKeyUpdatePoll = []byte("poll")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Update) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Update) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtUpdatebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtUpdatenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyUpdateEditedChannelPost, kn) {
						currentKey = ffjtUpdateEditedChannelPost
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyUpdateChannelPost, kn) {
						currentKey = ffjtUpdateChannelPost
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUpdateChosenInlineResult, kn) {
						currentKey = ffjtUpdateChosenInlineResult
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUpdateCallbackQuery, kn) {
						currentKey = ffjtUpdateCallbackQuery
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyUpdateEditedMessage, kn) {
						currentKey = ffjtUpdateEditedMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyUpdateInlineQuery, kn) {
						currentKey = ffjtUpdateInlineQuery
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyUpdateMessage, kn) {
						currentKey = ffjtUpdateMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyUpdatePreCheckoutQuery, kn) {
						currentKey = ffjtUpdatePreCheckoutQuery
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUpdatePoll, kn) {
						currentKey = ffjtUpdatePoll
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyUpdateShippingQuery, kn) {
						currentKey = ffjtUpdateShippingQuery
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyUpdateID, kn) {
						currentKey = ffjtUpdateID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyUpdatePoll, kn) {
					currentKey = ffjtUpdatePoll
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUpdatePreCheckoutQuery, kn) {
					currentKey = ffjtUpdatePreCheckoutQuery
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUpdateShippingQuery, kn) {
					currentKey = ffjtUpdateShippingQuery
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUpdateCallbackQuery, kn) {
					currentKey = ffjtUpdateCallbackQuery
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUpdateChosenInlineResult, kn) {
					currentKey = ffjtUpdateChosenInlineResult
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUpdateInlineQuery, kn) {
					currentKey = ffjtUpdateInlineQuery
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUpdateEditedChannelPost, kn) {
					currentKey = ffjtUpdateEditedChannelPost
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUpdateChannelPost, kn) {
					currentKey = ffjtUpdateChannelPost
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUpdateEditedMessage, kn) {
					currentKey = ffjtUpdateEditedMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUpdateMessage, kn) {
					currentKey = ffjtUpdateMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUpdateID, kn) {
					currentKey = ffjtUpdateID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtUpdatenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtUpdateID:
					goto handle_ID

				case ffjtUpdateMessage:
					goto handle_Message

				case ffjtUpdateEditedMessage:
					goto handle_EditedMessage

				case ffjtUpdateChannelPost:
					goto handle_ChannelPost

				case ffjtUpdateEditedChannelPost:
					goto handle_EditedChannelPost

				case ffjtUpdateInlineQuery:
					goto handle_InlineQuery

				case ffjtUpdateChosenInlineResult:
					goto handle_ChosenInlineResult

				case ffjtUpdateCallbackQuery:
					goto handle_CallbackQuery

				case ffjtUpdateShippingQuery:
					goto handle_ShippingQuery

				case ffjtUpdatePreCheckoutQuery:
					goto handle_PreCheckoutQuery

				case ffjtUpdatePoll:
					goto handle_Poll

				case ffjtUpdatenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: j.Message type=telegram.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Message = nil

		} else {

			if j.Message == nil {
				j.Message = new(Message)
			}

			err = j.Message.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EditedMessage:

	/* handler: j.EditedMessage type=telegram.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.EditedMessage = nil

		} else {

			if j.EditedMessage == nil {
				j.EditedMessage = new(Message)
			}

			err = j.EditedMessage.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelPost:

	/* handler: j.ChannelPost type=telegram.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ChannelPost = nil

		} else {

			if j.ChannelPost == nil {
				j.ChannelPost = new(Message)
			}

			err = j.ChannelPost.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EditedChannelPost:

	/* handler: j.EditedChannelPost type=telegram.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.EditedChannelPost = nil

		} else {

			if j.EditedChannelPost == nil {
				j.EditedChannelPost = new(Message)
			}

			err = j.EditedChannelPost.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InlineQuery:

	/* handler: j.InlineQuery type=telegram.InlineQuery kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.InlineQuery = nil

		} else {

			if j.InlineQuery == nil {
				j.InlineQuery = new(InlineQuery)
			}

			err = j.InlineQuery.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChosenInlineResult:

	/* handler: j.ChosenInlineResult type=telegram.ChosenInlineResult kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ChosenInlineResult = nil

		} else {

			if j.ChosenInlineResult == nil {
				j.ChosenInlineResult = new(ChosenInlineResult)
			}

			err = j.ChosenInlineResult.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CallbackQuery:

	/* handler: j.CallbackQuery type=telegram.CallbackQuery kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.CallbackQuery = nil

		} else {

			if j.CallbackQuery == nil {
				j.CallbackQuery = new(CallbackQuery)
			}

			err = j.CallbackQuery.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShippingQuery:

	/* handler: j.ShippingQuery type=telegram.ShippingQuery kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ShippingQuery = nil

		} else {

			if j.ShippingQuery == nil {
				j.ShippingQuery = new(ShippingQuery)
			}

			err = j.ShippingQuery.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PreCheckoutQuery:

	/* handler: j.PreCheckoutQuery type=telegram.PreCheckoutQuery kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.PreCheckoutQuery = nil

		} else {

			if j.PreCheckoutQuery == nil {
				j.PreCheckoutQuery = new(PreCheckoutQuery)
			}

			err = j.PreCheckoutQuery.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Poll:

	/* handler: j.Poll type=telegram.Poll kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Poll = nil

		} else {

			if j.Poll == nil {
				j.Poll = new(Poll)
			}

			err = j.Poll.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *User) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *User) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)
	fflib.FormatBits2(buf, uint64(j.ID), 10, j.ID < 0)
	if j.IsBot {
		buf.WriteString(`,"is_bot":true`)
	} else {
		buf.WriteString(`,"is_bot":false`)
	}
	buf.WriteString(`,"first_name":`)
	fflib.WriteJsonString(buf, string(j.FirstName))
	buf.WriteByte(',')
	if len(j.LastName) != 0 {
		buf.WriteString(`"last_name":`)
		fflib.WriteJsonString(buf, string(j.LastName))
		buf.WriteByte(',')
	}
	if len(j.Username) != 0 {
		buf.WriteString(`"username":`)
		fflib.WriteJsonString(buf, string(j.Username))
		buf.WriteByte(',')
	}
	if len(j.LanguageCode) != 0 {
		buf.WriteString(`"language_code":`)
		fflib.WriteJsonString(buf, string(j.LanguageCode))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtUserbase = iota
	ffjtUsernosuchkey

	ffjtUserID

	ffjtUserIsBot

	ffjtUserFirstName

	ffjtUserLastName

	ffjtUserUsername

	ffjtUserLanguageCode
)

var ffjKeyUserID = []byte("id")

var ffjKeyUserIsBot = []byte("is_bot")

var ffjKeyUserFirstName = []byte("first_name")

var ffjKeyUserLastName = []byte("last_name")

var ffjKeyUserUsername = []byte("username")

var ffjKeyUserLanguageCode = []byte("language_code")

// UnmarshalJSON umarshall json - template of ffjson
func (j *User) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *User) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtUserbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtUsernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyUserFirstName, kn) {
						currentKey = ffjtUserFirstName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyUserID, kn) {
						currentKey = ffjtUserID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserIsBot, kn) {
						currentKey = ffjtUserIsBot
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyUserLastName, kn) {
						currentKey = ffjtUserLastName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserLanguageCode, kn) {
						currentKey = ffjtUserLanguageCode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyUserUsername, kn) {
						currentKey = ffjtUserUsername
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyUserLanguageCode, kn) {
					currentKey = ffjtUserLanguageCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserUsername, kn) {
					currentKey = ffjtUserUsername
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserLastName, kn) {
					currentKey = ffjtUserLastName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserFirstName, kn) {
					currentKey = ffjtUserFirstName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserIsBot, kn) {
					currentKey = ffjtUserIsBot
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyUserID, kn) {
					currentKey = ffjtUserID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtUsernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtUserID:
					goto handle_ID

				case ffjtUserIsBot:
					goto handle_IsBot

				case ffjtUserFirstName:
					goto handle_FirstName

				case ffjtUserLastName:
					goto handle_LastName

				case ffjtUserUsername:
					goto handle_Username

				case ffjtUserLanguageCode:
					goto handle_LanguageCode

				case ffjtUsernosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsBot:

	/* handler: j.IsBot type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.IsBot = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.IsBot = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FirstName:

	/* handler: j.FirstName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FirstName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastName:

	/* handler: j.LastName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LastName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Username:

	/* handler: j.Username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LanguageCode:

	/* handler: j.LanguageCode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LanguageCode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *UserProfilePhotos) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *UserProfilePhotos) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"total_count":`)
	fflib.FormatBits2(buf, uint64(j.TotalCount), 10, j.TotalCount < 0)
	buf.WriteString(`,"photos":`)
	if j.Photos != nil {
		buf.WriteString(`[`)
		for i, v := range j.Photos {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				buf.WriteString(`[`)
				for i, v := range v {
					if i != 0 {
						buf.WriteString(`,`)
					}

					{

						err = v.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}
				}
				buf.WriteString(`]`)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtUserProfilePhotosbase = iota
	ffjtUserProfilePhotosnosuchkey

	ffjtUserProfilePhotosTotalCount

	ffjtUserProfilePhotosPhotos
)

var ffjKeyUserProfilePhotosTotalCount = []byte("total_count")

var ffjKeyUserProfilePhotosPhotos = []byte("photos")

// UnmarshalJSON umarshall json - template of ffjson
func (j *UserProfilePhotos) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *UserProfilePhotos) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtUserProfilePhotosbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtUserProfilePhotosnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffjKeyUserProfilePhotosPhotos, kn) {
						currentKey = ffjtUserProfilePhotosPhotos
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyUserProfilePhotosTotalCount, kn) {
						currentKey = ffjtUserProfilePhotosTotalCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyUserProfilePhotosPhotos, kn) {
					currentKey = ffjtUserProfilePhotosPhotos
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserProfilePhotosTotalCount, kn) {
					currentKey = ffjtUserProfilePhotosTotalCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtUserProfilePhotosnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtUserProfilePhotosTotalCount:
					goto handle_TotalCount

				case ffjtUserProfilePhotosPhotos:
					goto handle_Photos

				case ffjtUserProfilePhotosnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_TotalCount:

	/* handler: j.TotalCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.TotalCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Photos:

	/* handler: j.Photos type=[][]telegram.PhotoSize kind=slice quoted=false*/

	{
		/* Falling back. type=[][]telegram.PhotoSize kind=slice */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Photos)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Venue) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Venue) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.Location != nil {
		buf.WriteString(`{ "location":`)

		{

			err = j.Location.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`{ "location":null`)
	}
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteString(`,"address":`)
	fflib.WriteJsonString(buf, string(j.Address))
	buf.WriteByte(',')
	if len(j.FoursquareID) != 0 {
		buf.WriteString(`"foursquare_id":`)
		fflib.WriteJsonString(buf, string(j.FoursquareID))
		buf.WriteByte(',')
	}
	if len(j.FoursquareType) != 0 {
		buf.WriteString(`"foursquare_type":`)
		fflib.WriteJsonString(buf, string(j.FoursquareType))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtVenuebase = iota
	ffjtVenuenosuchkey

	ffjtVenueLocation

	ffjtVenueTitle

	ffjtVenueAddress

	ffjtVenueFoursquareID

	ffjtVenueFoursquareType
)

var ffjKeyVenueLocation = []byte("location")

var ffjKeyVenueTitle = []byte("title")

var ffjKeyVenueAddress = []byte("address")

var ffjKeyVenueFoursquareID = []byte("foursquare_id")

var ffjKeyVenueFoursquareType = []byte("foursquare_type")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Venue) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Venue) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtVenuebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtVenuenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyVenueAddress, kn) {
						currentKey = ffjtVenueAddress
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyVenueFoursquareID, kn) {
						currentKey = ffjtVenueFoursquareID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyVenueFoursquareType, kn) {
						currentKey = ffjtVenueFoursquareType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyVenueLocation, kn) {
						currentKey = ffjtVenueLocation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyVenueTitle, kn) {
						currentKey = ffjtVenueTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyVenueFoursquareType, kn) {
					currentKey = ffjtVenueFoursquareType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyVenueFoursquareID, kn) {
					currentKey = ffjtVenueFoursquareID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyVenueAddress, kn) {
					currentKey = ffjtVenueAddress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVenueTitle, kn) {
					currentKey = ffjtVenueTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVenueLocation, kn) {
					currentKey = ffjtVenueLocation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtVenuenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtVenueLocation:
					goto handle_Location

				case ffjtVenueTitle:
					goto handle_Title

				case ffjtVenueAddress:
					goto handle_Address

				case ffjtVenueFoursquareID:
					goto handle_FoursquareID

				case ffjtVenueFoursquareType:
					goto handle_FoursquareType

				case ffjtVenuenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Location:

	/* handler: j.Location type=telegram.Location kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Location = nil

		} else {

			if j.Location == nil {
				j.Location = new(Location)
			}

			err = j.Location.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Address:

	/* handler: j.Address type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Address = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FoursquareID:

	/* handler: j.FoursquareID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FoursquareID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FoursquareType:

	/* handler: j.FoursquareType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FoursquareType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Video) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Video) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(j.FileID))
	buf.WriteByte(',')
	if len(j.MimeType) != 0 {
		buf.WriteString(`"mime_type":`)
		fflib.WriteJsonString(buf, string(j.MimeType))
		buf.WriteByte(',')
	}
	buf.WriteString(`"width":`)
	fflib.FormatBits2(buf, uint64(j.Width), 10, j.Width < 0)
	buf.WriteString(`,"height":`)
	fflib.FormatBits2(buf, uint64(j.Height), 10, j.Height < 0)
	buf.WriteString(`,"duration":`)
	fflib.FormatBits2(buf, uint64(j.Duration), 10, j.Duration < 0)
	buf.WriteByte(',')
	if j.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(j.FileSize), 10, j.FileSize < 0)
		buf.WriteByte(',')
	}
	if j.Thumb != nil {
		if true {
			buf.WriteString(`"thumb":`)

			{

				err = j.Thumb.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtVideobase = iota
	ffjtVideonosuchkey

	ffjtVideoFileID

	ffjtVideoMimeType

	ffjtVideoWidth

	ffjtVideoHeight

	ffjtVideoDuration

	ffjtVideoFileSize

	ffjtVideoThumb
)

var ffjKeyVideoFileID = []byte("file_id")

var ffjKeyVideoMimeType = []byte("mime_type")

var ffjKeyVideoWidth = []byte("width")

var ffjKeyVideoHeight = []byte("height")

var ffjKeyVideoDuration = []byte("duration")

var ffjKeyVideoFileSize = []byte("file_size")

var ffjKeyVideoThumb = []byte("thumb")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Video) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Video) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtVideobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtVideonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyVideoDuration, kn) {
						currentKey = ffjtVideoDuration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyVideoFileID, kn) {
						currentKey = ffjtVideoFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyVideoFileSize, kn) {
						currentKey = ffjtVideoFileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyVideoHeight, kn) {
						currentKey = ffjtVideoHeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyVideoMimeType, kn) {
						currentKey = ffjtVideoMimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyVideoThumb, kn) {
						currentKey = ffjtVideoThumb
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyVideoWidth, kn) {
						currentKey = ffjtVideoWidth
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyVideoThumb, kn) {
					currentKey = ffjtVideoThumb
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyVideoFileSize, kn) {
					currentKey = ffjtVideoFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVideoDuration, kn) {
					currentKey = ffjtVideoDuration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVideoHeight, kn) {
					currentKey = ffjtVideoHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVideoWidth, kn) {
					currentKey = ffjtVideoWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyVideoMimeType, kn) {
					currentKey = ffjtVideoMimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyVideoFileID, kn) {
					currentKey = ffjtVideoFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtVideonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtVideoFileID:
					goto handle_FileID

				case ffjtVideoMimeType:
					goto handle_MimeType

				case ffjtVideoWidth:
					goto handle_Width

				case ffjtVideoHeight:
					goto handle_Height

				case ffjtVideoDuration:
					goto handle_Duration

				case ffjtVideoFileSize:
					goto handle_FileSize

				case ffjtVideoThumb:
					goto handle_Thumb

				case ffjtVideonosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: j.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeType:

	/* handler: j.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Width:

	/* handler: j.Width type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Width = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Height:

	/* handler: j.Height type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Height = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: j.Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: j.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Thumb:

	/* handler: j.Thumb type=telegram.PhotoSize kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Thumb = nil

		} else {

			if j.Thumb == nil {
				j.Thumb = new(PhotoSize)
			}

			err = j.Thumb.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *VideoNote) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *VideoNote) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(j.FileID))
	buf.WriteString(`,"length":`)
	fflib.FormatBits2(buf, uint64(j.Length), 10, j.Length < 0)
	buf.WriteString(`,"duration":`)
	fflib.FormatBits2(buf, uint64(j.Duration), 10, j.Duration < 0)
	buf.WriteByte(',')
	if j.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(j.FileSize), 10, j.FileSize < 0)
		buf.WriteByte(',')
	}
	if j.Thumb != nil {
		if true {
			buf.WriteString(`"thumb":`)

			{

				err = j.Thumb.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtVideoNotebase = iota
	ffjtVideoNotenosuchkey

	ffjtVideoNoteFileID

	ffjtVideoNoteLength

	ffjtVideoNoteDuration

	ffjtVideoNoteFileSize

	ffjtVideoNoteThumb
)

var ffjKeyVideoNoteFileID = []byte("file_id")

var ffjKeyVideoNoteLength = []byte("length")

var ffjKeyVideoNoteDuration = []byte("duration")

var ffjKeyVideoNoteFileSize = []byte("file_size")

var ffjKeyVideoNoteThumb = []byte("thumb")

// UnmarshalJSON umarshall json - template of ffjson
func (j *VideoNote) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *VideoNote) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtVideoNotebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtVideoNotenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyVideoNoteDuration, kn) {
						currentKey = ffjtVideoNoteDuration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyVideoNoteFileID, kn) {
						currentKey = ffjtVideoNoteFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyVideoNoteFileSize, kn) {
						currentKey = ffjtVideoNoteFileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyVideoNoteLength, kn) {
						currentKey = ffjtVideoNoteLength
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyVideoNoteThumb, kn) {
						currentKey = ffjtVideoNoteThumb
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyVideoNoteThumb, kn) {
					currentKey = ffjtVideoNoteThumb
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyVideoNoteFileSize, kn) {
					currentKey = ffjtVideoNoteFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVideoNoteDuration, kn) {
					currentKey = ffjtVideoNoteDuration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVideoNoteLength, kn) {
					currentKey = ffjtVideoNoteLength
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyVideoNoteFileID, kn) {
					currentKey = ffjtVideoNoteFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtVideoNotenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtVideoNoteFileID:
					goto handle_FileID

				case ffjtVideoNoteLength:
					goto handle_Length

				case ffjtVideoNoteDuration:
					goto handle_Duration

				case ffjtVideoNoteFileSize:
					goto handle_FileSize

				case ffjtVideoNoteThumb:
					goto handle_Thumb

				case ffjtVideoNotenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: j.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Length:

	/* handler: j.Length type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Length = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: j.Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: j.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Thumb:

	/* handler: j.Thumb type=telegram.PhotoSize kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Thumb = nil

		} else {

			if j.Thumb == nil {
				j.Thumb = new(PhotoSize)
			}

			err = j.Thumb.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Voice) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Voice) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(j.FileID))
	buf.WriteByte(',')
	if len(j.MimeType) != 0 {
		buf.WriteString(`"mime_type":`)
		fflib.WriteJsonString(buf, string(j.MimeType))
		buf.WriteByte(',')
	}
	buf.WriteString(`"duration":`)
	fflib.FormatBits2(buf, uint64(j.Duration), 10, j.Duration < 0)
	buf.WriteByte(',')
	if j.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(j.FileSize), 10, j.FileSize < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtVoicebase = iota
	ffjtVoicenosuchkey

	ffjtVoiceFileID

	ffjtVoiceMimeType

	ffjtVoiceDuration

	ffjtVoiceFileSize
)

var ffjKeyVoiceFileID = []byte("file_id")

var ffjKeyVoiceMimeType = []byte("mime_type")

var ffjKeyVoiceDuration = []byte("duration")

var ffjKeyVoiceFileSize = []byte("file_size")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Voice) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Voice) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtVoicebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtVoicenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyVoiceDuration, kn) {
						currentKey = ffjtVoiceDuration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyVoiceFileID, kn) {
						currentKey = ffjtVoiceFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyVoiceFileSize, kn) {
						currentKey = ffjtVoiceFileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyVoiceMimeType, kn) {
						currentKey = ffjtVoiceMimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyVoiceFileSize, kn) {
					currentKey = ffjtVoiceFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVoiceDuration, kn) {
					currentKey = ffjtVoiceDuration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyVoiceMimeType, kn) {
					currentKey = ffjtVoiceMimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyVoiceFileID, kn) {
					currentKey = ffjtVoiceFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtVoicenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtVoiceFileID:
					goto handle_FileID

				case ffjtVoiceMimeType:
					goto handle_MimeType

				case ffjtVoiceDuration:
					goto handle_Duration

				case ffjtVoiceFileSize:
					goto handle_FileSize

				case ffjtVoicenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: j.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeType:

	/* handler: j.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: j.Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: j.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *WebhookInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *WebhookInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "url":`)
	fflib.WriteJsonString(buf, string(j.URL))
	buf.WriteByte(',')
	if len(j.LastErrorMessage) != 0 {
		buf.WriteString(`"last_error_message":`)
		fflib.WriteJsonString(buf, string(j.LastErrorMessage))
		buf.WriteByte(',')
	}
	if j.HasCustomCertificate {
		buf.WriteString(`"has_custom_certificate":true`)
	} else {
		buf.WriteString(`"has_custom_certificate":false`)
	}
	buf.WriteString(`,"pending_update_count":`)
	fflib.FormatBits2(buf, uint64(j.PendingUpdateCount), 10, j.PendingUpdateCount < 0)
	buf.WriteByte(',')
	if j.MaxConnections != 0 {
		buf.WriteString(`"max_connections":`)
		fflib.FormatBits2(buf, uint64(j.MaxConnections), 10, j.MaxConnections < 0)
		buf.WriteByte(',')
	}
	if j.LastErrorDate != 0 {
		buf.WriteString(`"last_error_date":`)
		fflib.FormatBits2(buf, uint64(j.LastErrorDate), 10, j.LastErrorDate < 0)
		buf.WriteByte(',')
	}
	if len(j.AllowedUpdates) != 0 {
		buf.WriteString(`"allowed_updates":`)
		if j.AllowedUpdates != nil {
			buf.WriteString(`[`)
			for i, v := range j.AllowedUpdates {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtWebhookInfobase = iota
	ffjtWebhookInfonosuchkey

	ffjtWebhookInfoURL

	ffjtWebhookInfoLastErrorMessage

	ffjtWebhookInfoHasCustomCertificate

	ffjtWebhookInfoPendingUpdateCount

	ffjtWebhookInfoMaxConnections

	ffjtWebhookInfoLastErrorDate

	ffjtWebhookInfoAllowedUpdates
)

var ffjKeyWebhookInfoURL = []byte("url")

var ffjKeyWebhookInfoLastErrorMessage = []byte("last_error_message")

var ffjKeyWebhookInfoHasCustomCertificate = []byte("has_custom_certificate")

var ffjKeyWebhookInfoPendingUpdateCount = []byte("pending_update_count")

var ffjKeyWebhookInfoMaxConnections = []byte("max_connections")

var ffjKeyWebhookInfoLastErrorDate = []byte("last_error_date")

var ffjKeyWebhookInfoAllowedUpdates = []byte("allowed_updates")

// UnmarshalJSON umarshall json - template of ffjson
func (j *WebhookInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *WebhookInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtWebhookInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtWebhookInfonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyWebhookInfoAllowedUpdates, kn) {
						currentKey = ffjtWebhookInfoAllowedUpdates
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyWebhookInfoHasCustomCertificate, kn) {
						currentKey = ffjtWebhookInfoHasCustomCertificate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyWebhookInfoLastErrorMessage, kn) {
						currentKey = ffjtWebhookInfoLastErrorMessage
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyWebhookInfoLastErrorDate, kn) {
						currentKey = ffjtWebhookInfoLastErrorDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyWebhookInfoMaxConnections, kn) {
						currentKey = ffjtWebhookInfoMaxConnections
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyWebhookInfoPendingUpdateCount, kn) {
						currentKey = ffjtWebhookInfoPendingUpdateCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyWebhookInfoURL, kn) {
						currentKey = ffjtWebhookInfoURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyWebhookInfoAllowedUpdates, kn) {
					currentKey = ffjtWebhookInfoAllowedUpdates
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyWebhookInfoLastErrorDate, kn) {
					currentKey = ffjtWebhookInfoLastErrorDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyWebhookInfoMaxConnections, kn) {
					currentKey = ffjtWebhookInfoMaxConnections
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyWebhookInfoPendingUpdateCount, kn) {
					currentKey = ffjtWebhookInfoPendingUpdateCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyWebhookInfoHasCustomCertificate, kn) {
					currentKey = ffjtWebhookInfoHasCustomCertificate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyWebhookInfoLastErrorMessage, kn) {
					currentKey = ffjtWebhookInfoLastErrorMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyWebhookInfoURL, kn) {
					currentKey = ffjtWebhookInfoURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtWebhookInfonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtWebhookInfoURL:
					goto handle_URL

				case ffjtWebhookInfoLastErrorMessage:
					goto handle_LastErrorMessage

				case ffjtWebhookInfoHasCustomCertificate:
					goto handle_HasCustomCertificate

				case ffjtWebhookInfoPendingUpdateCount:
					goto handle_PendingUpdateCount

				case ffjtWebhookInfoMaxConnections:
					goto handle_MaxConnections

				case ffjtWebhookInfoLastErrorDate:
					goto handle_LastErrorDate

				case ffjtWebhookInfoAllowedUpdates:
					goto handle_AllowedUpdates

				case ffjtWebhookInfonosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_URL:

	/* handler: j.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastErrorMessage:

	/* handler: j.LastErrorMessage type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LastErrorMessage = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HasCustomCertificate:

	/* handler: j.HasCustomCertificate type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.HasCustomCertificate = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.HasCustomCertificate = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PendingUpdateCount:

	/* handler: j.PendingUpdateCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PendingUpdateCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaxConnections:

	/* handler: j.MaxConnections type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MaxConnections = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastErrorDate:

	/* handler: j.LastErrorDate type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.LastErrorDate = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AllowedUpdates:

	/* handler: j.AllowedUpdates type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.AllowedUpdates = nil
		} else {

			j.AllowedUpdates = []string{}

			wantVal := true

			for {

				var tmpJAllowedUpdates string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJAllowedUpdates type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJAllowedUpdates = string(string(outBuf))

					}
				}

				j.AllowedUpdates = append(j.AllowedUpdates, tmpJAllowedUpdates)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
