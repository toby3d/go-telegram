// Code generated by ffjson <https://github.com/pquerna/ffjson>. DO NOT EDIT.
// source: send.go

package telegram

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

// MarshalJSON marshal bytes to json - template
func (j *SendAnimationParameters) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *SendAnimationParameters) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "chat_id":`)
	fflib.FormatBits2(buf, uint64(j.ChatID), 10, j.ChatID < 0)
	buf.WriteString(`,"animation":`)
	/* Interface types must use runtime reflection. type=telegram.InputFile kind=interface */
	err = buf.Encode(j.Animation)
	if err != nil {
		return err
	}
	buf.WriteByte(',')
	if j.Duration != 0 {
		buf.WriteString(`"duration":`)
		fflib.FormatBits2(buf, uint64(j.Duration), 10, j.Duration < 0)
		buf.WriteByte(',')
	}
	if j.Width != 0 {
		buf.WriteString(`"width":`)
		fflib.FormatBits2(buf, uint64(j.Width), 10, j.Width < 0)
		buf.WriteByte(',')
	}
	if j.Height != 0 {
		buf.WriteString(`"height":`)
		fflib.FormatBits2(buf, uint64(j.Height), 10, j.Height < 0)
		buf.WriteByte(',')
	}
	if j.Thumb != nil {
		buf.WriteString(`"thumb":`)
		/* Interface types must use runtime reflection. type=telegram.InputFile kind=interface */
		err = buf.Encode(j.Thumb)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if len(j.ParseMode) != 0 {
		buf.WriteString(`"parse_mode":`)
		fflib.WriteJsonString(buf, string(j.ParseMode))
		buf.WriteByte(',')
	}
	if j.DisableNotification != false {
		if j.DisableNotification {
			buf.WriteString(`"disable_notification":true`)
		} else {
			buf.WriteString(`"disable_notification":false`)
		}
		buf.WriteByte(',')
	}
	if j.ReplyToMessageID != 0 {
		buf.WriteString(`"reply_to_message_id":`)
		fflib.FormatBits2(buf, uint64(j.ReplyToMessageID), 10, j.ReplyToMessageID < 0)
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		buf.WriteString(`"reply_markup":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.ReplyMarkup)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtSendAnimationParametersbase = iota
	ffjtSendAnimationParametersnosuchkey

	ffjtSendAnimationParametersChatID

	ffjtSendAnimationParametersAnimation

	ffjtSendAnimationParametersDuration

	ffjtSendAnimationParametersWidth

	ffjtSendAnimationParametersHeight

	ffjtSendAnimationParametersThumb

	ffjtSendAnimationParametersCaption

	ffjtSendAnimationParametersParseMode

	ffjtSendAnimationParametersDisableNotification

	ffjtSendAnimationParametersReplyToMessageID

	ffjtSendAnimationParametersReplyMarkup
)

var ffjKeySendAnimationParametersChatID = []byte("chat_id")

var ffjKeySendAnimationParametersAnimation = []byte("animation")

var ffjKeySendAnimationParametersDuration = []byte("duration")

var ffjKeySendAnimationParametersWidth = []byte("width")

var ffjKeySendAnimationParametersHeight = []byte("height")

var ffjKeySendAnimationParametersThumb = []byte("thumb")

var ffjKeySendAnimationParametersCaption = []byte("caption")

var ffjKeySendAnimationParametersParseMode = []byte("parse_mode")

var ffjKeySendAnimationParametersDisableNotification = []byte("disable_notification")

var ffjKeySendAnimationParametersReplyToMessageID = []byte("reply_to_message_id")

var ffjKeySendAnimationParametersReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *SendAnimationParameters) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *SendAnimationParameters) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtSendAnimationParametersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtSendAnimationParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeySendAnimationParametersAnimation, kn) {
						currentKey = ffjtSendAnimationParametersAnimation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeySendAnimationParametersChatID, kn) {
						currentKey = ffjtSendAnimationParametersChatID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendAnimationParametersCaption, kn) {
						currentKey = ffjtSendAnimationParametersCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeySendAnimationParametersDuration, kn) {
						currentKey = ffjtSendAnimationParametersDuration
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendAnimationParametersDisableNotification, kn) {
						currentKey = ffjtSendAnimationParametersDisableNotification
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeySendAnimationParametersHeight, kn) {
						currentKey = ffjtSendAnimationParametersHeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeySendAnimationParametersParseMode, kn) {
						currentKey = ffjtSendAnimationParametersParseMode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeySendAnimationParametersReplyToMessageID, kn) {
						currentKey = ffjtSendAnimationParametersReplyToMessageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendAnimationParametersReplyMarkup, kn) {
						currentKey = ffjtSendAnimationParametersReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeySendAnimationParametersThumb, kn) {
						currentKey = ffjtSendAnimationParametersThumb
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeySendAnimationParametersWidth, kn) {
						currentKey = ffjtSendAnimationParametersWidth
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeySendAnimationParametersReplyMarkup, kn) {
					currentKey = ffjtSendAnimationParametersReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendAnimationParametersReplyToMessageID, kn) {
					currentKey = ffjtSendAnimationParametersReplyToMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendAnimationParametersDisableNotification, kn) {
					currentKey = ffjtSendAnimationParametersDisableNotification
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendAnimationParametersParseMode, kn) {
					currentKey = ffjtSendAnimationParametersParseMode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySendAnimationParametersCaption, kn) {
					currentKey = ffjtSendAnimationParametersCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySendAnimationParametersThumb, kn) {
					currentKey = ffjtSendAnimationParametersThumb
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySendAnimationParametersHeight, kn) {
					currentKey = ffjtSendAnimationParametersHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySendAnimationParametersWidth, kn) {
					currentKey = ffjtSendAnimationParametersWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySendAnimationParametersDuration, kn) {
					currentKey = ffjtSendAnimationParametersDuration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySendAnimationParametersAnimation, kn) {
					currentKey = ffjtSendAnimationParametersAnimation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySendAnimationParametersChatID, kn) {
					currentKey = ffjtSendAnimationParametersChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtSendAnimationParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtSendAnimationParametersChatID:
					goto handle_ChatID

				case ffjtSendAnimationParametersAnimation:
					goto handle_Animation

				case ffjtSendAnimationParametersDuration:
					goto handle_Duration

				case ffjtSendAnimationParametersWidth:
					goto handle_Width

				case ffjtSendAnimationParametersHeight:
					goto handle_Height

				case ffjtSendAnimationParametersThumb:
					goto handle_Thumb

				case ffjtSendAnimationParametersCaption:
					goto handle_Caption

				case ffjtSendAnimationParametersParseMode:
					goto handle_ParseMode

				case ffjtSendAnimationParametersDisableNotification:
					goto handle_DisableNotification

				case ffjtSendAnimationParametersReplyToMessageID:
					goto handle_ReplyToMessageID

				case ffjtSendAnimationParametersReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtSendAnimationParametersnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ChatID:

	/* handler: j.ChatID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ChatID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Animation:

	/* handler: j.Animation type=telegram.InputFile kind=interface quoted=false*/

	{
		/* Falling back. type=telegram.InputFile kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Animation)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: j.Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Width:

	/* handler: j.Width type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Width = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Height:

	/* handler: j.Height type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Height = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Thumb:

	/* handler: j.Thumb type=telegram.InputFile kind=interface quoted=false*/

	{
		/* Falling back. type=telegram.InputFile kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Thumb)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ParseMode:

	/* handler: j.ParseMode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ParseMode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DisableNotification:

	/* handler: j.DisableNotification type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DisableNotification = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DisableNotification = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyToMessageID:

	/* handler: j.ReplyToMessageID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ReplyToMessageID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ReplyMarkup)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *SendChatActionParameters) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *SendChatActionParameters) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"chat_id":`)
	fflib.FormatBits2(buf, uint64(j.ChatID), 10, j.ChatID < 0)
	buf.WriteString(`,"action":`)
	fflib.WriteJsonString(buf, string(j.Action))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtSendChatActionParametersbase = iota
	ffjtSendChatActionParametersnosuchkey

	ffjtSendChatActionParametersChatID

	ffjtSendChatActionParametersAction
)

var ffjKeySendChatActionParametersChatID = []byte("chat_id")

var ffjKeySendChatActionParametersAction = []byte("action")

// UnmarshalJSON umarshall json - template of ffjson
func (j *SendChatActionParameters) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *SendChatActionParameters) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtSendChatActionParametersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtSendChatActionParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeySendChatActionParametersAction, kn) {
						currentKey = ffjtSendChatActionParametersAction
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeySendChatActionParametersChatID, kn) {
						currentKey = ffjtSendChatActionParametersChatID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeySendChatActionParametersAction, kn) {
					currentKey = ffjtSendChatActionParametersAction
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySendChatActionParametersChatID, kn) {
					currentKey = ffjtSendChatActionParametersChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtSendChatActionParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtSendChatActionParametersChatID:
					goto handle_ChatID

				case ffjtSendChatActionParametersAction:
					goto handle_Action

				case ffjtSendChatActionParametersnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ChatID:

	/* handler: j.ChatID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ChatID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Action:

	/* handler: j.Action type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Action = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *SendContactParameters) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *SendContactParameters) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "chat_id":`)
	fflib.FormatBits2(buf, uint64(j.ChatID), 10, j.ChatID < 0)
	buf.WriteString(`,"phone_number":`)
	fflib.WriteJsonString(buf, string(j.PhoneNumber))
	buf.WriteString(`,"first_name":`)
	fflib.WriteJsonString(buf, string(j.FirstName))
	buf.WriteString(`,"last_name":`)
	fflib.WriteJsonString(buf, string(j.LastName))
	buf.WriteByte(',')
	if len(j.VCard) != 0 {
		buf.WriteString(`"vcard":`)
		fflib.WriteJsonString(buf, string(j.VCard))
		buf.WriteByte(',')
	}
	if j.DisableNotification != false {
		if j.DisableNotification {
			buf.WriteString(`"disable_notification":true`)
		} else {
			buf.WriteString(`"disable_notification":false`)
		}
		buf.WriteByte(',')
	}
	if j.ReplyToMessageID != 0 {
		buf.WriteString(`"reply_to_message_id":`)
		fflib.FormatBits2(buf, uint64(j.ReplyToMessageID), 10, j.ReplyToMessageID < 0)
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			/* Struct fall back. type=telegram.InlineKeyboardMarkup kind=struct */
			buf.WriteString(`"reply_markup":`)
			err = buf.Encode(j.ReplyMarkup)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtSendContactParametersbase = iota
	ffjtSendContactParametersnosuchkey

	ffjtSendContactParametersChatID

	ffjtSendContactParametersPhoneNumber

	ffjtSendContactParametersFirstName

	ffjtSendContactParametersLastName

	ffjtSendContactParametersVCard

	ffjtSendContactParametersDisableNotification

	ffjtSendContactParametersReplyToMessageID

	ffjtSendContactParametersReplyMarkup
)

var ffjKeySendContactParametersChatID = []byte("chat_id")

var ffjKeySendContactParametersPhoneNumber = []byte("phone_number")

var ffjKeySendContactParametersFirstName = []byte("first_name")

var ffjKeySendContactParametersLastName = []byte("last_name")

var ffjKeySendContactParametersVCard = []byte("vcard")

var ffjKeySendContactParametersDisableNotification = []byte("disable_notification")

var ffjKeySendContactParametersReplyToMessageID = []byte("reply_to_message_id")

var ffjKeySendContactParametersReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *SendContactParameters) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *SendContactParameters) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtSendContactParametersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtSendContactParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeySendContactParametersChatID, kn) {
						currentKey = ffjtSendContactParametersChatID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeySendContactParametersDisableNotification, kn) {
						currentKey = ffjtSendContactParametersDisableNotification
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeySendContactParametersFirstName, kn) {
						currentKey = ffjtSendContactParametersFirstName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeySendContactParametersLastName, kn) {
						currentKey = ffjtSendContactParametersLastName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeySendContactParametersPhoneNumber, kn) {
						currentKey = ffjtSendContactParametersPhoneNumber
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeySendContactParametersReplyToMessageID, kn) {
						currentKey = ffjtSendContactParametersReplyToMessageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendContactParametersReplyMarkup, kn) {
						currentKey = ffjtSendContactParametersReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeySendContactParametersVCard, kn) {
						currentKey = ffjtSendContactParametersVCard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeySendContactParametersReplyMarkup, kn) {
					currentKey = ffjtSendContactParametersReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendContactParametersReplyToMessageID, kn) {
					currentKey = ffjtSendContactParametersReplyToMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendContactParametersDisableNotification, kn) {
					currentKey = ffjtSendContactParametersDisableNotification
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySendContactParametersVCard, kn) {
					currentKey = ffjtSendContactParametersVCard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendContactParametersLastName, kn) {
					currentKey = ffjtSendContactParametersLastName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendContactParametersFirstName, kn) {
					currentKey = ffjtSendContactParametersFirstName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySendContactParametersPhoneNumber, kn) {
					currentKey = ffjtSendContactParametersPhoneNumber
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySendContactParametersChatID, kn) {
					currentKey = ffjtSendContactParametersChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtSendContactParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtSendContactParametersChatID:
					goto handle_ChatID

				case ffjtSendContactParametersPhoneNumber:
					goto handle_PhoneNumber

				case ffjtSendContactParametersFirstName:
					goto handle_FirstName

				case ffjtSendContactParametersLastName:
					goto handle_LastName

				case ffjtSendContactParametersVCard:
					goto handle_VCard

				case ffjtSendContactParametersDisableNotification:
					goto handle_DisableNotification

				case ffjtSendContactParametersReplyToMessageID:
					goto handle_ReplyToMessageID

				case ffjtSendContactParametersReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtSendContactParametersnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ChatID:

	/* handler: j.ChatID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ChatID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PhoneNumber:

	/* handler: j.PhoneNumber type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PhoneNumber = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FirstName:

	/* handler: j.FirstName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FirstName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastName:

	/* handler: j.LastName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LastName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VCard:

	/* handler: j.VCard type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.VCard = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DisableNotification:

	/* handler: j.DisableNotification type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DisableNotification = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DisableNotification = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyToMessageID:

	/* handler: j.ReplyToMessageID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ReplyToMessageID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=telegram.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		/* Falling back. type=telegram.InlineKeyboardMarkup kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ReplyMarkup)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *SendDocumentParameters) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *SendDocumentParameters) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "chat_id":`)
	fflib.FormatBits2(buf, uint64(j.ChatID), 10, j.ChatID < 0)
	buf.WriteString(`,"document":`)
	/* Interface types must use runtime reflection. type=telegram.InputFile kind=interface */
	err = buf.Encode(j.Document)
	if err != nil {
		return err
	}
	buf.WriteByte(',')
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if len(j.ParseMode) != 0 {
		buf.WriteString(`"parse_mode":`)
		fflib.WriteJsonString(buf, string(j.ParseMode))
		buf.WriteByte(',')
	}
	if j.DisableNotification != false {
		if j.DisableNotification {
			buf.WriteString(`"disable_notification":true`)
		} else {
			buf.WriteString(`"disable_notification":false`)
		}
		buf.WriteByte(',')
	}
	if j.ReplyToMessageID != 0 {
		buf.WriteString(`"reply_to_message_id":`)
		fflib.FormatBits2(buf, uint64(j.ReplyToMessageID), 10, j.ReplyToMessageID < 0)
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		buf.WriteString(`"reply_markup":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.ReplyMarkup)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtSendDocumentParametersbase = iota
	ffjtSendDocumentParametersnosuchkey

	ffjtSendDocumentParametersChatID

	ffjtSendDocumentParametersDocument

	ffjtSendDocumentParametersCaption

	ffjtSendDocumentParametersParseMode

	ffjtSendDocumentParametersDisableNotification

	ffjtSendDocumentParametersReplyToMessageID

	ffjtSendDocumentParametersReplyMarkup
)

var ffjKeySendDocumentParametersChatID = []byte("chat_id")

var ffjKeySendDocumentParametersDocument = []byte("document")

var ffjKeySendDocumentParametersCaption = []byte("caption")

var ffjKeySendDocumentParametersParseMode = []byte("parse_mode")

var ffjKeySendDocumentParametersDisableNotification = []byte("disable_notification")

var ffjKeySendDocumentParametersReplyToMessageID = []byte("reply_to_message_id")

var ffjKeySendDocumentParametersReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *SendDocumentParameters) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *SendDocumentParameters) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtSendDocumentParametersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtSendDocumentParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeySendDocumentParametersChatID, kn) {
						currentKey = ffjtSendDocumentParametersChatID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendDocumentParametersCaption, kn) {
						currentKey = ffjtSendDocumentParametersCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeySendDocumentParametersDocument, kn) {
						currentKey = ffjtSendDocumentParametersDocument
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendDocumentParametersDisableNotification, kn) {
						currentKey = ffjtSendDocumentParametersDisableNotification
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeySendDocumentParametersParseMode, kn) {
						currentKey = ffjtSendDocumentParametersParseMode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeySendDocumentParametersReplyToMessageID, kn) {
						currentKey = ffjtSendDocumentParametersReplyToMessageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendDocumentParametersReplyMarkup, kn) {
						currentKey = ffjtSendDocumentParametersReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeySendDocumentParametersReplyMarkup, kn) {
					currentKey = ffjtSendDocumentParametersReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendDocumentParametersReplyToMessageID, kn) {
					currentKey = ffjtSendDocumentParametersReplyToMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendDocumentParametersDisableNotification, kn) {
					currentKey = ffjtSendDocumentParametersDisableNotification
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendDocumentParametersParseMode, kn) {
					currentKey = ffjtSendDocumentParametersParseMode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySendDocumentParametersCaption, kn) {
					currentKey = ffjtSendDocumentParametersCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySendDocumentParametersDocument, kn) {
					currentKey = ffjtSendDocumentParametersDocument
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySendDocumentParametersChatID, kn) {
					currentKey = ffjtSendDocumentParametersChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtSendDocumentParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtSendDocumentParametersChatID:
					goto handle_ChatID

				case ffjtSendDocumentParametersDocument:
					goto handle_Document

				case ffjtSendDocumentParametersCaption:
					goto handle_Caption

				case ffjtSendDocumentParametersParseMode:
					goto handle_ParseMode

				case ffjtSendDocumentParametersDisableNotification:
					goto handle_DisableNotification

				case ffjtSendDocumentParametersReplyToMessageID:
					goto handle_ReplyToMessageID

				case ffjtSendDocumentParametersReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtSendDocumentParametersnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ChatID:

	/* handler: j.ChatID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ChatID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Document:

	/* handler: j.Document type=telegram.InputFile kind=interface quoted=false*/

	{
		/* Falling back. type=telegram.InputFile kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Document)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ParseMode:

	/* handler: j.ParseMode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ParseMode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DisableNotification:

	/* handler: j.DisableNotification type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DisableNotification = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DisableNotification = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyToMessageID:

	/* handler: j.ReplyToMessageID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ReplyToMessageID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ReplyMarkup)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *SendGameParameters) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *SendGameParameters) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "chat_id":`)
	fflib.FormatBits2(buf, uint64(j.ChatID), 10, j.ChatID < 0)
	buf.WriteString(`,"game_short_name":`)
	fflib.WriteJsonString(buf, string(j.GameShortName))
	buf.WriteByte(',')
	if j.DisableNotification != false {
		if j.DisableNotification {
			buf.WriteString(`"disable_notification":true`)
		} else {
			buf.WriteString(`"disable_notification":false`)
		}
		buf.WriteByte(',')
	}
	if j.ReplyToMessageID != 0 {
		buf.WriteString(`"reply_to_message_id":`)
		fflib.FormatBits2(buf, uint64(j.ReplyToMessageID), 10, j.ReplyToMessageID < 0)
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			/* Struct fall back. type=telegram.InlineKeyboardMarkup kind=struct */
			buf.WriteString(`"reply_markup":`)
			err = buf.Encode(j.ReplyMarkup)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtSendGameParametersbase = iota
	ffjtSendGameParametersnosuchkey

	ffjtSendGameParametersChatID

	ffjtSendGameParametersGameShortName

	ffjtSendGameParametersDisableNotification

	ffjtSendGameParametersReplyToMessageID

	ffjtSendGameParametersReplyMarkup
)

var ffjKeySendGameParametersChatID = []byte("chat_id")

var ffjKeySendGameParametersGameShortName = []byte("game_short_name")

var ffjKeySendGameParametersDisableNotification = []byte("disable_notification")

var ffjKeySendGameParametersReplyToMessageID = []byte("reply_to_message_id")

var ffjKeySendGameParametersReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *SendGameParameters) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *SendGameParameters) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtSendGameParametersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtSendGameParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeySendGameParametersChatID, kn) {
						currentKey = ffjtSendGameParametersChatID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeySendGameParametersDisableNotification, kn) {
						currentKey = ffjtSendGameParametersDisableNotification
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeySendGameParametersGameShortName, kn) {
						currentKey = ffjtSendGameParametersGameShortName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeySendGameParametersReplyToMessageID, kn) {
						currentKey = ffjtSendGameParametersReplyToMessageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendGameParametersReplyMarkup, kn) {
						currentKey = ffjtSendGameParametersReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeySendGameParametersReplyMarkup, kn) {
					currentKey = ffjtSendGameParametersReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendGameParametersReplyToMessageID, kn) {
					currentKey = ffjtSendGameParametersReplyToMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendGameParametersDisableNotification, kn) {
					currentKey = ffjtSendGameParametersDisableNotification
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendGameParametersGameShortName, kn) {
					currentKey = ffjtSendGameParametersGameShortName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySendGameParametersChatID, kn) {
					currentKey = ffjtSendGameParametersChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtSendGameParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtSendGameParametersChatID:
					goto handle_ChatID

				case ffjtSendGameParametersGameShortName:
					goto handle_GameShortName

				case ffjtSendGameParametersDisableNotification:
					goto handle_DisableNotification

				case ffjtSendGameParametersReplyToMessageID:
					goto handle_ReplyToMessageID

				case ffjtSendGameParametersReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtSendGameParametersnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ChatID:

	/* handler: j.ChatID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ChatID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GameShortName:

	/* handler: j.GameShortName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.GameShortName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DisableNotification:

	/* handler: j.DisableNotification type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DisableNotification = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DisableNotification = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyToMessageID:

	/* handler: j.ReplyToMessageID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ReplyToMessageID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=telegram.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		/* Falling back. type=telegram.InlineKeyboardMarkup kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ReplyMarkup)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *SendInvoiceParameters) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *SendInvoiceParameters) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "chat_id":`)
	fflib.FormatBits2(buf, uint64(j.ChatID), 10, j.ChatID < 0)
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteString(`,"description":`)
	fflib.WriteJsonString(buf, string(j.Description))
	buf.WriteString(`,"payload":`)
	fflib.WriteJsonString(buf, string(j.Payload))
	buf.WriteString(`,"provider_token":`)
	fflib.WriteJsonString(buf, string(j.ProviderToken))
	buf.WriteString(`,"start_parameter":`)
	fflib.WriteJsonString(buf, string(j.StartParameter))
	buf.WriteString(`,"currency":`)
	fflib.WriteJsonString(buf, string(j.Currency))
	buf.WriteByte(',')
	if len(j.ProviderData) != 0 {
		buf.WriteString(`"provider_data":`)
		fflib.WriteJsonString(buf, string(j.ProviderData))
		buf.WriteByte(',')
	}
	if len(j.PhotoURL) != 0 {
		buf.WriteString(`"photo_url":`)
		fflib.WriteJsonString(buf, string(j.PhotoURL))
		buf.WriteByte(',')
	}
	buf.WriteString(`"prices":`)
	if j.Prices != nil {
		buf.WriteString(`[`)
		for i, v := range j.Prices {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Struct fall back. type=telegram.LabeledPrice kind=struct */
			err = buf.Encode(&v)
			if err != nil {
				return err
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if j.PhotoSize != 0 {
		buf.WriteString(`"photo_size":`)
		fflib.FormatBits2(buf, uint64(j.PhotoSize), 10, j.PhotoSize < 0)
		buf.WriteByte(',')
	}
	if j.PhotoWidth != 0 {
		buf.WriteString(`"photo_width":`)
		fflib.FormatBits2(buf, uint64(j.PhotoWidth), 10, j.PhotoWidth < 0)
		buf.WriteByte(',')
	}
	if j.PhotoHeight != 0 {
		buf.WriteString(`"photo_height":`)
		fflib.FormatBits2(buf, uint64(j.PhotoHeight), 10, j.PhotoHeight < 0)
		buf.WriteByte(',')
	}
	if j.ReplyToMessageID != 0 {
		buf.WriteString(`"reply_to_message_id":`)
		fflib.FormatBits2(buf, uint64(j.ReplyToMessageID), 10, j.ReplyToMessageID < 0)
		buf.WriteByte(',')
	}
	if j.NeedName != false {
		if j.NeedName {
			buf.WriteString(`"need_name":true`)
		} else {
			buf.WriteString(`"need_name":false`)
		}
		buf.WriteByte(',')
	}
	if j.NeedPhoneNumber != false {
		if j.NeedPhoneNumber {
			buf.WriteString(`"need_phone_number":true`)
		} else {
			buf.WriteString(`"need_phone_number":false`)
		}
		buf.WriteByte(',')
	}
	if j.NeedEmail != false {
		if j.NeedEmail {
			buf.WriteString(`"need_email":true`)
		} else {
			buf.WriteString(`"need_email":false`)
		}
		buf.WriteByte(',')
	}
	if j.NeedShippingAddress != false {
		if j.NeedShippingAddress {
			buf.WriteString(`"need_shipping_address":true`)
		} else {
			buf.WriteString(`"need_shipping_address":false`)
		}
		buf.WriteByte(',')
	}
	if j.IsFlexible != false {
		if j.IsFlexible {
			buf.WriteString(`"is_flexible":true`)
		} else {
			buf.WriteString(`"is_flexible":false`)
		}
		buf.WriteByte(',')
	}
	if j.DisableNotification != false {
		if j.DisableNotification {
			buf.WriteString(`"disable_notification":true`)
		} else {
			buf.WriteString(`"disable_notification":false`)
		}
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			/* Struct fall back. type=telegram.InlineKeyboardMarkup kind=struct */
			buf.WriteString(`"reply_markup":`)
			err = buf.Encode(j.ReplyMarkup)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtSendInvoiceParametersbase = iota
	ffjtSendInvoiceParametersnosuchkey

	ffjtSendInvoiceParametersChatID

	ffjtSendInvoiceParametersTitle

	ffjtSendInvoiceParametersDescription

	ffjtSendInvoiceParametersPayload

	ffjtSendInvoiceParametersProviderToken

	ffjtSendInvoiceParametersStartParameter

	ffjtSendInvoiceParametersCurrency

	ffjtSendInvoiceParametersProviderData

	ffjtSendInvoiceParametersPhotoURL

	ffjtSendInvoiceParametersPrices

	ffjtSendInvoiceParametersPhotoSize

	ffjtSendInvoiceParametersPhotoWidth

	ffjtSendInvoiceParametersPhotoHeight

	ffjtSendInvoiceParametersReplyToMessageID

	ffjtSendInvoiceParametersNeedName

	ffjtSendInvoiceParametersNeedPhoneNumber

	ffjtSendInvoiceParametersNeedEmail

	ffjtSendInvoiceParametersNeedShippingAddress

	ffjtSendInvoiceParametersIsFlexible

	ffjtSendInvoiceParametersDisableNotification

	ffjtSendInvoiceParametersReplyMarkup
)

var ffjKeySendInvoiceParametersChatID = []byte("chat_id")

var ffjKeySendInvoiceParametersTitle = []byte("title")

var ffjKeySendInvoiceParametersDescription = []byte("description")

var ffjKeySendInvoiceParametersPayload = []byte("payload")

var ffjKeySendInvoiceParametersProviderToken = []byte("provider_token")

var ffjKeySendInvoiceParametersStartParameter = []byte("start_parameter")

var ffjKeySendInvoiceParametersCurrency = []byte("currency")

var ffjKeySendInvoiceParametersProviderData = []byte("provider_data")

var ffjKeySendInvoiceParametersPhotoURL = []byte("photo_url")

var ffjKeySendInvoiceParametersPrices = []byte("prices")

var ffjKeySendInvoiceParametersPhotoSize = []byte("photo_size")

var ffjKeySendInvoiceParametersPhotoWidth = []byte("photo_width")

var ffjKeySendInvoiceParametersPhotoHeight = []byte("photo_height")

var ffjKeySendInvoiceParametersReplyToMessageID = []byte("reply_to_message_id")

var ffjKeySendInvoiceParametersNeedName = []byte("need_name")

var ffjKeySendInvoiceParametersNeedPhoneNumber = []byte("need_phone_number")

var ffjKeySendInvoiceParametersNeedEmail = []byte("need_email")

var ffjKeySendInvoiceParametersNeedShippingAddress = []byte("need_shipping_address")

var ffjKeySendInvoiceParametersIsFlexible = []byte("is_flexible")

var ffjKeySendInvoiceParametersDisableNotification = []byte("disable_notification")

var ffjKeySendInvoiceParametersReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *SendInvoiceParameters) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *SendInvoiceParameters) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtSendInvoiceParametersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtSendInvoiceParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeySendInvoiceParametersChatID, kn) {
						currentKey = ffjtSendInvoiceParametersChatID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendInvoiceParametersCurrency, kn) {
						currentKey = ffjtSendInvoiceParametersCurrency
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeySendInvoiceParametersDescription, kn) {
						currentKey = ffjtSendInvoiceParametersDescription
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendInvoiceParametersDisableNotification, kn) {
						currentKey = ffjtSendInvoiceParametersDisableNotification
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeySendInvoiceParametersIsFlexible, kn) {
						currentKey = ffjtSendInvoiceParametersIsFlexible
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeySendInvoiceParametersNeedName, kn) {
						currentKey = ffjtSendInvoiceParametersNeedName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendInvoiceParametersNeedPhoneNumber, kn) {
						currentKey = ffjtSendInvoiceParametersNeedPhoneNumber
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendInvoiceParametersNeedEmail, kn) {
						currentKey = ffjtSendInvoiceParametersNeedEmail
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendInvoiceParametersNeedShippingAddress, kn) {
						currentKey = ffjtSendInvoiceParametersNeedShippingAddress
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeySendInvoiceParametersPayload, kn) {
						currentKey = ffjtSendInvoiceParametersPayload
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendInvoiceParametersProviderToken, kn) {
						currentKey = ffjtSendInvoiceParametersProviderToken
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendInvoiceParametersProviderData, kn) {
						currentKey = ffjtSendInvoiceParametersProviderData
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendInvoiceParametersPhotoURL, kn) {
						currentKey = ffjtSendInvoiceParametersPhotoURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendInvoiceParametersPrices, kn) {
						currentKey = ffjtSendInvoiceParametersPrices
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendInvoiceParametersPhotoSize, kn) {
						currentKey = ffjtSendInvoiceParametersPhotoSize
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendInvoiceParametersPhotoWidth, kn) {
						currentKey = ffjtSendInvoiceParametersPhotoWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendInvoiceParametersPhotoHeight, kn) {
						currentKey = ffjtSendInvoiceParametersPhotoHeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeySendInvoiceParametersReplyToMessageID, kn) {
						currentKey = ffjtSendInvoiceParametersReplyToMessageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendInvoiceParametersReplyMarkup, kn) {
						currentKey = ffjtSendInvoiceParametersReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeySendInvoiceParametersStartParameter, kn) {
						currentKey = ffjtSendInvoiceParametersStartParameter
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeySendInvoiceParametersTitle, kn) {
						currentKey = ffjtSendInvoiceParametersTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeySendInvoiceParametersReplyMarkup, kn) {
					currentKey = ffjtSendInvoiceParametersReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendInvoiceParametersDisableNotification, kn) {
					currentKey = ffjtSendInvoiceParametersDisableNotification
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendInvoiceParametersIsFlexible, kn) {
					currentKey = ffjtSendInvoiceParametersIsFlexible
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendInvoiceParametersNeedShippingAddress, kn) {
					currentKey = ffjtSendInvoiceParametersNeedShippingAddress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySendInvoiceParametersNeedEmail, kn) {
					currentKey = ffjtSendInvoiceParametersNeedEmail
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySendInvoiceParametersNeedPhoneNumber, kn) {
					currentKey = ffjtSendInvoiceParametersNeedPhoneNumber
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySendInvoiceParametersNeedName, kn) {
					currentKey = ffjtSendInvoiceParametersNeedName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendInvoiceParametersReplyToMessageID, kn) {
					currentKey = ffjtSendInvoiceParametersReplyToMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySendInvoiceParametersPhotoHeight, kn) {
					currentKey = ffjtSendInvoiceParametersPhotoHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySendInvoiceParametersPhotoWidth, kn) {
					currentKey = ffjtSendInvoiceParametersPhotoWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendInvoiceParametersPhotoSize, kn) {
					currentKey = ffjtSendInvoiceParametersPhotoSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendInvoiceParametersPrices, kn) {
					currentKey = ffjtSendInvoiceParametersPrices
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySendInvoiceParametersPhotoURL, kn) {
					currentKey = ffjtSendInvoiceParametersPhotoURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySendInvoiceParametersProviderData, kn) {
					currentKey = ffjtSendInvoiceParametersProviderData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySendInvoiceParametersCurrency, kn) {
					currentKey = ffjtSendInvoiceParametersCurrency
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendInvoiceParametersStartParameter, kn) {
					currentKey = ffjtSendInvoiceParametersStartParameter
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendInvoiceParametersProviderToken, kn) {
					currentKey = ffjtSendInvoiceParametersProviderToken
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySendInvoiceParametersPayload, kn) {
					currentKey = ffjtSendInvoiceParametersPayload
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendInvoiceParametersDescription, kn) {
					currentKey = ffjtSendInvoiceParametersDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySendInvoiceParametersTitle, kn) {
					currentKey = ffjtSendInvoiceParametersTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySendInvoiceParametersChatID, kn) {
					currentKey = ffjtSendInvoiceParametersChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtSendInvoiceParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtSendInvoiceParametersChatID:
					goto handle_ChatID

				case ffjtSendInvoiceParametersTitle:
					goto handle_Title

				case ffjtSendInvoiceParametersDescription:
					goto handle_Description

				case ffjtSendInvoiceParametersPayload:
					goto handle_Payload

				case ffjtSendInvoiceParametersProviderToken:
					goto handle_ProviderToken

				case ffjtSendInvoiceParametersStartParameter:
					goto handle_StartParameter

				case ffjtSendInvoiceParametersCurrency:
					goto handle_Currency

				case ffjtSendInvoiceParametersProviderData:
					goto handle_ProviderData

				case ffjtSendInvoiceParametersPhotoURL:
					goto handle_PhotoURL

				case ffjtSendInvoiceParametersPrices:
					goto handle_Prices

				case ffjtSendInvoiceParametersPhotoSize:
					goto handle_PhotoSize

				case ffjtSendInvoiceParametersPhotoWidth:
					goto handle_PhotoWidth

				case ffjtSendInvoiceParametersPhotoHeight:
					goto handle_PhotoHeight

				case ffjtSendInvoiceParametersReplyToMessageID:
					goto handle_ReplyToMessageID

				case ffjtSendInvoiceParametersNeedName:
					goto handle_NeedName

				case ffjtSendInvoiceParametersNeedPhoneNumber:
					goto handle_NeedPhoneNumber

				case ffjtSendInvoiceParametersNeedEmail:
					goto handle_NeedEmail

				case ffjtSendInvoiceParametersNeedShippingAddress:
					goto handle_NeedShippingAddress

				case ffjtSendInvoiceParametersIsFlexible:
					goto handle_IsFlexible

				case ffjtSendInvoiceParametersDisableNotification:
					goto handle_DisableNotification

				case ffjtSendInvoiceParametersReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtSendInvoiceParametersnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ChatID:

	/* handler: j.ChatID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ChatID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Payload:

	/* handler: j.Payload type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Payload = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProviderToken:

	/* handler: j.ProviderToken type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ProviderToken = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StartParameter:

	/* handler: j.StartParameter type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.StartParameter = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Currency:

	/* handler: j.Currency type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Currency = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProviderData:

	/* handler: j.ProviderData type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ProviderData = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PhotoURL:

	/* handler: j.PhotoURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PhotoURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Prices:

	/* handler: j.Prices type=[]telegram.LabeledPrice kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Prices = nil
		} else {

			j.Prices = []LabeledPrice{}

			wantVal := true

			for {

				var tmpJPrices LabeledPrice

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJPrices type=telegram.LabeledPrice kind=struct quoted=false*/

				{
					/* Falling back. type=telegram.LabeledPrice kind=struct */
					tbuf, err := fs.CaptureField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}

					err = json.Unmarshal(tbuf, &tmpJPrices)
					if err != nil {
						return fs.WrapErr(err)
					}
				}

				j.Prices = append(j.Prices, tmpJPrices)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PhotoSize:

	/* handler: j.PhotoSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PhotoSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PhotoWidth:

	/* handler: j.PhotoWidth type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PhotoWidth = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PhotoHeight:

	/* handler: j.PhotoHeight type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PhotoHeight = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyToMessageID:

	/* handler: j.ReplyToMessageID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ReplyToMessageID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NeedName:

	/* handler: j.NeedName type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.NeedName = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.NeedName = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NeedPhoneNumber:

	/* handler: j.NeedPhoneNumber type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.NeedPhoneNumber = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.NeedPhoneNumber = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NeedEmail:

	/* handler: j.NeedEmail type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.NeedEmail = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.NeedEmail = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NeedShippingAddress:

	/* handler: j.NeedShippingAddress type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.NeedShippingAddress = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.NeedShippingAddress = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsFlexible:

	/* handler: j.IsFlexible type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.IsFlexible = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.IsFlexible = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DisableNotification:

	/* handler: j.DisableNotification type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DisableNotification = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DisableNotification = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=telegram.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		/* Falling back. type=telegram.InlineKeyboardMarkup kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ReplyMarkup)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *SendLocationParameters) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *SendLocationParameters) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "chat_id":`)
	fflib.FormatBits2(buf, uint64(j.ChatID), 10, j.ChatID < 0)
	buf.WriteString(`,"latitude":`)
	fflib.AppendFloat(buf, float64(j.Latitude), 'g', -1, 32)
	buf.WriteString(`,"longitude":`)
	fflib.AppendFloat(buf, float64(j.Longitude), 'g', -1, 32)
	buf.WriteByte(',')
	if j.LivePeriod != 0 {
		buf.WriteString(`"live_period":`)
		fflib.FormatBits2(buf, uint64(j.LivePeriod), 10, j.LivePeriod < 0)
		buf.WriteByte(',')
	}
	if j.ReplyToMessageID != 0 {
		buf.WriteString(`"reply_to_message_id":`)
		fflib.FormatBits2(buf, uint64(j.ReplyToMessageID), 10, j.ReplyToMessageID < 0)
		buf.WriteByte(',')
	}
	if j.DisableNotification != false {
		if j.DisableNotification {
			buf.WriteString(`"disable_notification":true`)
		} else {
			buf.WriteString(`"disable_notification":false`)
		}
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			/* Struct fall back. type=telegram.InlineKeyboardMarkup kind=struct */
			buf.WriteString(`"reply_markup":`)
			err = buf.Encode(j.ReplyMarkup)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtSendLocationParametersbase = iota
	ffjtSendLocationParametersnosuchkey

	ffjtSendLocationParametersChatID

	ffjtSendLocationParametersLatitude

	ffjtSendLocationParametersLongitude

	ffjtSendLocationParametersLivePeriod

	ffjtSendLocationParametersReplyToMessageID

	ffjtSendLocationParametersDisableNotification

	ffjtSendLocationParametersReplyMarkup
)

var ffjKeySendLocationParametersChatID = []byte("chat_id")

var ffjKeySendLocationParametersLatitude = []byte("latitude")

var ffjKeySendLocationParametersLongitude = []byte("longitude")

var ffjKeySendLocationParametersLivePeriod = []byte("live_period")

var ffjKeySendLocationParametersReplyToMessageID = []byte("reply_to_message_id")

var ffjKeySendLocationParametersDisableNotification = []byte("disable_notification")

var ffjKeySendLocationParametersReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *SendLocationParameters) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *SendLocationParameters) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtSendLocationParametersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtSendLocationParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeySendLocationParametersChatID, kn) {
						currentKey = ffjtSendLocationParametersChatID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeySendLocationParametersDisableNotification, kn) {
						currentKey = ffjtSendLocationParametersDisableNotification
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeySendLocationParametersLatitude, kn) {
						currentKey = ffjtSendLocationParametersLatitude
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendLocationParametersLongitude, kn) {
						currentKey = ffjtSendLocationParametersLongitude
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendLocationParametersLivePeriod, kn) {
						currentKey = ffjtSendLocationParametersLivePeriod
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeySendLocationParametersReplyToMessageID, kn) {
						currentKey = ffjtSendLocationParametersReplyToMessageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendLocationParametersReplyMarkup, kn) {
						currentKey = ffjtSendLocationParametersReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeySendLocationParametersReplyMarkup, kn) {
					currentKey = ffjtSendLocationParametersReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendLocationParametersDisableNotification, kn) {
					currentKey = ffjtSendLocationParametersDisableNotification
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendLocationParametersReplyToMessageID, kn) {
					currentKey = ffjtSendLocationParametersReplyToMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySendLocationParametersLivePeriod, kn) {
					currentKey = ffjtSendLocationParametersLivePeriod
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySendLocationParametersLongitude, kn) {
					currentKey = ffjtSendLocationParametersLongitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySendLocationParametersLatitude, kn) {
					currentKey = ffjtSendLocationParametersLatitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySendLocationParametersChatID, kn) {
					currentKey = ffjtSendLocationParametersChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtSendLocationParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtSendLocationParametersChatID:
					goto handle_ChatID

				case ffjtSendLocationParametersLatitude:
					goto handle_Latitude

				case ffjtSendLocationParametersLongitude:
					goto handle_Longitude

				case ffjtSendLocationParametersLivePeriod:
					goto handle_LivePeriod

				case ffjtSendLocationParametersReplyToMessageID:
					goto handle_ReplyToMessageID

				case ffjtSendLocationParametersDisableNotification:
					goto handle_DisableNotification

				case ffjtSendLocationParametersReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtSendLocationParametersnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ChatID:

	/* handler: j.ChatID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ChatID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Latitude:

	/* handler: j.Latitude type=float32 kind=float32 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Latitude = float32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Longitude:

	/* handler: j.Longitude type=float32 kind=float32 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Longitude = float32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LivePeriod:

	/* handler: j.LivePeriod type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.LivePeriod = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyToMessageID:

	/* handler: j.ReplyToMessageID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ReplyToMessageID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DisableNotification:

	/* handler: j.DisableNotification type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DisableNotification = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DisableNotification = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=telegram.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		/* Falling back. type=telegram.InlineKeyboardMarkup kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ReplyMarkup)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *SendMediaGroupParameters) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *SendMediaGroupParameters) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "chat_id":`)
	fflib.FormatBits2(buf, uint64(j.ChatID), 10, j.ChatID < 0)
	buf.WriteString(`,"media":`)
	if j.Media != nil {
		buf.WriteString(`[`)
		for i, v := range j.Media {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Interface types must use runtime reflection. type=interface {} kind=interface */
			err = buf.Encode(v)
			if err != nil {
				return err
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if j.DisableNotification != false {
		if j.DisableNotification {
			buf.WriteString(`"disable_notification":true`)
		} else {
			buf.WriteString(`"disable_notification":false`)
		}
		buf.WriteByte(',')
	}
	if j.ReplyToMessageID != 0 {
		buf.WriteString(`"reply_to_message_id":`)
		fflib.FormatBits2(buf, uint64(j.ReplyToMessageID), 10, j.ReplyToMessageID < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtSendMediaGroupParametersbase = iota
	ffjtSendMediaGroupParametersnosuchkey

	ffjtSendMediaGroupParametersChatID

	ffjtSendMediaGroupParametersMedia

	ffjtSendMediaGroupParametersDisableNotification

	ffjtSendMediaGroupParametersReplyToMessageID
)

var ffjKeySendMediaGroupParametersChatID = []byte("chat_id")

var ffjKeySendMediaGroupParametersMedia = []byte("media")

var ffjKeySendMediaGroupParametersDisableNotification = []byte("disable_notification")

var ffjKeySendMediaGroupParametersReplyToMessageID = []byte("reply_to_message_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *SendMediaGroupParameters) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *SendMediaGroupParameters) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtSendMediaGroupParametersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtSendMediaGroupParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeySendMediaGroupParametersChatID, kn) {
						currentKey = ffjtSendMediaGroupParametersChatID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeySendMediaGroupParametersDisableNotification, kn) {
						currentKey = ffjtSendMediaGroupParametersDisableNotification
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeySendMediaGroupParametersMedia, kn) {
						currentKey = ffjtSendMediaGroupParametersMedia
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeySendMediaGroupParametersReplyToMessageID, kn) {
						currentKey = ffjtSendMediaGroupParametersReplyToMessageID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeySendMediaGroupParametersReplyToMessageID, kn) {
					currentKey = ffjtSendMediaGroupParametersReplyToMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendMediaGroupParametersDisableNotification, kn) {
					currentKey = ffjtSendMediaGroupParametersDisableNotification
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySendMediaGroupParametersMedia, kn) {
					currentKey = ffjtSendMediaGroupParametersMedia
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySendMediaGroupParametersChatID, kn) {
					currentKey = ffjtSendMediaGroupParametersChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtSendMediaGroupParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtSendMediaGroupParametersChatID:
					goto handle_ChatID

				case ffjtSendMediaGroupParametersMedia:
					goto handle_Media

				case ffjtSendMediaGroupParametersDisableNotification:
					goto handle_DisableNotification

				case ffjtSendMediaGroupParametersReplyToMessageID:
					goto handle_ReplyToMessageID

				case ffjtSendMediaGroupParametersnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ChatID:

	/* handler: j.ChatID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ChatID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Media:

	/* handler: j.Media type=[]interface {} kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Media = nil
		} else {

			j.Media = []interface{}{}

			wantVal := true

			for {

				var tmpJMedia interface{}

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJMedia type=interface {} kind=interface quoted=false*/

				{
					/* Falling back. type=interface {} kind=interface */
					tbuf, err := fs.CaptureField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}

					err = json.Unmarshal(tbuf, &tmpJMedia)
					if err != nil {
						return fs.WrapErr(err)
					}
				}

				j.Media = append(j.Media, tmpJMedia)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DisableNotification:

	/* handler: j.DisableNotification type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DisableNotification = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DisableNotification = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyToMessageID:

	/* handler: j.ReplyToMessageID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ReplyToMessageID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *SendMessageParameters) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *SendMessageParameters) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "chat_id":`)
	fflib.FormatBits2(buf, uint64(j.ChatID), 10, j.ChatID < 0)
	buf.WriteString(`,"text":`)
	fflib.WriteJsonString(buf, string(j.Text))
	buf.WriteByte(',')
	if len(j.ParseMode) != 0 {
		buf.WriteString(`"parse_mode":`)
		fflib.WriteJsonString(buf, string(j.ParseMode))
		buf.WriteByte(',')
	}
	if j.DisableWebPagePreview != false {
		if j.DisableWebPagePreview {
			buf.WriteString(`"disable_web_page_preview":true`)
		} else {
			buf.WriteString(`"disable_web_page_preview":false`)
		}
		buf.WriteByte(',')
	}
	if j.DisableNotification != false {
		if j.DisableNotification {
			buf.WriteString(`"disable_notification":true`)
		} else {
			buf.WriteString(`"disable_notification":false`)
		}
		buf.WriteByte(',')
	}
	if j.ReplyToMessageID != 0 {
		buf.WriteString(`"reply_to_message_id":`)
		fflib.FormatBits2(buf, uint64(j.ReplyToMessageID), 10, j.ReplyToMessageID < 0)
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		buf.WriteString(`"reply_markup":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.ReplyMarkup)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtSendMessageParametersbase = iota
	ffjtSendMessageParametersnosuchkey

	ffjtSendMessageParametersChatID

	ffjtSendMessageParametersText

	ffjtSendMessageParametersParseMode

	ffjtSendMessageParametersDisableWebPagePreview

	ffjtSendMessageParametersDisableNotification

	ffjtSendMessageParametersReplyToMessageID

	ffjtSendMessageParametersReplyMarkup
)

var ffjKeySendMessageParametersChatID = []byte("chat_id")

var ffjKeySendMessageParametersText = []byte("text")

var ffjKeySendMessageParametersParseMode = []byte("parse_mode")

var ffjKeySendMessageParametersDisableWebPagePreview = []byte("disable_web_page_preview")

var ffjKeySendMessageParametersDisableNotification = []byte("disable_notification")

var ffjKeySendMessageParametersReplyToMessageID = []byte("reply_to_message_id")

var ffjKeySendMessageParametersReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *SendMessageParameters) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *SendMessageParameters) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtSendMessageParametersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtSendMessageParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeySendMessageParametersChatID, kn) {
						currentKey = ffjtSendMessageParametersChatID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeySendMessageParametersDisableWebPagePreview, kn) {
						currentKey = ffjtSendMessageParametersDisableWebPagePreview
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendMessageParametersDisableNotification, kn) {
						currentKey = ffjtSendMessageParametersDisableNotification
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeySendMessageParametersParseMode, kn) {
						currentKey = ffjtSendMessageParametersParseMode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeySendMessageParametersReplyToMessageID, kn) {
						currentKey = ffjtSendMessageParametersReplyToMessageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendMessageParametersReplyMarkup, kn) {
						currentKey = ffjtSendMessageParametersReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeySendMessageParametersText, kn) {
						currentKey = ffjtSendMessageParametersText
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeySendMessageParametersReplyMarkup, kn) {
					currentKey = ffjtSendMessageParametersReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendMessageParametersReplyToMessageID, kn) {
					currentKey = ffjtSendMessageParametersReplyToMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendMessageParametersDisableNotification, kn) {
					currentKey = ffjtSendMessageParametersDisableNotification
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendMessageParametersDisableWebPagePreview, kn) {
					currentKey = ffjtSendMessageParametersDisableWebPagePreview
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendMessageParametersParseMode, kn) {
					currentKey = ffjtSendMessageParametersParseMode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySendMessageParametersText, kn) {
					currentKey = ffjtSendMessageParametersText
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySendMessageParametersChatID, kn) {
					currentKey = ffjtSendMessageParametersChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtSendMessageParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtSendMessageParametersChatID:
					goto handle_ChatID

				case ffjtSendMessageParametersText:
					goto handle_Text

				case ffjtSendMessageParametersParseMode:
					goto handle_ParseMode

				case ffjtSendMessageParametersDisableWebPagePreview:
					goto handle_DisableWebPagePreview

				case ffjtSendMessageParametersDisableNotification:
					goto handle_DisableNotification

				case ffjtSendMessageParametersReplyToMessageID:
					goto handle_ReplyToMessageID

				case ffjtSendMessageParametersReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtSendMessageParametersnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ChatID:

	/* handler: j.ChatID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ChatID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Text:

	/* handler: j.Text type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Text = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ParseMode:

	/* handler: j.ParseMode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ParseMode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DisableWebPagePreview:

	/* handler: j.DisableWebPagePreview type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DisableWebPagePreview = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DisableWebPagePreview = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DisableNotification:

	/* handler: j.DisableNotification type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DisableNotification = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DisableNotification = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyToMessageID:

	/* handler: j.ReplyToMessageID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ReplyToMessageID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ReplyMarkup)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *SendPhotoParameters) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *SendPhotoParameters) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "chat_id":`)
	fflib.FormatBits2(buf, uint64(j.ChatID), 10, j.ChatID < 0)
	buf.WriteString(`,"photo":`)
	/* Interface types must use runtime reflection. type=telegram.InputFile kind=interface */
	err = buf.Encode(j.Photo)
	if err != nil {
		return err
	}
	buf.WriteByte(',')
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if len(j.ParseMode) != 0 {
		buf.WriteString(`"parse_mode":`)
		fflib.WriteJsonString(buf, string(j.ParseMode))
		buf.WriteByte(',')
	}
	if j.DisableWebPagePreview != false {
		if j.DisableWebPagePreview {
			buf.WriteString(`"disable_web_page_preview":true`)
		} else {
			buf.WriteString(`"disable_web_page_preview":false`)
		}
		buf.WriteByte(',')
	}
	if j.DisableNotification != false {
		if j.DisableNotification {
			buf.WriteString(`"disable_notification":true`)
		} else {
			buf.WriteString(`"disable_notification":false`)
		}
		buf.WriteByte(',')
	}
	if j.ReplyToMessageID != 0 {
		buf.WriteString(`"reply_to_message_id":`)
		fflib.FormatBits2(buf, uint64(j.ReplyToMessageID), 10, j.ReplyToMessageID < 0)
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		buf.WriteString(`"reply_markup":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.ReplyMarkup)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtSendPhotoParametersbase = iota
	ffjtSendPhotoParametersnosuchkey

	ffjtSendPhotoParametersChatID

	ffjtSendPhotoParametersPhoto

	ffjtSendPhotoParametersCaption

	ffjtSendPhotoParametersParseMode

	ffjtSendPhotoParametersDisableWebPagePreview

	ffjtSendPhotoParametersDisableNotification

	ffjtSendPhotoParametersReplyToMessageID

	ffjtSendPhotoParametersReplyMarkup
)

var ffjKeySendPhotoParametersChatID = []byte("chat_id")

var ffjKeySendPhotoParametersPhoto = []byte("photo")

var ffjKeySendPhotoParametersCaption = []byte("caption")

var ffjKeySendPhotoParametersParseMode = []byte("parse_mode")

var ffjKeySendPhotoParametersDisableWebPagePreview = []byte("disable_web_page_preview")

var ffjKeySendPhotoParametersDisableNotification = []byte("disable_notification")

var ffjKeySendPhotoParametersReplyToMessageID = []byte("reply_to_message_id")

var ffjKeySendPhotoParametersReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *SendPhotoParameters) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *SendPhotoParameters) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtSendPhotoParametersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtSendPhotoParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeySendPhotoParametersChatID, kn) {
						currentKey = ffjtSendPhotoParametersChatID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendPhotoParametersCaption, kn) {
						currentKey = ffjtSendPhotoParametersCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeySendPhotoParametersDisableWebPagePreview, kn) {
						currentKey = ffjtSendPhotoParametersDisableWebPagePreview
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendPhotoParametersDisableNotification, kn) {
						currentKey = ffjtSendPhotoParametersDisableNotification
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeySendPhotoParametersPhoto, kn) {
						currentKey = ffjtSendPhotoParametersPhoto
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendPhotoParametersParseMode, kn) {
						currentKey = ffjtSendPhotoParametersParseMode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeySendPhotoParametersReplyToMessageID, kn) {
						currentKey = ffjtSendPhotoParametersReplyToMessageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendPhotoParametersReplyMarkup, kn) {
						currentKey = ffjtSendPhotoParametersReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeySendPhotoParametersReplyMarkup, kn) {
					currentKey = ffjtSendPhotoParametersReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendPhotoParametersReplyToMessageID, kn) {
					currentKey = ffjtSendPhotoParametersReplyToMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendPhotoParametersDisableNotification, kn) {
					currentKey = ffjtSendPhotoParametersDisableNotification
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendPhotoParametersDisableWebPagePreview, kn) {
					currentKey = ffjtSendPhotoParametersDisableWebPagePreview
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendPhotoParametersParseMode, kn) {
					currentKey = ffjtSendPhotoParametersParseMode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySendPhotoParametersCaption, kn) {
					currentKey = ffjtSendPhotoParametersCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySendPhotoParametersPhoto, kn) {
					currentKey = ffjtSendPhotoParametersPhoto
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySendPhotoParametersChatID, kn) {
					currentKey = ffjtSendPhotoParametersChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtSendPhotoParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtSendPhotoParametersChatID:
					goto handle_ChatID

				case ffjtSendPhotoParametersPhoto:
					goto handle_Photo

				case ffjtSendPhotoParametersCaption:
					goto handle_Caption

				case ffjtSendPhotoParametersParseMode:
					goto handle_ParseMode

				case ffjtSendPhotoParametersDisableWebPagePreview:
					goto handle_DisableWebPagePreview

				case ffjtSendPhotoParametersDisableNotification:
					goto handle_DisableNotification

				case ffjtSendPhotoParametersReplyToMessageID:
					goto handle_ReplyToMessageID

				case ffjtSendPhotoParametersReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtSendPhotoParametersnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ChatID:

	/* handler: j.ChatID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ChatID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Photo:

	/* handler: j.Photo type=telegram.InputFile kind=interface quoted=false*/

	{
		/* Falling back. type=telegram.InputFile kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Photo)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ParseMode:

	/* handler: j.ParseMode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ParseMode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DisableWebPagePreview:

	/* handler: j.DisableWebPagePreview type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DisableWebPagePreview = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DisableWebPagePreview = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DisableNotification:

	/* handler: j.DisableNotification type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DisableNotification = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DisableNotification = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyToMessageID:

	/* handler: j.ReplyToMessageID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ReplyToMessageID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ReplyMarkup)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *SendPollConfig) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *SendPollConfig) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "chat_id":`)
	fflib.FormatBits2(buf, uint64(j.ChatID), 10, j.ChatID < 0)
	buf.WriteString(`,"question":`)
	fflib.WriteJsonString(buf, string(j.Question))
	buf.WriteString(`,"options":`)
	if j.Options != nil {
		buf.WriteString(`[`)
		for i, v := range j.Options {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if j.DisableNotification != false {
		if j.DisableNotification {
			buf.WriteString(`"disable_notification":true`)
		} else {
			buf.WriteString(`"disable_notification":false`)
		}
		buf.WriteByte(',')
	}
	if j.ReplyToMessageID != 0 {
		buf.WriteString(`"reply_to_message_id":`)
		fflib.FormatBits2(buf, uint64(j.ReplyToMessageID), 10, j.ReplyToMessageID < 0)
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		buf.WriteString(`"reply_markup":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.ReplyMarkup)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtSendPollConfigbase = iota
	ffjtSendPollConfignosuchkey

	ffjtSendPollConfigChatID

	ffjtSendPollConfigQuestion

	ffjtSendPollConfigOptions

	ffjtSendPollConfigDisableNotification

	ffjtSendPollConfigReplyToMessageID

	ffjtSendPollConfigReplyMarkup
)

var ffjKeySendPollConfigChatID = []byte("chat_id")

var ffjKeySendPollConfigQuestion = []byte("question")

var ffjKeySendPollConfigOptions = []byte("options")

var ffjKeySendPollConfigDisableNotification = []byte("disable_notification")

var ffjKeySendPollConfigReplyToMessageID = []byte("reply_to_message_id")

var ffjKeySendPollConfigReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *SendPollConfig) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *SendPollConfig) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtSendPollConfigbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtSendPollConfignosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeySendPollConfigChatID, kn) {
						currentKey = ffjtSendPollConfigChatID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeySendPollConfigDisableNotification, kn) {
						currentKey = ffjtSendPollConfigDisableNotification
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeySendPollConfigOptions, kn) {
						currentKey = ffjtSendPollConfigOptions
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'q':

					if bytes.Equal(ffjKeySendPollConfigQuestion, kn) {
						currentKey = ffjtSendPollConfigQuestion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeySendPollConfigReplyToMessageID, kn) {
						currentKey = ffjtSendPollConfigReplyToMessageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendPollConfigReplyMarkup, kn) {
						currentKey = ffjtSendPollConfigReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeySendPollConfigReplyMarkup, kn) {
					currentKey = ffjtSendPollConfigReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendPollConfigReplyToMessageID, kn) {
					currentKey = ffjtSendPollConfigReplyToMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendPollConfigDisableNotification, kn) {
					currentKey = ffjtSendPollConfigDisableNotification
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendPollConfigOptions, kn) {
					currentKey = ffjtSendPollConfigOptions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendPollConfigQuestion, kn) {
					currentKey = ffjtSendPollConfigQuestion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySendPollConfigChatID, kn) {
					currentKey = ffjtSendPollConfigChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtSendPollConfignosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtSendPollConfigChatID:
					goto handle_ChatID

				case ffjtSendPollConfigQuestion:
					goto handle_Question

				case ffjtSendPollConfigOptions:
					goto handle_Options

				case ffjtSendPollConfigDisableNotification:
					goto handle_DisableNotification

				case ffjtSendPollConfigReplyToMessageID:
					goto handle_ReplyToMessageID

				case ffjtSendPollConfigReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtSendPollConfignosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ChatID:

	/* handler: j.ChatID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ChatID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Question:

	/* handler: j.Question type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Question = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Options:

	/* handler: j.Options type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Options = nil
		} else {

			j.Options = []string{}

			wantVal := true

			for {

				var tmpJOptions string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJOptions type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJOptions = string(string(outBuf))

					}
				}

				j.Options = append(j.Options, tmpJOptions)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DisableNotification:

	/* handler: j.DisableNotification type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DisableNotification = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DisableNotification = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyToMessageID:

	/* handler: j.ReplyToMessageID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ReplyToMessageID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ReplyMarkup)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *SendStickerParameters) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *SendStickerParameters) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "chat_id":`)
	fflib.FormatBits2(buf, uint64(j.ChatID), 10, j.ChatID < 0)
	buf.WriteString(`,"sticker":`)
	/* Interface types must use runtime reflection. type=interface {} kind=interface */
	err = buf.Encode(j.Sticker)
	if err != nil {
		return err
	}
	buf.WriteByte(',')
	if j.DisableNotification != false {
		if j.DisableNotification {
			buf.WriteString(`"disable_notification":true`)
		} else {
			buf.WriteString(`"disable_notification":false`)
		}
		buf.WriteByte(',')
	}
	if j.ReplyToMessageID != 0 {
		buf.WriteString(`"reply_to_message_id":`)
		fflib.FormatBits2(buf, uint64(j.ReplyToMessageID), 10, j.ReplyToMessageID < 0)
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		buf.WriteString(`"reply_markup":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.ReplyMarkup)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtSendStickerParametersbase = iota
	ffjtSendStickerParametersnosuchkey

	ffjtSendStickerParametersChatID

	ffjtSendStickerParametersSticker

	ffjtSendStickerParametersDisableNotification

	ffjtSendStickerParametersReplyToMessageID

	ffjtSendStickerParametersReplyMarkup
)

var ffjKeySendStickerParametersChatID = []byte("chat_id")

var ffjKeySendStickerParametersSticker = []byte("sticker")

var ffjKeySendStickerParametersDisableNotification = []byte("disable_notification")

var ffjKeySendStickerParametersReplyToMessageID = []byte("reply_to_message_id")

var ffjKeySendStickerParametersReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *SendStickerParameters) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *SendStickerParameters) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtSendStickerParametersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtSendStickerParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeySendStickerParametersChatID, kn) {
						currentKey = ffjtSendStickerParametersChatID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeySendStickerParametersDisableNotification, kn) {
						currentKey = ffjtSendStickerParametersDisableNotification
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeySendStickerParametersReplyToMessageID, kn) {
						currentKey = ffjtSendStickerParametersReplyToMessageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendStickerParametersReplyMarkup, kn) {
						currentKey = ffjtSendStickerParametersReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeySendStickerParametersSticker, kn) {
						currentKey = ffjtSendStickerParametersSticker
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeySendStickerParametersReplyMarkup, kn) {
					currentKey = ffjtSendStickerParametersReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendStickerParametersReplyToMessageID, kn) {
					currentKey = ffjtSendStickerParametersReplyToMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendStickerParametersDisableNotification, kn) {
					currentKey = ffjtSendStickerParametersDisableNotification
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendStickerParametersSticker, kn) {
					currentKey = ffjtSendStickerParametersSticker
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySendStickerParametersChatID, kn) {
					currentKey = ffjtSendStickerParametersChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtSendStickerParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtSendStickerParametersChatID:
					goto handle_ChatID

				case ffjtSendStickerParametersSticker:
					goto handle_Sticker

				case ffjtSendStickerParametersDisableNotification:
					goto handle_DisableNotification

				case ffjtSendStickerParametersReplyToMessageID:
					goto handle_ReplyToMessageID

				case ffjtSendStickerParametersReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtSendStickerParametersnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ChatID:

	/* handler: j.ChatID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ChatID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sticker:

	/* handler: j.Sticker type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Sticker)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DisableNotification:

	/* handler: j.DisableNotification type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DisableNotification = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DisableNotification = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyToMessageID:

	/* handler: j.ReplyToMessageID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ReplyToMessageID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ReplyMarkup)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *SendVenueParameters) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *SendVenueParameters) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "chat_id":`)
	fflib.FormatBits2(buf, uint64(j.ChatID), 10, j.ChatID < 0)
	buf.WriteString(`,"latitude":`)
	fflib.AppendFloat(buf, float64(j.Latitude), 'g', -1, 32)
	buf.WriteString(`,"longitude":`)
	fflib.AppendFloat(buf, float64(j.Longitude), 'g', -1, 32)
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteString(`,"address":`)
	fflib.WriteJsonString(buf, string(j.Address))
	buf.WriteByte(',')
	if len(j.FoursquareID) != 0 {
		buf.WriteString(`"foursquare_id":`)
		fflib.WriteJsonString(buf, string(j.FoursquareID))
		buf.WriteByte(',')
	}
	if len(j.FoursquareType) != 0 {
		buf.WriteString(`"foursquare_type":`)
		fflib.WriteJsonString(buf, string(j.FoursquareType))
		buf.WriteByte(',')
	}
	if j.DisableNotification != false {
		if j.DisableNotification {
			buf.WriteString(`"disable_notification":true`)
		} else {
			buf.WriteString(`"disable_notification":false`)
		}
		buf.WriteByte(',')
	}
	if j.ReplyToMessageID != 0 {
		buf.WriteString(`"reply_to_message_id":`)
		fflib.FormatBits2(buf, uint64(j.ReplyToMessageID), 10, j.ReplyToMessageID < 0)
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			/* Struct fall back. type=telegram.InlineKeyboardMarkup kind=struct */
			buf.WriteString(`"reply_markup":`)
			err = buf.Encode(j.ReplyMarkup)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtSendVenueParametersbase = iota
	ffjtSendVenueParametersnosuchkey

	ffjtSendVenueParametersChatID

	ffjtSendVenueParametersLatitude

	ffjtSendVenueParametersLongitude

	ffjtSendVenueParametersTitle

	ffjtSendVenueParametersAddress

	ffjtSendVenueParametersFoursquareID

	ffjtSendVenueParametersFoursquareType

	ffjtSendVenueParametersDisableNotification

	ffjtSendVenueParametersReplyToMessageID

	ffjtSendVenueParametersReplyMarkup
)

var ffjKeySendVenueParametersChatID = []byte("chat_id")

var ffjKeySendVenueParametersLatitude = []byte("latitude")

var ffjKeySendVenueParametersLongitude = []byte("longitude")

var ffjKeySendVenueParametersTitle = []byte("title")

var ffjKeySendVenueParametersAddress = []byte("address")

var ffjKeySendVenueParametersFoursquareID = []byte("foursquare_id")

var ffjKeySendVenueParametersFoursquareType = []byte("foursquare_type")

var ffjKeySendVenueParametersDisableNotification = []byte("disable_notification")

var ffjKeySendVenueParametersReplyToMessageID = []byte("reply_to_message_id")

var ffjKeySendVenueParametersReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *SendVenueParameters) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *SendVenueParameters) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtSendVenueParametersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtSendVenueParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeySendVenueParametersAddress, kn) {
						currentKey = ffjtSendVenueParametersAddress
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeySendVenueParametersChatID, kn) {
						currentKey = ffjtSendVenueParametersChatID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeySendVenueParametersDisableNotification, kn) {
						currentKey = ffjtSendVenueParametersDisableNotification
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeySendVenueParametersFoursquareID, kn) {
						currentKey = ffjtSendVenueParametersFoursquareID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendVenueParametersFoursquareType, kn) {
						currentKey = ffjtSendVenueParametersFoursquareType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeySendVenueParametersLatitude, kn) {
						currentKey = ffjtSendVenueParametersLatitude
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendVenueParametersLongitude, kn) {
						currentKey = ffjtSendVenueParametersLongitude
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeySendVenueParametersReplyToMessageID, kn) {
						currentKey = ffjtSendVenueParametersReplyToMessageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySendVenueParametersReplyMarkup, kn) {
						currentKey = ffjtSendVenueParametersReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeySendVenueParametersTitle, kn) {
						currentKey = ffjtSendVenueParametersTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeySendVenueParametersReplyMarkup, kn) {
					currentKey = ffjtSendVenueParametersReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendVenueParametersReplyToMessageID, kn) {
					currentKey = ffjtSendVenueParametersReplyToMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendVenueParametersDisableNotification, kn) {
					currentKey = ffjtSendVenueParametersDisableNotification
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendVenueParametersFoursquareType, kn) {
					currentKey = ffjtSendVenueParametersFoursquareType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendVenueParametersFoursquareID, kn) {
					currentKey = ffjtSendVenueParametersFoursquareID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySendVenueParametersAddress, kn) {
					currentKey = ffjtSendVenueParametersAddress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySendVenueParametersTitle, kn) {
					currentKey = ffjtSendVenueParametersTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySendVenueParametersLongitude, kn) {
					currentKey = ffjtSendVenueParametersLongitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySendVenueParametersLatitude, kn) {
					currentKey = ffjtSendVenueParametersLatitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySendVenueParametersChatID, kn) {
					currentKey = ffjtSendVenueParametersChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtSendVenueParametersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtSendVenueParametersChatID:
					goto handle_ChatID

				case ffjtSendVenueParametersLatitude:
					goto handle_Latitude

				case ffjtSendVenueParametersLongitude:
					goto handle_Longitude

				case ffjtSendVenueParametersTitle:
					goto handle_Title

				case ffjtSendVenueParametersAddress:
					goto handle_Address

				case ffjtSendVenueParametersFoursquareID:
					goto handle_FoursquareID

				case ffjtSendVenueParametersFoursquareType:
					goto handle_FoursquareType

				case ffjtSendVenueParametersDisableNotification:
					goto handle_DisableNotification

				case ffjtSendVenueParametersReplyToMessageID:
					goto handle_ReplyToMessageID

				case ffjtSendVenueParametersReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtSendVenueParametersnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ChatID:

	/* handler: j.ChatID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ChatID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Latitude:

	/* handler: j.Latitude type=float32 kind=float32 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Latitude = float32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Longitude:

	/* handler: j.Longitude type=float32 kind=float32 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Longitude = float32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Address:

	/* handler: j.Address type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Address = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FoursquareID:

	/* handler: j.FoursquareID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FoursquareID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FoursquareType:

	/* handler: j.FoursquareType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FoursquareType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DisableNotification:

	/* handler: j.DisableNotification type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DisableNotification = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DisableNotification = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyToMessageID:

	/* handler: j.ReplyToMessageID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ReplyToMessageID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=telegram.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		/* Falling back. type=telegram.InlineKeyboardMarkup kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ReplyMarkup)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
